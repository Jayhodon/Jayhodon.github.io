<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Node.js相关</title>
      <link href="/2024/05/10/NodeJS/"/>
      <url>/2024/05/10/NodeJS/</url>
      
        <content type="html"><![CDATA[<h3 id="Node-js相关"><a href="#Node-js相关" class="headerlink" title="Node.js相关"></a>Node.js相关</h3><h4 id="Node-js的三大特性"><a href="#Node-js的三大特性" class="headerlink" title="Node.js的三大特性"></a>Node.js的三大特性</h4><p>Node.js 的三大特性通常被总结为其非阻塞的 I/O 模型、单线程事件循环以及跨平台性。这些特性使得 Node.js 在处理高并发、I/O 密集型任务时表现出色，同时也为开发者提供了编写服务器端应用程序的灵活性和便捷性。</p><ol><li>非阻塞的 I/O 模型<ul><li>Node.js 采用了非阻塞的 I/O 模型，这意味着当 Node.js 执行 I/O 操作（如读取文件、网络请求等）时，它不会等待该操作完成再继续执行后续代码，而是会立即返回一个“正在处理”的标识，然后继续执行后续代码。当 I/O 操作完成时，Node.js 会通过事件和回调函数的方式通知应用程序进行相应的处理。</li><li>这种非阻塞的 I/O 模型使得 Node.js 能够高效地处理大量的并发请求，而不会像传统的多线程模型那样因为线程切换和同步阻塞而浪费大量的 CPU 时间。</li></ul></li><li>单线程事件循环<ul><li>Node.js 采用了单线程的事件循环机制来处理异步操作。这意味着在 Node.js 中，所有的代码都是在一个线程中执行的，包括同步代码和异步代码的回调函数。</li><li>当一个异步操作（如网络请求）被触发时，Node.js 会将其添加到事件队列中，并在适当的时候（如 I/O 操作完成）从事件队列中取出并执行相应的回调函数。</li><li>这种单线程事件循环的机制避免了多线程编程中的线程同步和线程安全问题，使得 Node.js 的代码更加简洁、易于理解和维护。</li></ul></li><li>跨平台性<ul><li>Node.js 是基于 V8 引擎（Google 开发的开源高性能 JavaScript 和 WebAssembly 引擎）构建的，因此具有跨平台的特性。只要安装了适合当前操作系统的 Node.js 运行时环境，就可以在任何支持 Node.js 的平台上运行 Node.js 应用程序。</li><li>这种跨平台的特性使得 Node.js 成为一种非常流行的服务器端开发技术，可以在不同的操作系统和硬件平台上运行和部署应用程序。</li></ul></li></ol><p>除了以上三大特性外，Node.js 还具有其他许多优点，如开源、社区支持丰富、生态系统庞大等，这些优点都使得 Node.js 成为一种非常受欢迎的服务器端开发技术。</p><h4 id="Node-js中事件循环的流程"><a href="#Node-js中事件循环的流程" class="headerlink" title="Node.js中事件循环的流程"></a>Node.js中事件循环的流程</h4><p>Node.js中的事件循环是其非阻塞I/O模型的核心组成部分，它负责调度执行各种回调函数。以下是Node.js事件循环的基本流程：</p><ol><li><p>初始化</p><ul><li>当Node.js应用程序启动时，它会初始化事件循环，加载需要的模块，并执行全局代码。</li></ul></li><li><p>进入事件循环</p><ul><li>一旦初始化完成，Node.js就会进入事件循环，开始监听各种事件。</li></ul></li><li><p>事件循环的阶段</p><ul><li>Node.js的事件循环分为多个阶段，每个阶段都有与之对应的事件队列。这些阶段按照特定的顺序执行，以处理不同类型的事件。</li></ul><p>Timers（定时器）</p><ul><li>此阶段执行setTimeout()和setInterval()的回调函数。</li></ul><p>Pending Callbacks（待定回调）</p><ul><li>执行延迟到下一个循环迭代的I/O回调。</li></ul><p>Idle, Prepare（空闲、准备）</p><ul><li>这两个阶段用于Node.js内部处理，通常不会对应用程序开发者产生影响。</li></ul><p>Poll（轮询）</p><ul><li>检索新的I/O事件；执行与I/O相关的回调（几乎所有回调，除了关闭回调、定时器回调和setImmediate()）；如果在此阶段没有可用的回调，并且脚本没有使用setImmediate()，则事件循环将等待回调被添加到队列中，或者直到定时器到期。</li></ul><p>Check（检查）</p><ul><li>执行setImmediate()的回调函数。</li></ul><p>Close Callbacks（关闭回调）</p><ul><li>执行例如socket.on(‘close’, …)的回调。</li></ul></li><li><p>执行回调</p><ul><li>在每个阶段，事件循环都会从相应的事件队列中取出事件并执行它们的回调函数。</li></ul></li><li><p>循环迭代</p><ul><li>一旦某个阶段的事件队列为空，事件循环就会进入下一个阶段。如果所有阶段都为空，并且没有定时器需要等待，则事件循环将暂停执行，直到出现新的I/O事件、定时器到期或者调用了process.nextTick()。</li></ul></li><li><p>process.nextTick()</p><ul><li>process.nextTick()是一个特殊的函数，它允许你将回调添加到下一个事件循环的顶部，无论当前事件循环的哪个阶段。这意味着在调用process.nextTick()后，你的回调函数会在任何I/O或定时器回调之前执行。</li></ul></li><li><p>退出事件循环</p><ul><li>当事件循环的队列为空，并且没有更多的工作要执行时（例如，没有挂起的定时器或未完成的I/O操作），Node.js将退出事件循环，并且应用程序将终止。</li></ul></li></ol><p>通过理解Node.js事件循环的工作流程，你可以更有效地编写异步代码，避免阻塞操作，并提高应用程序的性能和响应速度。</p><h4 id="Node-js中整个异步I-O的流程"><a href="#Node-js中整个异步I-O的流程" class="headerlink" title="Node.js中整个异步I/O的流程"></a>Node.js中整个异步I/O的流程</h4><p>Node.js中整个异步I/O的流程主要涉及到异步操作的发起、执行以及结果的处理。以下是该流程的基本步骤：</p><ol><li>发起异步I/O请求<ul><li>在Node.js中，当需要执行I/O操作（如读取文件、网络请求等）时，主线程会发起一个异步I/O请求。这个请求会被放入一个任务队列中等待执行。</li></ul></li><li>线程池处理I/O请求<ul><li>Node.js内部有一个线程池，用于处理I/O请求。当主线程发起异步I/O请求后，该请求会被推送到线程池中等待执行。线程池中的线程会负责实际的I/O操作，如读取文件内容、发送网络请求等。</li></ul></li><li>I/O操作完成并通知主线程<ul><li>当线程池中的线程完成I/O操作后，它会将结果封装成一个事件或消息，并将其放入事件队列中。这个事件队列与主线程的事件循环相关联。</li></ul></li><li>事件循环处理事件队列<ul><li>主线程的事件循环会不断检查事件队列中是否有待处理的事件。如果有，它会取出事件并调用相应的回调函数来处理该事件。在Node.js中，这个回调函数通常是我们在发起异步I/O请求时指定的。</li></ul></li><li>回调函数处理I/O结果<ul><li>当主线程从事件队列中取出I/O操作的事件时，它会调用与该事件关联的回调函数。这个回调函数会接收I/O操作的结果作为参数，并进行相应的处理。例如，如果我们发起了一个读取文件的异步I/O请求，并在回调函数中接收到了文件内容，那么我们就可以在回调函数中处理这个文件内容。</li></ul></li><li>继续执行后续代码<ul><li>在Node.js中，由于使用了异步I/O机制，主线程在发起I/O请求后可以立即继续执行后续的代码，而无需等待I/O操作完成。这大大提高了程序的并发性和响应速度。</li></ul></li></ol><p>需要注意的是，Node.js中的异步I/O操作是基于事件循环和回调函数实现的。事件循环负责监听事件队列中的事件并调用相应的回调函数来处理这些事件；而回调函数则负责处理I/O操作的结果并进行后续的逻辑处理。这种机制使得Node.js能够高效地处理大量的并发请求和I/O操作。</p><h4 id="模块化规范中require和import的区别"><a href="#模块化规范中require和import的区别" class="headerlink" title="模块化规范中require和import的区别"></a>模块化规范中require和import的区别</h4><p>在JavaScript的模块化规范中，<code>require</code> 和 <code>import</code> 是两种不同的模块导入（或称为“引入”）方式，它们主要存在于CommonJS和ES6（ECMAScript 2015）两种模块系统中。以下是它们之间的一些主要区别：</p><ol><li><p><strong>来源</strong>：</p><ul><li><code>require</code> 是 CommonJS 模块规范的一部分，主要在 Node.js 环境中使用。</li><li><code>import</code> 是 ES6（也称为ES2015）模块规范的一部分，是现代前端JavaScript项目中的常用方式，但也逐渐被一些现代的后端工具（如Deno）采用。</li></ul></li><li><p><strong>语法</strong>：</p><ul><li><code>require</code> 是一个函数调用，用于在运行时动态地加载和解析模块。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> moduleName <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'module-name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><code>import</code> 是一个静态声明，在编译时解析模块依赖，因此它不能用于在运行时根据条件动态地导入模块。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> moduleName <span class="token keyword">from</span> <span class="token string">'module-name'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 或者  </span><span class="token keyword">import</span> <span class="token punctuation">{</span> export1<span class="token punctuation">,</span> export2 <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'module-name'</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>默认导出</strong>：</p><ul><li>CommonJS 模块系统没有内建的默认导出机制，但可以通过将对象或值赋值给 <code>module.exports</code> 来导出。</li></ul><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> myObject<span class="token punctuation">;</span></code></pre><ul><li>ES6 模块系统支持默认导出，可以使用 <code>export default</code> 语法。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> myObject<span class="token punctuation">;</span></code></pre></li><li><p><strong>命名导出</strong>：</p><ul><li>CommonJS 可以通过 <code>module.exports</code> 导出多个命名属性。</li></ul><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>property1 <span class="token operator">=</span> value1<span class="token punctuation">;</span>  module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>property2 <span class="token operator">=</span> value2<span class="token punctuation">;</span></code></pre><ul><li>ES6 同样支持命名导出，但语法更为简洁。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">const</span> property1 <span class="token operator">=</span> value1<span class="token punctuation">;</span>  <span class="token keyword">export</span> <span class="token keyword">const</span> property2 <span class="token operator">=</span> value2<span class="token punctuation">;</span></code></pre></li><li><p><strong>动态导入</strong>：</p><ul><li>CommonJS 没有直接的动态导入机制（尽管可以通过某些方式模拟）。</li><li>ES6 提供了 <code>import()</code> 函数，允许在运行时（即在代码执行期间）动态地导入模块。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'module-name'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>module <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 使用模块  </span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 处理错误  </span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>循环依赖</strong>：</p><ul><li>CommonJS 处理循环依赖的方式可能导致一些问题，因为模块可能会在其依赖项完全解析之前就被部分导出。</li><li>ES6 模块规范对循环依赖有明确的处理机制，可以保证在循环依赖的情况下模块导出的一致性和正确性。</li></ul></li><li><p><strong>静态分析</strong>：</p><ul><li>由于 <code>import</code> 是静态的，它可以被静态分析工具（如构建工具、打包工具等）更有效地处理，从而优化打包和树摇（tree shaking）等过程。</li><li><code>require</code> 是动态的，因此在某些情况下可能不如 <code>import</code> 那样易于静态分析。</li></ul></li><li><p><strong>兼容性</strong>：</p><ul><li><code>require</code> 在传统的Node.js环境中广泛支持。</li><li><code>import</code> 在现代浏览器中广泛支持，但在Node.js中，直到较新的版本（v13及更高版本）才开始原生支持，之前需要使用转译器（如Babel）来支持。</li></ul></li></ol><p>在选择使用 <code>require</code> 还是 <code>import</code> 时，通常取决于你的项目环境和需求。在Node.js中，传统上使用 <code>require</code>，但随着Node.js对ES6模块的原生支持不断增强，<code>import</code> 的使用也越来越普遍。在前端项目中，<code>import</code> 几乎是唯一的选择。</p><h4 id="pnpm原理"><a href="#pnpm原理" class="headerlink" title="pnpm原理"></a>pnpm原理</h4><p>pnpm（Performance-focused Node Package Manager）是一个高性能的Node.js包管理器，它的原理主要基于硬链接和符号链接来管理依赖项，以提高安装速度和减少存储空间占用。以下是pnpm工作原理的详细解释：</p><ol><li><strong>本地缓存</strong>：pnpm在安装依赖项时，会先将它们缓存到本地存储空间中。这意味着当再次安装相同的依赖项时，pnpm会直接从本地缓存中读取，而不是重新从远程仓库下载。这种机制显著减少了网络带宽的使用，提高了安装速度。</li><li><strong>硬链接和符号链接</strong>：pnpm使用硬链接和符号链接来构建<code>node_modules</code>目录。具体来说，它将所有依赖项保存到单个位置（称为内容可寻址存储，CAS），并使用硬链接将这些依赖项链接到项目的<code>node_modules</code>目录中。对于需要多个版本的依赖项，pnpm会使用符号链接来确保它们指向正确的版本。这种机制避免了重复的依赖项，进一步减少了存储空间的占用。</li><li><strong>依赖关系解析</strong>：pnpm在解析依赖关系时，会首先检查项目根目录下的<code>package.json</code>文件，该文件包含了项目需要安装的依赖关系和其他配置信息。然后，pnpm会解析这些依赖关系，包括直接依赖和间接依赖，并根据这些依赖关系创建一个依赖关系树。这个依赖关系树是一个有向无环图，其中每个节点表示一个依赖项，边表示依赖关系。</li><li><strong>lockfile文件</strong>：与npm和yarn类似，pnpm也使用lockfile文件来锁定依赖项的版本。当执行<code>pnpm install</code>命令时，如果存在一个lockfile文件（例如<code>pnpm-lock.yaml</code>），pnpm将优先使用此文件来安装包，以确保版本的一致性。</li><li><strong>命令和操作</strong>：pnpm提供了与npm类似的命令和操作，如<code>pnpm install</code>（安装项目所需的所有包）、<code>pnpm add</code>（安装单个包并将其添加到项目的<code>dependencies</code>或<code>devDependencies</code>中）、<code>pnpm remove</code>（卸载项目中的包并将其从<code>dependencies</code>或<code>devDependencies</code>中删除）以及<code>pnpm update</code>（更新项目中的包）。此外，<code>pnpm run</code>命令也用于运行项目中的脚本。</li></ol><p>通过以上原理，pnpm在保持与npm和yarn相似的功能和使用体验的同时，显著提高了安装速度和减少了存储空间占用，成为了一个高效且实用的Node.js包管理器。</p><h4 id="node是单线程的，如何让他在多核CPU上跑满？"><a href="#node是单线程的，如何让他在多核CPU上跑满？" class="headerlink" title="node是单线程的，如何让他在多核CPU上跑满？"></a>node是单线程的，如何让他在多核CPU上跑满？</h4><p>虽然Node.js本身基于单线程模型，但我们可以使用多种策略来使其在多核CPU上实现更高的利用率，以下是几种常见的方法：</p><ol><li><p><strong>使用集群模块（Cluster Module）</strong>：<br>Node.js提供了一个内置的集群模块，它允许你创建多个子进程，每个子进程运行在一个独立的V8引擎实例上，并监听相同的端口。这样，你就可以将请求分发到不同的子进程，从而充分利用多核CPU资源。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> cluster <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cluster'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> os <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'os'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>cluster<span class="token punctuation">.</span>isMaster<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Master </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>process<span class="token punctuation">.</span>pid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is running`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Fork workers.  </span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> os<span class="token punctuation">.</span><span class="token function">cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      cluster<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     cluster<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'exit'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>worker<span class="token punctuation">,</span> code<span class="token punctuation">,</span> signal<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`worker </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>worker<span class="token punctuation">.</span>process<span class="token punctuation">.</span>pid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> died`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Workers can share any TCP connection  </span>  <span class="token comment" spellcheck="true">// In this case, it is an HTTP server  </span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./app.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li><li><p><strong>使用子进程（Child Processes）</strong>：<br>除了集群模块，你还可以使用<code>child_process</code>模块来创建子进程，每个子进程可以执行不同的任务或处理不同的请求。你可以通过<code>child_process.fork()</code>方法来创建一个新的Node.js进程，并通过进程间通信（IPC）来传递消息和数据。</p></li><li><p><strong>使用工作线程（Worker Threads）</strong>：<br>Node.js从v10.5.0版本开始支持工作线程（Worker Threads），这是一种在Node.js环境中运行JavaScript线程的方法。工作线程是独立于主线程的，它们有自己的V8实例，可以执行CPU密集型任务，而不会阻塞主线程。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token punctuation">{</span> Worker<span class="token punctuation">,</span> isMainThread<span class="token punctuation">,</span> parentPort<span class="token punctuation">,</span> workerData <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'worker_threads'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>isMainThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建一个工作线程  </span>  <span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">{</span> workerData<span class="token punctuation">:</span> <span class="token string">'hello'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     worker<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Received from worker:'</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     worker<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Worker error:'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     worker<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'exit'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Worker stopped with exit code'</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在工作线程中  </span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Worker started with'</span><span class="token punctuation">,</span> workerData<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 执行一些CPU密集型任务  </span>   parentPort<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'Hello from worker'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li><li><p><strong>使用外部服务</strong>：<br>对于某些任务，如数据库查询、图像处理或复杂的计算，你可以考虑将它们移到外部服务中，如微服务、队列系统（如RabbitMQ、Kafka）或云函数（如AWS Lambda）。这样，你就可以使用多个服务实例来处理这些任务，从而利用多核CPU和其他资源。</p></li><li><p><strong>优化代码和依赖项</strong>：<br>确保你的代码是高效的，并尽可能减少阻塞操作。使用异步I/O、事件驱动和回调来处理非阻塞操作。同时，优化你的依赖项，确保它们也是高效的，并尽可能减少不必要的依赖项。</p></li></ol><p>请注意，在尝试使Node.js在多核CPU上跑满时，需要谨慎权衡性能和复杂性。过多的子进程或线程可能会增加系统开销和复杂性，并可能导致性能下降或资源争用问题。因此，建议在实际应用中逐步增加并行度，并监控性能和资源使用情况。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 个人知识库 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React相关</title>
      <link href="/2024/03/21/React%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/03/21/React%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="React-高阶组件"><a href="#React-高阶组件" class="headerlink" title="React 高阶组件"></a>React 高阶组件</h3><h4 id="了解React的高阶组件吗"><a href="#了解React的高阶组件吗" class="headerlink" title="了解React的高阶组件吗"></a>了解React的高阶组件吗</h4><p>高阶组件（Higher-Order Components，简称HOC)是React中用于复用组件逻辑的一种高级技术。它并不是React API的一部分，而是从React的组件组合特性中衍生出来的一种模式。具体来说，高阶组件就是一个接收一个组件并返回另外一个新组件的函数。这个新的组件可以操作传入的组件的props，或者通过refs访问到组件实例，甚至可以提取和修改组件的state。</p><p>高阶组件主要有两种形式：属性代理（Props Proxy）和反向继承（Inheritance Inversion）。在属性代理中，高阶组件会接收一个React组件并返回一个新的组件，这个新组件会将接收到的props进行处理，然后再传递给原始组件。在反向继承中，高阶组件会继承原始组件，然后添加新的state或生命周期方法等。</p><p>高阶组件在React开发中有很多应用场景，比如操纵props、通过ref访问组件实例、提取state等。它们可以帮助我们更好地组织代码，提高组件的可复用性和可维护性。同时，高阶组件也是一种非常强大的抽象手段，可以帮助我们更好地理解和设计React应用。</p><p>当然，高阶组件（HOC）在React中提供了很大的灵活性，以下是如何使用高阶组件来操纵props、通过ref访问组件实例以及提取state的示例：</p><ol><li><strong>操纵props</strong></li></ol><p>高阶组件可以接收一个组件作为参数，并返回一个新的组件，这个新组件可以修改或增强传入的props。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">withEnhancedProps</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 操纵props  </span>      <span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span>          <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">,</span>          enhancedProp<span class="token punctuation">:</span> <span class="token string">'some enhanced value'</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span>newProps<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用高阶组件  </span><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>enhancedProp<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token keyword">const</span> EnhancedMyComponent <span class="token operator">=</span> <span class="token function">withEnhancedProps</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 渲染EnhancedMyComponent  </span><span class="token comment" spellcheck="true">// &lt;div>some enhanced value&lt;/div></span></code></pre><p><strong>2. 通过ref访问组件实例</strong></p><p>React推荐使用<code>React.forwardRef</code>和<code>useImperativeHandle</code>（在函数组件中）来暴露子组件的ref给父组件。但是，对于使用类组件的高阶组件，你可以直接在返回的组件内部使用<code>React.createRef</code>或<code>useRef</code>（在函数组件中）来创建ref，并附加到被包装的组件上。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">withRefForwarding</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">ForwardRefHOC</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>      wrappedInstance <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span> forwardedRef<span class="token punctuation">,</span> <span class="token operator">...</span>restProps <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>wrappedInstance<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>restProps<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 提供方法以访问被包装的组件实例  </span>    getWrappedInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>wrappedInstance<span class="token punctuation">.</span>current<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 使用React.forwardRef来确保ref被正确传递  </span>  <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> ref<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>ForwardRefHOC <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> forwardedRef<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用高阶组件  </span><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> ref<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span><span class="token operator">></span>Hello<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> RefForwardingComponent <span class="token operator">=</span> <span class="token function">withRefForwarding</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 渲染并访问实例  </span><span class="token keyword">const</span> ref <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...  </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问MyComponent的DOM元素</span></code></pre><p>注意：在React 16.3及以后的版本中，直接访问子组件实例通常不是推荐的做法，因为它破坏了封装性。但是，在某些情况下，如动画库或需要直接DOM访问的库，这可能是有用的。</p><p><strong>3. 提取state</strong></p><p>高阶组件通常不直接提取被包装组件的state，因为这违反了封装原则，并且React的state是私有的。但是，你可以通过props在被包装组件和高阶组件之间共享状态，或者使用如Redux、MobX或Context等状态管理库来在组件之间共享状态。</p><p>如果你确实需要“提取”state（这通常意味着你想在被包装组件外部管理其状态），那么你应该考虑使用状态提升（State Lifting）或上述提到的状态管理库。</p><p>记住，高阶组件是一种强大的模式，但它们应该谨慎使用，以避免过度嵌套和组件树变得难以理解。</p><h4 id="React中常用的高阶组件有哪些？"><a href="#React中常用的高阶组件有哪些？" class="headerlink" title="React中常用的高阶组件有哪些？"></a>React中常用的高阶组件有哪些？</h4><p>在React中，高阶组件（Higher-Order Components, HOC）是一个高级的概念，它允许你通过函数来操作并返回新的React组件。高阶组件并不是React API的一部分，而是一种基于React的组合特性而形成的模式。虽然React库本身并不提供预定义的高阶组件，但在许多实际场景中，你可以使用高阶组件来复用组件逻辑、修改组件的props、操作组件的状态等。</p><p>以下是一些常见的使用高阶组件的场景和示例：</p><blockquote><ol><li><p>属性代理（Props Proxy）</p><p>：</p><ul><li>高阶组件接收一个组件并返回一个新的组件，这个新组件将原始组件包裹在一个容器组件中，并控制原始组件接收的props。</li><li>示例：<code>withRouter</code>（React Router库提供），它给组件注入<code>history</code>对象，使其具备导航功能。</li></ul></li><li><p>操作props</p><p>：</p><ul><li>高阶组件接收原始组件的props，并对其进行修改、增强或添加新的props，然后将这些props传递给原始组件。</li><li>示例：<code>connect</code>（Redux库提供），它用于连接React组件到Redux store，将store中的state作为props注入到组件中，并允许组件触发actions来更新state。</li></ul></li><li><p>抽象state</p><p>：</p><ul><li>高阶组件可以管理原始组件的状态（state），并将其提取到高阶组件中。</li><li>示例：一个自定义的HOC可以接收一个无状态的组件，并为其添加本地状态，以便在不需要使用class组件的情况下管理状态。</li></ul></li><li><p>渲染劫持（Render Highjacking）</p><p>：</p><ul><li>高阶组件可以改变原始组件的渲染输出，而不必更改其实际的结构。</li><li>示例：一个HOC可以接收一个组件，并在其渲染结果周围添加额外的元素或样式。</li></ul></li><li><p>包装组件</p><p>：</p><ul><li>高阶组件可以接收一个组件，并返回一个新的组件，这个新组件在原始组件的基础上添加了额外的功能或行为。</li><li>示例：一个HOC可以接收一个组件，并为其添加错误边界（Error Boundaries）功能，以便在子组件树中捕获任何未处理的JavaScript错误。</li></ul></li><li><p>其他场景</p><p>：</p><ul><li>除了上述示例之外，你还可以使用高阶组件来实现许多其他功能，如权限控制、国际化、日志记录等。</li></ul></li></ol></blockquote><p>需要注意的是，虽然高阶组件在React中非常有用，但它们也可能导致组件树变得复杂和难以调试。因此，在使用高阶组件时，请确保你了解其工作原理和潜在的影响，并谨慎使用它们来构建你的应用程序。</p><h3 id="React-Diff-算法与-Fiber-架构"><a href="#React-Diff-算法与-Fiber-架构" class="headerlink" title="React Diff 算法与 Fiber 架构"></a>React Diff 算法与 Fiber 架构</h3><h4 id="react中的虚拟dom"><a href="#react中的虚拟dom" class="headerlink" title="react中的虚拟dom"></a>react中的虚拟dom</h4><p>React中的虚拟DOM（Virtual DOM）是一个关键的概念，它极大地提高了React应用的渲染性能。以下是对React虚拟DOM的详细解释：</p><blockquote><ol><li><p><strong>什么是DOM</strong>：DOM（Document Object Model）是用一颗逻辑树来表示一个文档，树的每个分支的终点都是一个节点。我们可以使用特定的方式（如编写JS、CSS、HTML）来改变这个树的结构，从而改变文档结构、样式或内容。</p></li><li><p><strong>虚拟DOM的概念</strong>：虚拟DOM就是一个JS对象，通过对象的方式来表示DOM结构。React在内存中维护一个跟真实DOM一样的虚拟DOM树。在改动完组件后，React会再生成一个新的虚拟DOM，并与原来的虚拟DOM进行对比，找出两个DOM树的不同之处（diff），然后在真实DOM上进行最小化的更新。</p></li><li><p><strong>虚拟DOM的工作原理</strong>：</p><ul><li><strong>渲染过程</strong>：React通过组件的render方法返回一个虚拟DOM树，并将其与之前的虚拟DOM进行对比。</li><li><strong>对比过程</strong>：React通过Diff算法（也称为协调算法）对比新旧虚拟DOM之间的差异，找出需要更新的部分，并生成一个patch对象。</li><li><strong>更新过程</strong>：React根据patch对象，对真实DOM进行最小化更新。</li></ul></li><li><p><strong>虚拟DOM的优劣</strong>：</p><ul><li><p>优点</p><p>：</p><ul><li>减少了不必要的DOM操作：通过对比新旧虚拟DOM，React能够精确地知道哪些部分需要更新，从而避免了不必要的DOM重排和重绘。</li><li>提高了渲染性能：由于只在数据发生变化时才会更新Real DOM，相比于直接操作Real DOM，节约了更多的资源消耗。</li></ul></li><li><p>缺点</p><p>：</p><ul><li>需要额外的计算开销：使用虚拟DOM需要进行额外的计算来构建和比较虚拟DOM树，这可能会造成一定的计算开销。</li><li>内存消耗：在内存中维护一个虚拟DOM树需要额外的内存空间。</li></ul></li></ul></li></ol></blockquote><p>总的来说，React的虚拟DOM技术使得React能够更高效地处理UI的更新和渲染，从而提高了应用的性能。</p><h4 id="react栈调和、diff算法说一下"><a href="#react栈调和、diff算法说一下" class="headerlink" title="react栈调和、diff算法说一下"></a>react栈调和、diff算法说一下</h4><p>在React中，”调和”（Reconciliation）和”Diff算法”（Diffing Algorithm）是两个紧密相关的概念，它们共同构成了React用于更新DOM的核心机制。以下是对这两个概念的详细解释：</p><p><strong>调和（Reconciliation）</strong></p><p>调和是React用来确定何时以及如何更新UI的过程。当React组件的props或state发生变化时，React会重新调用该组件的render方法，并生成一个新的虚拟DOM树。然后，React会使用一种称为“调和”的过程来比较新的虚拟DOM树和旧的虚拟DOM树，找出两者之间的差异。</p><p>这个过程的核心是React的Diff算法，它用于高效地找出两个树之间的差异。一旦React确定了需要更新的部分，它就会将这些差异转换为一组DOM操作，并将它们添加到一个更新队列中。然后，React会等待浏览器空闲时间，开始执行更新队列中的DOM操作，从而更新真实的DOM树。</p><p><strong>Diff算法</strong></p><p>Diff算法是React用来比较两个虚拟DOM树并找出差异的具体实现。React的Diff算法基于三个主要的策略，这些策略使得React能够以O(n)的时间复杂度来高效地处理大多数常见的UI更新场景：</p><blockquote><ol><li><strong>Tree Diff</strong>：React通过updateDepth对虚拟DOM树进行层级控制，并且只比较同一层次的节点。由于Web UI中DOM节点跨层级的移动操作特别少，因此这个策略可以大大减少不必要的比较。</li><li><strong>Component Diff</strong>：React假设拥有相同类的两个组件会生成相似的树形结构，而拥有不同类的两个组件会生成完全不同的树形结构。因此，在比较两个组件时，React会首先检查它们的类型是否相同。如果类型相同，React会继续使用Diff算法来比较它们的子节点；如果类型不同，React则会卸载旧的组件并挂载新的组件。</li><li><strong>Element Diff</strong>：对于同一层级的一组子节点，React通过唯一的key来进行区分。如果子节点的key相同，React会假设它们是同一个节点，并尝试对其进行复用。这种策略可以大大提高列表渲染的性能。</li></ol></blockquote><p>通过这些策略，React的Diff算法能够在大多数情况下以O(n)的时间复杂度高效地找出两个虚拟DOM树之间的差异。然后，React会将这些差异转换为一组DOM操作，并更新真实的DOM树。这个过程使得React能够在保持高性能的同时，为用户提供流畅的UI体验。</p><h4 id="React中的Fiber架构"><a href="#React中的Fiber架构" class="headerlink" title="React中的Fiber架构"></a>React中的Fiber架构</h4><p>React中的Fiber架构是React 16及后续版本引入的一个新的核心算法，旨在解决React 15及以前版本中遇到的性能问题，特别是在处理大型或复杂的React应用程序时。Fiber架构为React应用程序带来了更高的灵活性和可扩展性，以及更好的性能和交互体验。</p><p>Fiber架构的关键原理和特点包括：</p><blockquote><ol><li><strong>可中断的更新</strong>：Fiber架构将渲染过程分解为多个步骤，并允许在每个步骤中暂停、中断或者优先级调度。这确保了React在处理更新时能够及时响应用户输入、动画和其他高优先级任务，从而提高了应用的响应性和流畅性。</li><li><strong>优先级调度</strong>：Fiber架构支持基于优先级的调度，允许开发者为不同类型的更新设置不同的优先级。React使用任务队列来存储待执行的任务，每个任务都带有一个优先级级别。这使得React能够更好地管理任务的执行顺序，确保高优先级的任务得到优先处理。</li><li><strong>增量渲染</strong>：Fiber架构可以将渲染工作拆分成多个时间片段执行，使得每个时间片段都有机会插入其他优先级更高的任务。这样，React可以在保证页面响应性的同时，尽可能快地完成渲染工作。</li><li><strong>协调器和调度器</strong>：Fiber架构包含了两个核心部分：协调器（Reconciler）和调度器（Scheduler）。协调器负责处理组件更新的逻辑，包括构建Fiber树、执行更新、生成副作用等；调度器负责处理更新的调度和优先级，决定何时执行更新以及以何种优先级执行更新。</li></ol></blockquote><p>通过引入Fiber架构，React能够更高效地处理任务优先级，提高页面的响应性，减少卡顿的情况。同时，Fiber架构也使得React应用程序能够更加灵活和可扩展，能够更好地处理大型应用程序的渲染和交互需求。</p><p>总的来说，Fiber架构是React为了解决性能问题而引入的一个新的核心算法，它通过可中断的更新、优先级调度、增量渲染等机制，提高了React应用程序的性能和交互体验。</p><h4 id="React-Fiber在哪个过程是可以中断的？"><a href="#React-Fiber在哪个过程是可以中断的？" class="headerlink" title="React Fiber在哪个过程是可以中断的？"></a>React Fiber在哪个过程是可以中断的？</h4><p>React Fiber在渲染过程中是可以中断的。具体来说，React Fiber将渲染任务划分成多个小任务，每个小任务一般只负责一小部分DOM更新。这些小任务被保存到任务队列中，并按照优先级进行排序和调度。</p><p>当浏览器处于空闲状态时，React Fiber会从任务队列中取出一个高优先级的任务并执行。然而，这个过程是可以中断的。如果任务在执行过程中遇到优先级更高的任务，或者浏览器需要处理其他事件（如用户输入、动画等），React Fiber会暂停当前任务的执行，转而执行优先级更高的任务或者响应浏览器事件。</p><p>当优先级更高的任务完成后，或者浏览器事件处理完毕后，React Fiber会回到之前暂停的任务，继续执行直到任务完成或者时间片用完。如果时间片用完，React Fiber会将任务挂起，并将未完成的工作保存到Fiber树中，返回控制权给浏览器。</p><p>因此，React Fiber通过任务分割和任务优先级算法，实现了渲染过程的中断和恢复，保证了应用程序的响应性和性能，提高了用户的使用体验。</p><h4 id="React框架的特点是什么，跟传统的框架对比？"><a href="#React框架的特点是什么，跟传统的框架对比？" class="headerlink" title="React框架的特点是什么，跟传统的框架对比？"></a>React框架的特点是什么，跟传统的框架对比？</h4><p>React框架的特点主要体现在以下几个方面，与传统框架相比，它有着显著的优势：</p><blockquote><ol><li><strong>声明式设计</strong>：React使得创建交互式UI变得轻而易举。通过为应用的每一个状态设计简洁的视图，当数据变动时，React能够高效更新并渲染合适的组件。这种声明式的设计方式使得开发者能够更专注于描述UI应该呈现的样子，而不是手动操作DOM来更新UI。</li><li><strong>组件化</strong>：React构建的是管理自身状态的封装组件，这些组件可以组合起来以构成复杂的UI。这种组件化的开发方式使得代码更加可复用、可测试和可维护。相比之下，传统框架可能更侧重于整体的页面或功能开发，而React则更加注重于构建可复用的组件。</li><li><strong>高效</strong>：React通过对DOM的模拟（即虚拟DOM），最大限度地减少了与DOM的交互。当组件的状态发生变化时，React会创建一个新的虚拟DOM树，并与旧的树进行对比，找出需要更新的部分，然后只更新这些部分。这种差异算法使得React在渲染大型UI时依然能够保持高效。而传统框架在直接操作DOM时可能会面临性能问题。</li><li><strong>灵活</strong>：React非常灵活，可以轻松地与其他技术栈集成。无论你现在使用什么技术栈，都可以在无需重写现有代码的前提下，通过引入React来开发新功能。这种灵活性使得React成为了一个非常受欢迎的前端框架。</li></ol></blockquote><p>与传统框架相比，React还具有以下优势：</p><blockquote><ul><li><strong>学习曲线相对陡峭但上手快</strong>：React的学习曲线相对陡峭，需要掌握JSX语法和组件开发的概念。但对于有JavaScript经验的开发者而言，React可能更容易上手。一旦掌握了React的基本概念和工具链（如Redux、React Router等），开发者就能够快速地构建出高质量的Web应用。</li><li><strong>生态系统庞大</strong>：React拥有一个庞大的生态系统，提供了许多功能强大的第三方库和插件。这些库和插件可以帮助开发者解决各种常见问题和需求，如状态管理、路由、表单处理、数据获取等。相比之下，一些传统框架可能没有这么完善的生态系统支持。</li><li><strong>支持服务器端渲染（SSR）和移动端开发</strong>：React不仅支持传统的客户端渲染方式，还支持服务器端渲染（SSR）和移动端开发。通过React Native项目，开发者可以使用相同的React代码库来构建原生移动应用。这种跨平台的能力使得React成为了一个非常强大的工具链。</li></ul></blockquote><p>总之，React框架以其声明式设计、组件化、高效和灵活等特点，以及庞大的生态系统和跨平台能力，成为了现代Web开发中的重要一环。</p><h4 id="React框架渲染层面有什么特别，跟document-的方式有什么区别吗？"><a href="#React框架渲染层面有什么特别，跟document-的方式有什么区别吗？" class="headerlink" title="React框架渲染层面有什么特别，跟document 的方式有什么区别吗？"></a>React框架渲染层面有什么特别，跟document 的方式有什么区别吗？</h4><p>React框架在渲染层面的特点主要体现在其独特的虚拟DOM（Virtual DOM）机制和并发渲染机制上，这些机制使得React在处理复杂的UI更新时能够保持高效和可响应性。与直接使用document对象进行DOM操作的方式相比，React的渲染方式具有以下区别和优势：</p><blockquote><blockquote></blockquote><ol><li>虚拟DOM（Virtual DOM）：<ul><li>React会先将你的代码转换成一个JavaScript对象来模拟DOM中的节点，这个JavaScript对象就是虚拟DOM。当React组件的状态发生变化时，它会重新生成一个新的虚拟DOM树，并与旧的虚拟DOM树进行对比（通过diff算法），找出需要更新的部分。</li><li>与直接使用document对象操作DOM相比，虚拟DOM的优势在于它避免了不必要的DOM操作。因为虚拟DOM的对比和更新是在JavaScript层面进行的，所以速度非常快。只有当需要更新真实的DOM时，React才会将变更应用到实际的DOM上，从而提高了渲染性能。</li></ul></li><li>并发渲染机制：<ul><li>React的并发渲染机制主要目标是根据用户的设备性能和网速对渲染过程进行适当的调整，帮助应用始终保持可响应。它能够优先执行高优先级变更，避免页面出现卡顿或无响应的情况，从而提升用户体验。</li><li>在并发渲染模式下，React可以将渲染任务拆分成多个较小的任务，并在不同的时间片中执行这些任务。这样即使在高负载的情况下，React也能保持应用的流畅性和可交互性。</li></ul></li><li>与document对象操作DOM的区别：<ul><li>使用document对象直接操作DOM时，开发者需要手动管理DOM元素的创建、更新和删除等操作。这种方式不仅繁琐易错，而且在处理复杂的UI更新时容易导致性能问题。</li><li>相比之下，React通过虚拟DOM和并发渲染机制将开发者从繁琐的DOM操作中解放出来。开发者只需要关心组件的状态和UI表现即可，React会自动处理虚拟DOM的对比和更新操作，并在必要时将变更应用到真实的DOM上。</li></ul></li></ol></blockquote><p>综上所述，React框架在渲染层面的特点主要体现在其独特的虚拟DOM机制和并发渲染机制上。这些机制使得React在处理复杂的UI更新时能够保持高效和可响应性，从而提高了开发效率和用户体验。</p><h3 id="React组件通信"><a href="#React组件通信" class="headerlink" title="React组件通信"></a>React组件通信</h3><h4 id="React中的组件通信有哪些方法？"><a href="#React中的组件通信有哪些方法？" class="headerlink" title="React中的组件通信有哪些方法？"></a>React中的组件通信有哪些方法？</h4><p>在React中，组件之间的通信是一个重要的概念，它允许组件之间共享数据和功能。以下是一些常用的React组件通信方法：</p><blockquote><ol><li><p>Props</p><p>：</p><ul><li>这是最常用和基础的组件通信方式。父组件通过props将数据传递给子组件，子组件通过<code>this.props</code>来访问这些数据。</li></ul></li><li><p>回调函数（Callback Functions）</p><p>：</p><ul><li>父组件可以通过在子组件上传递一个回调函数作为props，让子组件在需要时调用该函数，并将数据作为参数传递回去。这样，子组件就能够将数据发送回父组件。</li></ul></li><li><p>Context</p><p>：</p><ul><li>当需要在多个层级的组件之间共享数据时，可以使用React的Context API。它允许你声明性地在组件树之间共享值，而无需显式地通过每一层组件传递props。</li></ul></li><li><p>Redux 或其他状态管理库</p><p>：</p><ul><li>对于更复杂的应用程序，可能需要使用Redux或其他状态管理库来管理全局状态。这些库提供了一个集中的地方来存储和管理应用程序的状态，并提供了一种机制来订阅状态的变化和触发状态更新。</li></ul></li><li><p>事件冒泡（Event Bubbling）</p><p>：</p><ul><li>在DOM中，事件可以通过冒泡机制从子组件传播到父组件。React也支持这种机制，因此你可以通过自定义事件或DOM事件在组件之间传递信息。</li></ul></li><li><p>Refs</p><p>：</p><ul><li>虽然refs主要用于直接访问DOM节点或React元素实例，但也可以用来在父子组件之间建立直接的引用关系。然而，由于这破坏了组件的封装性，通常不建议过度使用refs进行组件通信。</li></ul></li><li><p>Render Props</p><p>：</p><ul><li>Render props是一种在React中共享代码的模式。它允许你将一个组件的渲染逻辑作为子组件传递给另一个组件，并在该组件中渲染它。这可以用于在组件之间传递渲染相关的函数或数据。</li></ul></li><li><p>兄弟组件通信</p><p>：</p><ul><li>对于兄弟组件之间的通信，通常需要使用一个共同的父组件作为中介。父组件可以维护它们共享的状态，并通过props将数据传递给子组件。子组件可以通过回调函数或其他机制将数据发送回父组件，然后由父组件再将数据传递给其他子组件。</li></ul></li></ol></blockquote><p>请注意，每种方法都有其适用场景和优缺点。在选择适当的通信方法时，请根据你的应用程序的具体需求和结构进行权衡。</p><h4 id="React中的受控组件与非受控组件"><a href="#React中的受控组件与非受控组件" class="headerlink" title="React中的受控组件与非受控组件"></a>React中的受控组件与非受控组件</h4><p>React中的受控组件（Controlled Components）和非受控组件（Uncontrolled Components）是两种处理表单输入数据的不同方式。</p><blockquote><blockquote></blockquote><ol><li><strong>受控组件</strong>：<ul><li>受控组件是由React组件完全控制的表单元素。其值由React组件的状态（state）进行管理，这意味着组件的状态会用于存储和更新表单元素的值。</li><li>在受控组件中，你需要在组件的状态中设置表单元素的初始值，并通过监听表单元素的变化事件（如onChange）来更新组件的状态。当表单元素的值改变时，事件处理器会触发，并更新组件的状态。由于值受到状态的控制，你可以在事件处理器中执行验证和处理逻辑，并在状态更新后对值进行处理。</li><li>需要对组件的value值进行修改时，使用受控组件是一个很好的选择。例如，如果你有一个按钮，每次点击时受控组件的值需要增加，那么受控组件是一个合适的选择。</li></ul></li><li><strong>非受控组件</strong>：<ul><li>非受控组件是由DOM自身管理和处理的表单元素。React组件不直接追踪或管理表单元素的状态，而是通过引用（ref）来访问表单元素的值和状态。</li><li>在非受控组件中，你不需要设置value属性，而是直接通过ref来访问DOM元素并获取其值。这使得非受控组件更接近于传统的HTML表单，组件无需为每个用户输入事件创建事件处理函数，而是直接从DOM中读取值。</li><li>在某些情况下，使用非受控组件可能更为方便，例如当你不关心表单元素值的中间状态，或者当表单元素是由第三方库提供且难以或无法直接控制其值时。</li></ul></li></ol></blockquote><p>总的来说，受控组件和非受控组件在React中都有其应用场景。受控组件提供了更大的灵活性和对表单元素值的控制，而非受控组件则更简洁并更接近传统的HTML表单处理方式。在选择使用哪种组件时，你需要根据具体的应用场景和需求来做出决策。</p><h4 id="React中为什么要劫持事件？"><a href="#React中为什么要劫持事件？" class="headerlink" title="React中为什么要劫持事件？"></a>React中为什么要劫持事件？</h4><p>React中劫持事件（或称为事件代理）的主要原因是为了提高性能和简化事件处理。以下是关于React劫持事件的几个关键点：</p><blockquote><blockquote></blockquote><ol><li><strong>性能优化</strong>：在React中，事件处理程序不是直接绑定到每个DOM元素上的，而是被注册在组件的顶层。这意味着React维护一个事件监听器，而不是在每个DOM元素上都添加监听器。当事件发生时，React使用事件代理技术来确定哪个组件应该接收这个事件，并触发相应的事件处理程序。这种方法减少了内存使用和DOM操作，从而提高了性能。</li><li><strong>简化事件处理</strong>：通过事件代理，React提供了一个统一的接口来处理DOM事件。无论在哪个DOM元素上触发事件，事件处理程序都会以相同的方式接收事件对象，这消除了处理不同浏览器和DOM元素之间事件差异的需要。React的合成事件对象（SyntheticEvent）提供了一致性接口，使开发者能够更容易地访问事件的相关信息。</li><li><strong>支持事件冒泡和捕获</strong>：React的事件系统也支持事件冒泡和捕获阶段。这意味着开发者可以选择在事件的不同阶段处理事件，这提供了更大的灵活性和控制力。</li><li><strong>阻止默认行为和停止冒泡</strong>：在React的合成事件对象中，提供了方法来阻止事件的默认行为（<code>event.preventDefault()</code>）和停止事件冒泡（<code>event.stopPropagation()</code>）。这使得开发者能够更精细地控制事件的行为。</li></ol></blockquote><p>总之，React劫持事件是为了提高性能、简化事件处理、支持事件冒泡和捕获以及提供阻止默认行为和停止冒泡的能力。这种机制使得React在处理DOM事件时更加高效和灵活。</p><h3 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h3><h4 id="React16之后的生命周期，之前呢？"><a href="#React16之后的生命周期，之前呢？" class="headerlink" title="React16之后的生命周期，之前呢？"></a>React16之后的生命周期，之前呢？</h4><p>React 16之前的生命周期主要包括三个阶段：初始化阶段、更新阶段和销毁阶段。以下是React 16之前的主要生命周期方法：</p><p><strong>初始化阶段</strong>：</p><blockquote><ol><li><code>getDefaultProps()</code>：用于设置组件的默认props，但在ES6的class语法中，这个方法不再使用，而是直接在constructor中定义默认值。</li><li><code>getInitialState()</code>：在使用ES6的class语法时，这个方法也被移除。可以直接在constructor中通过<code>this.state</code>来定义初始状态。</li><li><code>componentWillMount()</code>：在组件挂载前调用，只调用一次。此时可以修改state，但不建议在此阶段进行异步操作或DOM操作，因为这些操作可能会引发问题。</li><li><code>render()</code>：创建并返回一个虚拟DOM，表示组件的输出。</li><li><code>componentDidMount()</code>：在组件挂载后立即调用，只调用一次。此时可以获取真实的DOM，并进行网络请求或DOM操作。</li></ol></blockquote><p><strong>更新阶段</strong>：</p><blockquote><ol><li><code>componentWillReceiveProps(nextProps)</code>：当组件的props发生变化时调用。此方法可以用来比较新的props和旧的props，并决定是否需要更新组件的状态。</li><li><code>shouldComponentUpdate(nextProps, nextState)</code>：在组件重新渲染前调用，返回一个布尔值来决定组件是否应该重新渲染。默认返回true，但可以通过此方法来优化性能。</li><li><code>componentWillUpdate(nextProps, nextState)</code>：在组件重新渲染前调用，但此时不能修改state或props。</li><li><code>componentDidUpdate(prevProps, prevState)</code>：在组件重新渲染后立即调用。此时可以访问到更新后的DOM。</li></ol></blockquote><p><strong>销毁阶段</strong>：</p><blockquote><ol><li><code>componentWillUnmount()</code>：在组件卸载前调用。可以在此阶段进行必要的清理工作，如取消网络请求、移除事件监听器等。</li></ol></blockquote><p>React 16及之后的版本对生命周期方法进行了重要的修改和更新。React 16.3版本引入了<code>getDerivedStateFromProps</code>和<code>getSnapshotBeforeUpdate</code>两个新的生命周期方法，并在React 17中计划弃用三个旧的生命周期方法（<code>componentWillMount</code>、<code>componentWillReceiveProps</code>和<code>componentWillUpdate</code>）。</p><h4 id="以下是React-16及之后版本的生命周期方法的概述："><a href="#以下是React-16及之后版本的生命周期方法的概述：" class="headerlink" title="以下是React 16及之后版本的生命周期方法的概述："></a>以下是React 16及之后版本的生命周期方法的概述：</h4><p><strong>挂载阶段（Mounting）</strong></p><blockquote><ol><li>**constructor(props)**：在创建和初始化组件时调用。常用于初始化state或绑定事件处理器。</li><li>**static getDerivedStateFromProps(props, state)**：这是一个静态方法，在组件实例化并插入DOM之前调用。它返回一个对象来更新state，或者返回null表示新的props不需要任何state更新。这个方法在<code>render</code>之前调用，并且无论是否调用<code>render</code>，都会调用它。</li><li>**render()**：用于渲染组件的UI。</li><li>**componentDidMount()**：在组件挂载后立即调用。常用于执行网络请求、DOM操作或添加事件监听器。</li></ol></blockquote><p><strong>更新阶段（Updating）</strong></p><blockquote><ol><li>**static getDerivedStateFromProps(props, state)**：在组件接收到新的props时调用（与挂载阶段相同）。</li><li>**shouldComponentUpdate(nextProps, nextState)**：返回一个布尔值，决定组件是否应该响应props或state的变化而重新渲染。默认返回<code>true</code>。</li><li>**render()**：根据新的props或state重新渲染组件的UI。</li><li>**getSnapshotBeforeUpdate(prevProps, prevState)**：在最新的props或state被渲染但实际的DOM更新尚未发生之前调用。它使组件能在可能的DOM变化之前从DOM捕获一些信息（例如，滚动位置）。这个方法返回一个值，该值将作为<code>componentDidUpdate()</code>的第三个参数。</li><li>**componentDidUpdate(prevProps, prevState, snapshotValue)**：在DOM更新后立即调用。如果组件实现了<code>getSnapshotBeforeUpdate()</code>，则它会传递该方法的返回值作为此方法的第三个参数。</li></ol></blockquote><p><strong>卸载阶段（Unmounting）</strong></p><blockquote><ol><li>**componentWillUnmount()**：在组件卸载及销毁之前调用。常用于执行清理操作，如清除定时器、取消网络请求或删除事件监听器。</li></ol></blockquote><p><strong>注意</strong></p><blockquote><ul><li><code>componentWillMount</code>、<code>componentWillReceiveProps</code>和<code>componentWillUpdate</code>这三个方法在React 16.3及以后的版本中被标记为“不安全”，因为它们可能会在异步渲染过程中引发问题。React 17计划正式弃用这三个方法，因此不建议在新的代码中使用它们。</li><li>如果你正在使用React 16.3之前的版本，并依赖于上述三个被标记为“不安全”的方法，建议迁移到新的生命周期方法或<code>componentDidUpdate</code>中处理相应的逻辑。</li></ul></blockquote><h4 id="React中函数组件使用哪些hook来代替生命周期"><a href="#React中函数组件使用哪些hook来代替生命周期" class="headerlink" title="React中函数组件使用哪些hook来代替生命周期"></a>React中函数组件使用哪些hook来代替生命周期</h4><p>在React中，函数组件并不直接拥有生命周期方法，因为它们是无状态的。然而，从React 16.8版本开始，引入了Hooks API，这使得函数组件能够拥有类似类组件的生命周期行为和其他功能。</p><p>要模拟类组件的生命周期，函数组件可以使用以下Hooks：</p><blockquote><ol><li><strong>useEffect</strong>：这个Hook相当于<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>这三个生命周期方法的组合。你可以在<code>useEffect</code>中进行一些副作用操作，比如DOM操作、网络请求、设置定时器等。在函数组件被挂载到DOM后，<code>useEffect</code>中的函数会执行（类似于<code>componentDidMount</code>）。当组件的props或state更新时，<code>useEffect</code>也会再次执行（类似于<code>componentDidUpdate</code>）。在组件卸载前，<code>useEffect</code>会清理它之前创建的副作用（类似于<code>componentWillUnmount</code>）。</li></ol></blockquote><p>例如：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 组件挂载后执行的代码  </span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Component mounted'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回一个清理函数，在组件卸载前执行  </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Component will unmount'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第二个参数是依赖项数组，空数组表示这个effect不依赖于任何props或state的变更  </span>    <span class="token comment" spellcheck="true">// ...  </span><span class="token punctuation">}</span></code></pre><ol><li><strong>useState</strong>：这个Hook用于在函数组件中添加状态。虽然函数组件本身是无状态的，但你可以使用<code>useState</code>来在函数组件中添加状态。每次调用<code>useState</code>都会返回一个状态变量和一个更新状态的函数。</li></ol><p>例如：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// ...  </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Count<span class="token punctuation">:</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span>Increment<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><ol><li><strong>useLayoutEffect</strong>：这个Hook与<code>useEffect</code>类似，但它会在所有的DOM变更之后同步调用effect。如果你需要在浏览器绘制之前同步地执行某些操作，可以使用<code>useLayoutEffect</code>。但是请注意，由于<code>useLayoutEffect</code>是同步执行的，所以它可能会阻塞浏览器的绘制，因此应该谨慎使用。</li></ol><p>以上这些Hooks可以帮助函数组件模拟类组件的生命周期行为，并添加状态和副作用操作。</p><h3 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h3><h4 id="React-v18中的hooks"><a href="#React-v18中的hooks" class="headerlink" title="React v18中的hooks"></a>React v18中的hooks</h4><p>React v18 引入了一些新的 Hooks 和对已有 Hooks 的改进，但主要的 Hooks 集合（如 <code>useState</code>、<code>useEffect</code>、<code>useContext</code> 等）仍然保持不变。然而，React v18 确实对 Hooks 的使用场景和并发模式进行了一些重要的扩展和优化。</p><p>在 React v18 中，有两个新的 Hooks 特别值得注意：</p><blockquote><ol><li>**<code>useTransition</code>**：<ul><li><code>useTransition</code> 是一个新的 Hook，它允许你在组件的状态更新时添加过渡效果。这个 Hook 接收一个函数（通常是一个更新状态的函数）和一个配置对象作为参数。</li><li>当状态更新时，<code>useTransition</code> 会尝试在一段时间内“延迟”这个更新，以便在这个时间内你可以展示一个过渡效果或者一个占位符。如果这段时间内又有新的状态更新发生，那么 React 会取消前一个过渡并等待下一个。</li><li>这个 Hook 非常适合用于处理那些可能导致 UI 闪烁或者用户体验不佳的长时间更新。</li></ul></li><li>**<code>useDeferredValue</code>**：<ul><li><code>useDeferredValue</code> 是另一个新的 Hook，它允许你创建一个“延迟”的值。这个值在初始渲染时会立即返回，但在后续的渲染中，React 会尝试延迟这个值的更新，以便在可能的情况下避免不必要的渲染。</li><li>这个 Hook 通常与 <code>useTransition</code> 一起使用，用于在过渡期间提供一个稳定的值。例如，你可以在输入框的 onChange 事件中使用 <code>useDeferredValue</code> 来延迟更新搜索建议列表的状态，以便在用户输入时不会立即触发搜索建议的更新。</li></ul></li></ol></blockquote><p>除了这两个新的 Hooks 之外，React v18 还对并发模式（Concurrent Mode）进行了更深入的集成和优化。在并发模式下，React 可以更智能地调度更新和渲染，以便在可能的情况下提供更好的用户体验。虽然并发模式本身并不直接涉及到 Hooks，但它确实为 Hooks 的使用提供了更多的可能性和场景。</p><p>请注意，为了充分利用 React v18 的新特性和改进，你可能需要更新你的 React 和相关的依赖库（如 ReactDOM）到最新版本，并确保你的代码与新的 API 和行为兼容。</p><h4 id="React中如何拿到函数组件的实例？"><a href="#React中如何拿到函数组件的实例？" class="headerlink" title="React中如何拿到函数组件的实例？"></a>React中如何拿到函数组件的实例？</h4><p>在React中，函数组件（Functional Components）与类组件（Class Components）的一个主要区别是，函数组件没有实例（instance）。函数组件仅仅是接收props并返回React元素的纯函数，它们没有生命周期方法、实例属性或状态。</p><p>然而，React Hooks（如<code>useState</code>、<code>useEffect</code>等）的引入使得函数组件能够拥有类似类组件的功能，而无需创建类。这些Hooks不是通过实例来访问的，而是直接在函数组件的作用域内调用。</p><p>如果你需要访问类似于类组件实例的某些东西（例如，访问某个特定的状态或副作用），你应该使用Hooks而不是尝试获取函数组件的实例。</p><p>例如，你可以使用<code>useState</code>来在函数组件中存储状态：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">MyFunctionalComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Count<span class="token punctuation">:</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span>Increment<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>在这个例子中，<code>count</code>状态被直接在函数组件的作用域内定义和使用，而不需要通过实例来访问。</p><p>如果你正在使用第三方库或API，该库或API需要访问组件实例，并且这个库还没有更新以支持Hooks，那么你可能需要将你的组件转换为类组件，或者查找该库的更新版本，该版本已经支持Hooks。</p><p>然而，大多数情况下，你应该能够使用Hooks来实现你需要的所有功能，而无需担心组件实例的问题。如果你发现自己在函数组件中需要类似实例的东西，那么很可能是Hooks（如<code>useRef</code>、<code>useContext</code>等）可以提供你需要的解决方案。</p><h4 id="React-memo：优化函数组件的性能"><a href="#React-memo：优化函数组件的性能" class="headerlink" title="React.memo：优化函数组件的性能"></a>React.memo：优化函数组件的性能</h4><p><code>React.memo</code> 是 React 提供的一个高阶组件（Higher-Order Component, HOC），用于对函数组件进行记忆化（memoization），从而提高组件的性能。当组件的 props 发生变化时，React 会决定是否重新渲染该组件。通过使用 <code>React.memo</code>，你可以告诉 React，如果组件的 props 没有发生变化，那么就不需要重新渲染该组件。</p><p>下面是如何使用 <code>React.memo</code> 来优化函数组件性能的示例：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> memo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* render using props */</span>    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 或者使用箭头函数  </span><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* render using props */</span>    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但是，有几个重要的点需要注意：</p><blockquote><ol><li><strong>浅比较</strong>：<code>React.memo</code> 使用浅比较（shallow comparison）来检查 props 是否发生变化。这意味着，如果 props 中的对象或数组是新的引用（即使它们的内容相同），React 也会认为 props 发生了变化，并重新渲染组件。为了解决这个问题，你可能需要在组件内部使用 <code>useMemo</code> 或其他技术来确保 props 对象的稳定性。</li><li><strong>性能权衡</strong>：虽然 <code>React.memo</code> 可以减少不必要的渲染，但它也会增加每次渲染时的比较成本。因此，只有在渲染开销很大，且 props 很少发生变化的情况下，使用 <code>React.memo</code> 才是有意义的。</li><li><strong>手动指定比较函数</strong>：<code>React.memo</code> 还接受一个可选的比较函数作为第二个参数。这个比较函数接收两个参数：<code>prevProps</code> 和 <code>nextProps</code>，并返回一个布尔值，表示这两个 props 是否相等。你可以使用这个比较函数来覆盖默认的浅比较行为。</li></ol></blockquote><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    return true if passing nextProps to render would return    the same result as passing prevProps to render,    otherwise return false    */</span>  <span class="token punctuation">}</span>    <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* render using props */</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> areEqual<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="4"><li><strong>与其他 Hooks 配合使用</strong>：<code>React.memo</code> 可以与 <code>useState</code>、<code>useEffect</code> 等其他 Hooks 配合使用，以进一步优化函数组件的性能。例如，你可以使用 <code>useMemo</code> 来记忆化一些计算昂贵的值，以减少不必要的计算。</li></ol><h4 id="React中的useMemo和memo"><a href="#React中的useMemo和memo" class="headerlink" title="React中的useMemo和memo"></a>React中的useMemo和memo</h4><p>React中的<code>useMemo</code>和<code>memo</code>都是优化工具，但它们的作用方式和使用场景有所不同。</p><ol><li><code>useMemo</code>：</li></ol><p><code>useMemo</code>是一个自定义的React Hook，它用于在函数组件中进行内存缓存和性能优化。它接收一个函数（通常是一个计算密集型函数）和一个依赖项数组作为参数。这个函数会返回一个记忆化的值，这个值是在函数首次运行或依赖项发生变化时计算的。如果依赖项没有变化，<code>useMemo</code>会返回上次计算的结果，从而避免不必要的重复计算。</p><p>例如，如果你有一个计算密集型函数<code>computeExpensiveValue</code>，它依赖于变量<code>a</code>和<code>b</code>，你可以使用<code>useMemo</code>来缓存其计算结果：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> useMemo<span class="token punctuation">,</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> setA<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> setB<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// ...  </span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>在这个例子中，只有当<code>a</code>或<code>b</code>发生变化时，<code>computeExpensiveValue</code>函数才会重新运行并计算结果。</p><ol><li><code>memo</code>：</li></ol><p><code>memo</code>是一个高阶组件（HOC），用于优化函数组件的渲染性能。它接收一个函数组件作为参数，并返回一个经过优化的新组件。<code>memo</code>会对组件的输入属性（props）进行浅比较。只有当组件的输入属性发生变化时，才会重新渲染该组件。如果输入属性没有变化，<code>memo</code>会直接返回上次渲染的结果，从而避免不必要的渲染。</p><p>例如，你可以使用<code>memo</code>来包装一个组件，确保它只在输入属性发生变化时才重新渲染：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> memo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> prop1<span class="token punctuation">,</span> prop2 <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...  </span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">memo</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这个例子中，只有当<code>prop1</code>或<code>prop2</code>发生变化时，<code>MyComponent</code>才会重新渲染。</p><p>总的来说，<code>useMemo</code>和<code>memo</code>都是React中的优化工具，但它们的作用方式和使用场景不同。<code>useMemo</code>用于在函数组件中缓存计算结果，避免不必要的重复计算；而<code>memo</code>用于优化函数组件的渲染性能，避免不必要的重新渲染。</p><h4 id="React中useCallbck-和-useMemo的区别"><a href="#React中useCallbck-和-useMemo的区别" class="headerlink" title="React中useCallbck 和 useMemo的区别"></a>React中useCallbck 和 useMemo的区别</h4><p>在React中，<code>useCallback</code>和<code>useMemo</code>是两个用于优化性能的Hooks，但它们的使用场景和目的有所不同。</p><p><strong>useCallback</strong></p><p><code>useCallback</code>返回一个记忆化的回调函数。它主要用于避免在每次渲染时都创建新的函数，尤其是在将函数作为props传递给子组件时。如果传递给子组件的回调函数在每次父组件渲染时都重新创建，那么即使回调函数的内容没有变化，也可能导致子组件不必要的重新渲染。通过使用<code>useCallback</code>，你可以指定一个依赖项数组，只有当这些依赖项发生变化时，才会返回一个新的记忆化的回调函数。</p><p><strong>useMemo</strong></p><p><code>useMemo</code>返回一个记忆化的值。它用于缓存计算结果，以避免不必要的重复计算。当组件重新渲染时，如果<code>useMemo</code>的依赖项没有发生变化，那么它将直接返回之前计算的结果，而不是重新计算。这对于计算量大或计算昂贵的操作特别有用，因为它可以显著提高性能。</p><p><strong>区别</strong></p><blockquote><ol><li><strong>目的</strong>：<code>useCallback</code>的目的是优化函数的创建，而<code>useMemo</code>的目的是优化计算结果。</li><li><strong>参数</strong>：两者都接受一个函数和一个依赖项数组作为参数。但是，<code>useCallback</code>的函数是一个回调函数，而<code>useMemo</code>的函数是一个计算函数。</li><li><strong>返回值</strong>：<code>useCallback</code>返回一个记忆化的回调函数，而<code>useMemo</code>返回一个记忆化的计算结果。</li><li><strong>使用场景</strong>：<code>useCallback</code>主要用于优化传递给子组件的回调函数，以避免不必要的重新创建和渲染。而<code>useMemo</code>主要用于优化计算操作，避免不必要的重复计算。</li></ol></blockquote><p>总结来说，<code>useCallback</code>和<code>useMemo</code>都是React中用于优化性能的Hooks，但它们的优化目标和使用场景有所不同。在选择使用哪个Hook时，你应该根据你的具体需求和场景来决定。</p><h4 id="React-Hook为什么不能放到条件语句中？"><a href="#React-Hook为什么不能放到条件语句中？" class="headerlink" title="React Hook为什么不能放到条件语句中？"></a>React Hook为什么不能放到条件语句中？</h4><p>React Hooks 的设计原则之一是它们应该在函数组件的顶层被调用，而不是在条件语句、循环、嵌套函数或普通 JavaScript 函数中。这个规则被称为“Hook 规则”（Rules of Hooks），是 React 团队为了保持 Hooks 的简单性和可预测性而制定的。</p><p>为什么 Hooks 不能放在条件语句中呢？主要有以下几个原因：</p><blockquote><ol><li><strong>可预测性和一致性</strong>：React 需要确保 Hooks 在每次组件渲染时都以相同的顺序被调用。如果 Hooks 被放在条件语句中，它们的调用顺序可能会根据条件的不同而变化，导致 React 无法正确管理组件的状态和副作用。</li><li><strong>逻辑清晰性</strong>：将 Hooks 放在组件的顶层可以使得代码结构更加清晰，更容易理解和维护。如果将 Hooks 放在条件语句中，可能会使代码变得混乱，增加出错的可能性。</li><li><strong>避免循环和嵌套函数中的 Hooks</strong>：类似地，将 Hooks 放在循环或嵌套函数中也会导致调用顺序的问题。React 需要确保每次渲染时 Hooks 的调用顺序都相同，而循环和嵌套函数中的条件判断可能会破坏这个顺序。</li></ol></blockquote><p>为了遵循“Hook 规则”，你应该始终在函数组件的顶层调用 Hooks，并在调用它们之前不要使用任何条件语句或循环。如果需要根据某些条件来执行某些逻辑，你可以使用其他方式来实现，例如使用条件渲染（在 JSX 中使用条件语句）或根据条件来更新组件的状态。</p><p>总之，遵循“Hook 规则”可以确保你的 React 组件具有可预测性、一致性和可维护性。如果你违反了这些规则，React 可能会在控制台中发出警告或错误，帮助你识别和修复问题。</p><h4 id="React中实现自定义Hook"><a href="#React中实现自定义Hook" class="headerlink" title="React中实现自定义Hook"></a>React中实现自定义Hook</h4><p>在React中，自定义Hook是一种让你“钩入”React特性（如状态和生命周期）的函数，但它不需要创建class。自定义Hook本质上就是一个普通的函数，但是按照惯例，它的名称应该以“use”开头，并且它可能会调用其他的Hook。</p><p>下面是一个简单的自定义Hook的例子，它用来跟踪鼠标在组件中的位置：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自定义Hook: useMousePosition  </span><span class="token keyword">function</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>position<span class="token punctuation">,</span> setPosition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">function</span> <span class="token function">handleMouseMove</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setPosition</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> event<span class="token punctuation">.</span>clientX<span class="token punctuation">,</span> y<span class="token punctuation">:</span> event<span class="token punctuation">.</span>clientY <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 绑定事件监听器  </span>    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> handleMouseMove<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 清除函数，在组件卸载或重新渲染时调用  </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> handleMouseMove<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意这里的空依赖数组，表示这个effect不会在每次渲染时都重新执行  </span>    <span class="token keyword">return</span> position<span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用自定义Hook的组件  </span><span class="token keyword">function</span> <span class="token function">MouseTracker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> position <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Mouse position is at <span class="token punctuation">(</span><span class="token punctuation">{</span>position<span class="token punctuation">.</span>x<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>position<span class="token punctuation">.</span>y<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">export</span> <span class="token keyword">default</span> MouseTracker<span class="token punctuation">;</span></code></pre><p>在这个例子中，<code>useMousePosition</code>就是一个自定义Hook。它使用<code>useState</code>来存储鼠标的位置，使用<code>useEffect</code>来添加和移除鼠标移动事件监听器。然后，这个自定义Hook可以在任何需要使用鼠标位置信息的组件中被重复使用。</p><p>这就是React中自定义Hook的基本概念和用法。你可以根据具体的需求来创建自己的自定义Hook，以提高代码的复用性和可维护性。</p><h4 id="React中常用的自定义Hook有哪些"><a href="#React中常用的自定义Hook有哪些" class="headerlink" title="React中常用的自定义Hook有哪些"></a>React中常用的自定义Hook有哪些</h4><p>React中并没有内置的“常用”自定义Hook列表，因为自定义Hook是由开发者根据具体需求创建的。然而，有一些常见的使用场景和模式，这些场景和模式经常导致开发者创建自定义Hook。以下是一些常见的自定义Hook示例：</p><ol><li><strong>数据请求（如<code>useFetch</code>）</strong>：</li></ol><p>用于封装数据获取逻辑，如API调用。这个Hook可以处理异步操作、错误处理、数据缓存等。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">useFetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> setData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>error<span class="token punctuation">,</span> setError<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>isLoading<span class="token punctuation">,</span> setIsLoading<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">setIsLoading</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">setError</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">setData</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">setError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setIsLoading</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span> data<span class="token punctuation">,</span> error<span class="token punctuation">,</span> isLoading <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><ol><li><strong>表单处理（如<code>useForm</code>）</strong>：</li></ol><p>用于管理表单状态，如输入值、验证等。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">useForm</span><span class="token punctuation">(</span>initialValues <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>values<span class="token punctuation">,</span> setValues<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialValues<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> handleChange <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">setValues</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token operator">...</span>values<span class="token punctuation">,</span>        <span class="token punctuation">[</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// ...其他表单逻辑，如提交、验证等  </span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> values<span class="token punctuation">,</span> handleChange <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><ol><li><strong>定时器（如<code>useTimeout</code>或<code>useInterval</code>）</strong>：</li></ol><p>用于在React组件中轻松管理setTimeout和setInterval。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">useTimeout</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> savedCallback <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Remember the latest callback.  </span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      savedCallback<span class="token punctuation">.</span>current <span class="token operator">=</span> callback<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>callback<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// Set up the timeout.  </span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">function</span> <span class="token function">tick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        savedCallback<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> id <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>tick<span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>delay<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><ol><li><strong>动画和过渡（如<code>useAnimation</code>）</strong>：</li></ol><p>用于封装复杂的动画和过渡逻辑。</p><ol start="5"><li><strong>窗口大小（如<code>useWindowSize</code>）</strong>：</li></ol><p>用于获取浏览器窗口的大小。</p><ol start="6"><li><strong>设备检测（如<code>useDeviceDetection</code>）</strong>：</li></ol><p>用于检测设备的类型（如手机、平板、桌面）或特定的设备功能。</p><ol start="7"><li><strong>键盘事件（如<code>useKeyboardEvents</code>）</strong>：</li></ol><p>用于封装键盘事件监听逻辑。</p><p>这些只是自定义Hook的一些示例，实际上，你可以根据项目的具体需求创建任何你想要的自定义Hook。</p><h4 id="React-hooks的使用限制有哪些？"><a href="#React-hooks的使用限制有哪些？" class="headerlink" title="React hooks的使用限制有哪些？"></a>React hooks的使用限制有哪些？</h4><p>React Hooks 的使用限制主要有以下几点：</p><blockquote><ol><li><strong>只能在函数组件或自定义Hook内部使用</strong>：React Hooks 不能在类组件中使用，它们只能在函数组件或自定义Hook的内部使用。</li><li><strong>只能在组件的顶层调用</strong>：Hooks 必须在函数组件的顶层调用，而不能在循环、条件或嵌套函数中调用。这是为了保持 Hooks 调用顺序的一致性，以便 React 能够在多次渲染之间正确地关联状态和副作用。</li><li><strong>名称必须以“use”开头</strong>：自定义 Hook 的名称必须以“use”开头，这是一个约定俗成的命名规范，有助于其他开发者识别该函数是一个 Hook。</li><li><strong>调用顺序必须一致</strong>：在函数组件的多次渲染中，Hooks 的调用顺序必须保持一致。如果调用顺序发生变化，React 将无法正确地将之前的状态和副作用与当前的状态和副作用进行匹配，可能导致不可预期的行为或错误。</li><li><strong>不要在循环、条件或嵌套函数中调用Hook</strong>：在循环、条件或嵌套函数中调用 Hook 可能会导致调用顺序的不一致，从而破坏 React 的状态管理机制。如果需要在这些结构中使用 Hook，请考虑将它们提升到组件的顶层或使用自定义 Hook 来封装相关逻辑。</li><li><strong>避免在普通的JavaScript函数中调用Hook</strong>：Hooks 只能在 React 函数组件或自定义 Hook 中调用，而不能在普通的 JavaScript 函数中调用。这是因为 Hooks 依赖于 React 的渲染机制来管理状态和副作用，而普通的 JavaScript 函数无法提供这种上下文。</li></ol></blockquote><p>遵循这些限制和规则可以确保你的 React 代码具有更好的可预测性和可维护性。同时，它们也有助于减少因误用 Hooks 而导致的潜在问题和错误。</p><h4 id="介绍下React中的useEffect"><a href="#介绍下React中的useEffect" class="headerlink" title="介绍下React中的useEffect"></a>介绍下React中的useEffect</h4><p><code>useEffect</code> 是 React 的一个 Hook，它给函数组件增加了执行副作用操作的能力。副作用操作包括数据获取、订阅或手动更改 DOM 等。与类组件中的生命周期方法（如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>）相似，但 <code>useEffect</code> 将它们统一到一个 API 中。</p><p>以下是 <code>useEffect</code> 的基本用法和特性：</p><p><strong>基本用法</strong></p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 使用浏览器的API更新页面标题  </span>    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token string">`你点击了 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 次`</span></span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>你点击了 <span class="token punctuation">{</span>count<span class="token punctuation">}</span> 次<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span>          点我        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>在上面的例子中，每次组件渲染时，<code>useEffect</code> 中的函数都会被调用。但通常，我们希望在组件挂载（mount）和更新（update）时执行某些操作，并在组件卸载（unmount）时执行清理操作。为此，<code>useEffect</code> 可以接受一个返回函数的第二个参数。</p><p><strong>清理操作</strong></p><pre class=" language-jsx"><code class="language-jsx"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 组件挂载后设置订阅  </span>  <span class="token keyword">const</span> subscription <span class="token operator">=</span> props<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 清除订阅  </span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      subscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>依赖项数组</strong></p><p>如果你希望 <code>useEffect</code> 只在某个 prop 或 state 发生变化时运行，可以将它们作为依赖项数组传入 <code>useEffect</code> 的第二个参数。这样，<code>useEffect</code> 只有在依赖项发生变化时才会重新运行。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用 count 作为依赖项  </span>  document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token string">`你点击了 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 次`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只有当 count 发生变化时，这个 effect 才会重新运行</span></code></pre><p><strong>异步操作</strong></p><p>由于 <code>useEffect</code> 中的函数是同步执行的，如果你需要在其中执行异步操作（如数据获取），请确保在清理函数中取消任何未完成的异步操作，以避免内存泄漏。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> ignore <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 模拟异步数据获取  </span>    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchSomeData</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 检查组件是否仍然挂载（没有卸载）  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 开始获取数据  </span>  <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 当组件卸载时，将 ignore 设置为 true  </span>  <span class="token comment" spellcheck="true">// 这将阻止在组件卸载后更新 setData  </span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> ignore <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当 props.id 发生变化时，重新获取数据</span></code></pre><p><strong>总结</strong></p><p><code>useEffect</code> 是一个强大的 Hook，它允许你在函数组件中执行副作用操作。通过正确地使用它，你可以将复杂的逻辑和生命周期管理封装到可重用的自定义 Hook 中，从而提高代码的可读性和可维护性。</p><h4 id="React中useEffect和useLayoutEffect区别"><a href="#React中useEffect和useLayoutEffect区别" class="headerlink" title="React中useEffect和useLayoutEffect区别"></a>React中useEffect和useLayoutEffect区别</h4><p>React中的<code>useEffect</code>和<code>useLayoutEffect</code>是两个常用的Hook，它们的主要区别在于触发时机和用途。</p><blockquote><ol><li><strong>触发时机</strong>：<ul><li><code>useEffect</code>：在组件渲染完成后异步执行，不会阻塞浏览器的绘制操作。也就是说，它会在浏览器执行绘制之后，等待当前帧的所有DOM更新都完成后执行。这可能会导致渲染的一次跳跃，用户可能会在页面渲染完成后才看到最终效果。</li><li><code>useLayoutEffect</code>：在浏览器执行绘制之前同步执行。也就是说，在js线程执行完毕即DOM更新之后立即执行，且会在所有DOM更改之后同步触发。由于它会在页面渲染之前执行，因此可以阻止屏幕更新，确保副作用的执行不会引起渲染跳跃，提供更流畅的用户体验。</li></ul></li><li><strong>用途</strong>：<ul><li><code>useEffect</code>：适用于需要在组件渲染后执行副作用的情况，例如数据的获取、订阅事件等。由于它不会阻止屏幕更新，所以可能更适合于那些不需要立即反映到UI上的副作用。</li><li><code>useLayoutEffect</code>：适用于需要在DOM更新之后同步执行副作用的情况，例如获取DOM元素的尺寸、位置等。由于它会在页面渲染之前执行，所以更适合于那些需要立即反映到UI上的副作用。</li></ul></li><li><strong>与类组件生命周期的对比</strong>：<ul><li>你可以把<code>useLayoutEffect</code>等同于<code>componentDidMount</code>和<code>componentDidUpdate</code>，因为它们的调用阶段是相同的。也就是说，当组件所有DOM都渲染完成后，同步调用<code>useLayoutEffect</code>。</li><li>而<code>useEffect</code>是在<code>componentDidMount</code>和<code>componentDidUpdate</code>调用之后才会触发的。</li></ul></li></ol></blockquote><p>总的来说，<code>useEffect</code>和<code>useLayoutEffect</code>的选择取决于你的具体需求。如果你需要在DOM更新后执行某些操作，并且这些操作不需要立即反映到UI上，那么<code>useEffect</code>可能是更好的选择。而如果你需要在DOM更新后立即执行某些操作，并且这些操作需要立即反映到UI上，那么<code>useLayoutEffect</code>可能更适合你。</p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><h4 id="Redux的使用"><a href="#Redux的使用" class="headerlink" title="Redux的使用"></a>Redux的使用</h4><p>Redux是一个JavaScript状态容器，主要用于可预测和可维护的全局状态管理。以下是Redux的基本使用步骤：</p><ol><li><strong>安装Redux</strong>：</li></ol><p>你可以使用npm或yarn来安装Redux。例如，使用npm的命令是<code>npm install redux</code>，使用yarn的命令是<code>yarn add redux</code>。</p><ol start="2"><li><strong>定义核心概念</strong>：</li></ol><p>Redux有三个核心概念：actions、reducers和store。</p><pre><code>* **Actions**：动作对象，包含两个属性。`type`是标识属性，值为唯一字符串，是必要属性；`data`是数据属性，可以包含任意类型的数据，是可选属性。Actions通过action生成器创建，这些生成器仅仅是返回action的函数。  * **Reducers**：用于初始化状态、加工状态的纯函数。加工时，根据state和action，产生新的state。  * **Store**：将state、action、reducer联系在一起的对象。你可以使用Redux提供的`createStore`函数来创建一个store。</code></pre><ol start="3"><li><strong>创建Store</strong>：</li></ol><p>在项目中，你通常会在一个单独的文件中（例如<code>store.js</code>）创建Redux store。在这个文件中，你需要引入Redux的<code>createStore</code>函数以及你的reducer函数，然后调用<code>createStore(reducer)</code>来创建一个store。</p><ol start="4"><li><strong>在React组件中使用Redux</strong>：</li></ol><p>虽然Redux本身不依赖于React，但两者经常一起使用。在React组件中，你可以使用Redux提供的<code>connect</code>函数或者<code>useSelector</code>和<code>useDispatch</code> Hooks来访问store中的状态和发送actions。</p><p>例如，使用<code>connect</code>函数，你可以将Redux store中的状态和actions映射到React组件的props中。然后，在组件中，你就可以像使用普通props一样使用这些状态和actions了。</p><p>另外，你也可以使用Redux Toolkit（RTK），它是Redux的官方工具包，提供了一些简化和改进Redux开发的工具和函数。例如，RTK中的<code>createSlice</code>函数可以帮助你更简洁地定义actions和reducers。</p><ol start="5"><li><strong>监听数据变化</strong>：</li></ol><p>如果你的组件需要监听store中数据的变化，你可以使用Redux提供的<code>store.subscribe</code>方法来注册一个回调函数。当store中的数据发生变化时，这个回调函数就会被调用。在回调函数中，你可以获取最新的state，并根据需要更新组件的状态或执行其他操作。</p><p>以上就是Redux的基本使用步骤。请注意，Redux是一个比较复杂的库，需要一定的学习和实践才能熟练掌握。同时，Redux也提供了丰富的文档和社区支持，你可以通过查阅文档和参与社区讨论来深入了解Redux的使用方法和最佳实践。</p><h4 id="Redux的实现原理"><a href="#Redux的实现原理" class="headerlink" title="Redux的实现原理"></a>Redux的实现原理</h4><p>Redux的实现原理可以概括为以下几个核心部分：</p><ol><li><p>Store（存储）</p><p>：</p><ul><li>Redux应用程序的状态存储在一个单一的JavaScript对象中，称为Store。这个Store包含了整个应用程序的状态树。</li><li>Store通过<code>dispatch(action)</code>方法来更新状态。每当一个action被分发（dispatch）时，Redux都会将当前的state和该action一起传递给reducer。</li></ul></li><li><p>Action（动作）</p><p>：</p><ul><li>Action是一个描述状态变化的纯JavaScript对象。它必须包含一个<code>type</code>字段，用于指定要执行的操作类型。</li><li>根据需要，Action还可以包含其他字段来传递数据。例如，你可以有一个<code>&#123; type: &#39;INCREMENT&#39;, amount: 1 &#125;</code>的Action来表示一个增加计数的操作。</li></ul></li><li><p>Reducer（规约器）</p><p>：</p><ul><li>Reducer是一个纯函数，它接收当前的state和一个action作为参数，并返回一个新的state。</li><li>Reducer负责根据传入的action来更新state。由于reducer是纯函数，所以相同的输入总是产生相同的输出，这有助于保持应用程序的状态是可预测和可调试的。</li></ul></li><li><p>Dispatch（分发）</p><p>：</p><ul><li>Dispatch是一个方法，用于触发状态的更新。当你调用<code>dispatch(action)</code>时，Redux会将当前的state和该action一起传递给reducer。</li><li>Reducer会处理这个action并返回一个新的state。然后，Redux会用这个新的state来更新Store中的状态。</li></ul></li><li><p>Subscribe（订阅）</p><p>：</p><ul><li>Subscribe是一个方法，用于订阅Store中状态的变化。当一个组件或其他部分需要知道Store中的状态何时发生变化时，它们可以调用<code>store.subscribe(listener)</code>来注册一个监听器。</li><li>当Store中的状态发生变化时，Redux会调用所有注册的监听器，并将新的state作为参数传递给它们。这样，监听器就可以知道状态何时发生变化，并可以根据需要更新自己。</li></ul></li><li><p>Middleware（中间件）</p><p>：</p><ul><li>虽然Middleware不是Redux的核心部分，但它是Redux生态系统中非常重要的一部分。Middleware允许你在action被发送到reducer之前对其进行拦截、修改或处理。</li><li>例如，你可以使用middleware来实现异步操作、日志记录、异常处理等功能。</li></ul></li></ol><p>通过这些核心部分，Redux提供了一个可预测、可维护的状态管理解决方案，使得在React等前端框架中管理复杂的应用程序状态变得更加容易和可靠。</p><h4 id="Redux中间件了解过吗？"><a href="#Redux中间件了解过吗？" class="headerlink" title="Redux中间件了解过吗？"></a>Redux中间件了解过吗？</h4><p>Redux中间件是一种拦截Redux的派发过程，并对派发的action进行一系列处理的机制。它允许我们在action到达reducer之前或之后执行自定义的逻辑，例如日志记录、异步操作、路由等。Redux中间件提供了一种机制，让我们可以在Redux的派发过程中进行额外的操作，从而更加灵活地处理各种场景下的状态管理需求。</p><p>在Redux中，中间件可以改变数据流，实现如异步action、action过滤、日志输出、异常报告等功能。中间件的本质是对dispatch的功能做了扩展，使得action -&gt; reducer的过程变为action -&gt; middlewares -&gt; reducer。</p><p>常用的Redux中间件包括redux-thunk和redux-saga。redux-thunk支持在action中进行异步操作，允许我们派发函数类型的action，而不仅仅是普通的对象。redux-saga则单独地把逻辑放到另一个文件中进行管理。</p><p>此外，Redux中间件的使用通常涉及applyMiddlewares()方法，这是Redux的原生方法，作用是将所有中间件组成一个数组，依次执行。例如，redux-logger中间件就提供了一个生成器createLogger，可以生成日志中间件，然后将其放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强。</p><p>当然可以。以下是一个使用Redux和<code>redux-thunk</code>中间件的例子，它展示了如何处理异步操作。</p><p>首先，你需要安装<code>redux</code>和<code>redux-thunk</code>。通过npm或yarn，可以这样做：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> redux redux-thunk  <span class="token comment" spellcheck="true"># 或者  </span>yarn add redux redux-thunk</code></pre><p>然后，你可以创建一个action创建函数，这个函数返回一个函数，而不是直接返回一个action对象。这是<code>redux-thunk</code>中间件所允许的，使得你可以在返回的函数中执行异步操作。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// actions.js  </span><span class="token keyword">export</span> <span class="token keyword">const</span> fetchData <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">async</span> dispatch <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://api.example.com/data'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'FETCH_DATA_SUCCESS'</span><span class="token punctuation">,</span> payload<span class="token punctuation">:</span> data <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'FETCH_DATA_FAILURE'</span><span class="token punctuation">,</span> error <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>接下来，你需要一个reducer来处理这些action：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// reducers.js  </span><span class="token keyword">const</span> initialState <span class="token operator">=</span> <span class="token punctuation">{</span>    data<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    error<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">export</span> <span class="token keyword">const</span> dataReducer <span class="token operator">=</span> <span class="token punctuation">(</span>state <span class="token operator">=</span> initialState<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> <span class="token string">'FETCH_DATA_SUCCESS'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> data<span class="token punctuation">:</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">,</span> error<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">'FETCH_DATA_FAILURE'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> error<span class="token punctuation">:</span> action<span class="token punctuation">.</span>error <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">default</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>现在，你需要将<code>redux-thunk</code>中间件应用到你的Redux store中：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// store.js  </span><span class="token keyword">import</span> <span class="token punctuation">{</span> createStore<span class="token punctuation">,</span> applyMiddleware <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span><span class="token punctuation">;</span>  <span class="token keyword">import</span> thunk <span class="token keyword">from</span> <span class="token string">'redux-thunk'</span><span class="token punctuation">;</span>  <span class="token keyword">import</span> <span class="token punctuation">{</span> dataReducer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./reducers'</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>dataReducer<span class="token punctuation">,</span> <span class="token function">applyMiddleware</span><span class="token punctuation">(</span>thunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">export</span> <span class="token keyword">default</span> store<span class="token punctuation">;</span></code></pre><p>最后，在你的React组件中，你可以使用<code>dispatch</code>方法来调用<code>fetchData</code> action：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// MyComponent.js  </span><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>  <span class="token keyword">import</span> <span class="token punctuation">{</span> useDispatch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-redux'</span><span class="token punctuation">;</span>  <span class="token keyword">import</span> <span class="token punctuation">{</span> fetchData <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./actions'</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> dispatch <span class="token operator">=</span> <span class="token function">useDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// ... 组件的其他部分  </span><span class="token punctuation">}</span>    <span class="token keyword">export</span> <span class="token keyword">default</span> MyComponent<span class="token punctuation">;</span></code></pre><p>在这个例子中，当<code>MyComponent</code>组件挂载时，它会调用<code>fetchData</code> action。由于<code>fetchData</code>返回一个函数，<code>redux-thunk</code>中间件会拦截这个action，并执行这个函数。在函数内部，我们执行了一个异步的fetch操作，并在操作成功或失败时派发了相应的action。这些action随后被<code>dataReducer</code> reducer处理，并更新了Redux store中的状态。</p><h4 id="React中状态管理的方式除了redux，还有哪些？"><a href="#React中状态管理的方式除了redux，还有哪些？" class="headerlink" title="React中状态管理的方式除了redux，还有哪些？"></a>React中状态管理的方式除了redux，还有哪些？</h4><ol><li><p>React的内置状态（State）和Hooks</p><p>：</p><ul><li>React组件可以使用<code>useState</code>钩子来管理内部的状态。它允许你在函数组件中定义和更新状态。</li><li>通过<code>createContext</code>和<code>useContext</code>钩子，你可以在组件树中共享数据，避免通过多层嵌套传递props的繁琐过程。</li></ul></li><li><p>React Context API</p><p>：</p><ul><li>React Context API是React官方提供的一种状态管理方案。</li><li>通过创建一个Context对象，你可以在需要共享状态的组件中使用<code>Provider</code>提供状态，并在其他组件中使用<code>Consumer</code>或<code>useContext</code>钩子来获取状态。</li></ul></li><li><p>MobX</p><p>：</p><ul><li>MobX是一个可扩展的状态管理库，通过透明的函数式响应式编程（TFRP：Transparent Functional Reactive Programming）使得状态管理变得非常简单。</li><li>它使用可观察对象来封装状态，并在状态发生变化时自动更新相关的组件。</li></ul></li><li><p>Zustand</p><p>：</p><ul><li>Zustand是一个轻量级的、可扩展的状态管理库，专为React和React Native设计。</li><li>它提供了简单直观的API来创建和管理状态，并支持TypeScript和React Hooks。</li></ul></li><li><p>Recoil</p><p>：</p><ul><li>Recoil是Facebook推出的一款新型状态管理库，旨在通过提供一种更加直观和简洁的方式来简化React应用中的状态管理。</li><li>它使用了JavaScript的Proxy和React的并发特性来实现快速和高效的状态更新。</li></ul></li><li><p>多个状态提供者</p><p>：</p><ul><li>在大型应用中，可以在多个层级上设置提供者（Provider），而不是仅仅在应用的顶层。这样可以控制渲染发生的具体位置和范围。</li></ul></li><li><p>状态选择</p><p>：</p><ul><li>在使用Context时，可以通过传递一个函数给Consumer（或<code>useContext</code>），而不是直接传递整个状态对象。这个函数可以从全局状态中选择组件特定需要的部分状态。这样可以避免组件不必要的更新，并使组件的意图更加明显。</li></ul></li><li><p>避免在Context Value中传递新对象或函数</p><p>：</p><ul><li>这会在每次Provider渲染时创建新的引用，导致所有消费者组件重新渲染。你可以通过使用<code>useCallback</code>来缓存函数，以及使用<code>useMemo</code>来缓存计算得出的值。</li></ul></li></ol><p>选择哪种状态管理方式取决于你的具体需求和项目规模。对于小型项目，React的内置状态和Context API可能就足够了。而对于大型复杂项目，可能需要考虑使用更强大和灵活的状态管理库，如Redux、MobX或Zustand等。</p><h3 id="React-router"><a href="#React-router" class="headerlink" title="React-router"></a>React-router</h3><h4 id="React-router-dom、React-router、history库三者什么关系"><a href="#React-router-dom、React-router、history库三者什么关系" class="headerlink" title="React-router-dom、React-router、history库三者什么关系"></a>React-router-dom、React-router、history库三者什么关系</h4><p>React-router-dom、React-router以及history库在React应用中处理路由方面有着密切的关系，但各自扮演着不同的角色。</p><ol><li><strong>React-router</strong>：</li></ol><p>React-router是React生态系统中用于处理路由的核心库。它允许开发者在React应用中实现页面导航和状态管理，特别是在单页面应用（SPA）中。React-router为开发者提供了一种简洁、灵活且强大的方式来处理页面之间的导航关系，支持页面参数传递、路由守卫、权限控制、代码分割和懒加载优化等功能。React-router并不仅仅是一个简单的URL路由管理工具，而是一个可以帮助开发者构建复杂SPA的工具集。</p><ol start="2"><li><strong>React-router-dom</strong>：</li></ol><p>React-router-dom是React-router在浏览器环境中的实现，它提供了与DOM相关的路由功能。React-router-dom包含了一些特定的组件，如<code>&lt;BrowserRouter&gt;</code>、<code>&lt;Route&gt;</code>、<code>&lt;Link&gt;</code>等，这些组件允许开发者在React应用中声明式地定义路由。当浏览器的URL发生变化时，React-router-dom会根据当前URL匹配相应的路由组件，并将其渲染到页面上。</p><ol start="3"><li><strong>history库</strong>：</li></ol><p>history库是一个独立的JavaScript库，用于管理浏览器的历史记录。它与React-router紧密集成，为React-router提供了底层的历史记录管理功能。history库提供了创建History对象、监听URL变化、导航操作（如push、replace、go等）以及兼容性处理等功能。通过使用history库，React-router能够实现对浏览器历史记录的精确控制，从而实现无刷新页面的页面导航。</p><p>总的来说，React-router是React应用中的路由管理工具，React-router-dom是React-router在浏览器环境中的实现，而history库则为React-router提供了底层的历史记录管理功能。这三者共同协作，使得React应用能够实现高效、灵活且易于管理的页面导航和状态管理。</p><h4 id="路由的不同及原理"><a href="#路由的不同及原理" class="headerlink" title="路由的不同及原理"></a>路由的不同及原理</h4><p>路由在计算机网络和软件开发中都扮演着重要的角色，但其含义和原理在不同领域有所不同。以下是路由在不同情境下的不同及原理：</p><ol><li>计算机网络中的路由：</li></ol><blockquote><ul><li>定义：路由（Routing）是指分组从源到目的地时，决定端到端路径的网络范围的进程。在OSI七层模型下，路由主要进行在第三次网络层。</li><li>分类：<ol><li>静态路由：由管理员手工定义到一个或多个目的网络的路由。静态路由不需要使用路由协议，但需要由路由器管理员手工更新路由表。</li><li>动态路由：路由器根据路由选择协议所定义的规则来交换路由信息，并独立地选择最佳路径。</li><li>缺省路由：当路由表中与包的目的地址之间无匹配的表项时，路由器会选择缺省路由进行转发。</li></ol></li><li>原理：路由器通过转发数据包来实现网络互连。它根据收到数据包中的网络层地址以及路由器内部维护的路由表来决定输出端口以及下一跳地址，并重写链路层数据包头实现转发数据包。</li></ul></blockquote><ol><li><p>软件开发中的路由（如React-router）：</p><blockquote><ul><li>定义：在软件开发中，路由通常指的是一种机制，用于确定如何根据URL或用户输入来呈现不同的视图或组件。</li><li>原理：以React-router为例，它允许开发者在React应用中声明式地定义路由。当URL发生变化时，React-router会根据当前URL匹配相应的路由组件，并将其渲染到页面上。这通过React组件和状态管理来实现，使用户界面能够随着URL的变化而动态更新。</li></ul></blockquote></li></ol><p>总结来说，路由在计算机网络中主要负责决定数据包从源到目的地的最佳路径，而在软件开发中则主要用于确定如何根据用户输入或URL来呈现不同的视图或组件。虽然两者在定义和应用场景上有所不同，但都体现了“根据某种规则或条件来选择或决定路径”的核心思想。</p><h3 id="React-相关"><a href="#React-相关" class="headerlink" title="React 相关"></a>React 相关</h3><h4 id="React中错误边界的概念"><a href="#React中错误边界的概念" class="headerlink" title="React中错误边界的概念"></a>React中错误边界的概念</h4><p>在React中，<strong>错误边界（Error Boundaries）</strong>是一种React组件，用于捕获并处理其子组件树中任何位置的JavaScript错误。它允许开发人员在应用程序中定义错误边界，以便在发生错误时显示备用UI而不会导致整个应用程序崩溃。</p><p>错误边界的主要作用是提高应用程序的健壮性和稳定性。在开发过程中，我们经常会遇到各种各样的错误，如网络请求失败、数据解析错误、组件渲染错误等。这些错误如果没有得到适当处理，可能会导致整个应用程序崩溃，给用户带来不好的体验。通过将错误边界包装在组件周围，开发人员可以更好地控制错误的影响范围，并提供更友好的用户体验。</p><p>要创建一个错误边界，需要自定义一个React组件并实现特定的生命周期方法，如<code>componentDidCatch</code>和<code>static getDerivedStateFromError</code>。当错误发生时，这些方法将被调用，并允许你处理错误、记录错误日志或向用户展示友好的错误提示信息。</p><p>需要注意的是，错误边界无法捕获自身的渲染错误或生命周期方法中的错误，只能捕获其子组件树中的错误。此外，错误边界应该谨慎使用，因为过度使用可能会导致应用程序的调试变得困难。</p><p>总之，React中的错误边界是一种强大的工具，可以帮助开发人员更好地处理应用程序中的错误，提高应用程序的健壮性和用户体验。</p><h4 id="React中的Suspense组件"><a href="#React中的Suspense组件" class="headerlink" title="React中的Suspense组件"></a>React中的Suspense组件</h4><p>React中的Suspense组件是一个用于处理异步加载组件时加载状态和错误处理的组件。具体来说，Suspense组件可以包裹一个或多个异步加载的组件，并通过fallback属性指定一个加载时的占位符。当异步加载的组件尚未完成加载时，Suspense会显示fallback指定的占位符内容。一旦异步加载的组件加载完成，Suspense会显示实际的组件内容。</p><p>Suspense组件的使用场景通常与React的懒加载（lazy loading）功能相结合。通过使用React.lazy函数和Suspense组件，你可以按需加载组件，从而提高应用程序的性能和响应速度。</p><p>此外，Suspense组件还可以与ErrorBoundary组件一起使用，以捕获和处理异步加载组件时可能出现的错误。这样，即使在加载组件时发生错误，也可以向用户展示一个友好的错误提示信息，而不会导致整个应用程序崩溃。</p><p>总的来说，React中的Suspense组件为处理异步加载组件的加载状态和错误处理提供了一种优雅的方式，有助于提高应用程序的健壮性和用户体验。</p><h4 id="React的合成事件和事件委托机制，混用合成事件和原生事件谁会先执行？"><a href="#React的合成事件和事件委托机制，混用合成事件和原生事件谁会先执行？" class="headerlink" title="React的合成事件和事件委托机制，混用合成事件和原生事件谁会先执行？"></a>React的合成事件和事件委托机制，混用合成事件和原生事件谁会先执行？</h4><p>在React中，合成事件（Synthetic Events）和事件委托（Event Delegation）机制是紧密相关的，并且它们共同构成了React的事件处理系统。</p><p>关于合成事件和原生事件（Native Events）的执行顺序，React的合成事件会先于原生DOM事件触发。然而，两者都可以在组件中处理，并按照事件冒泡的顺序执行相应的事件处理函数。</p><p>具体来说，React的事件处理机制可以分为两个阶段：</p><blockquote><ol><li>在初始化渲染时，React会在root节点上注册原生事件。</li><li>当原生事件触发时，React会模拟事件的目标和冒泡阶段，并派发合成事件。</li></ol></blockquote><p>这种机制使得冒泡的原生事件类型最多在root节点上注册一次，从而节省了内存开销。同时，由于React使用了事件委托，所有的事件都会冒泡到根元素，然后React根据事件的类型和目标元素来调用相应的事件处理函数。</p><p>在React中，你通常不需要直接处理原生事件，而是使用React提供的合成事件系统。合成事件是React模拟原生DOM事件所有能力的一个事件对象，它可以兼容所有浏览器，并拥有和浏览器原生事件相同的接口。此外，React还在事件合成过程中对不同浏览器的事件进行了封装处理，以抹平浏览器之间的事件差异。</p><p>因此，在React中混用合成事件和原生事件时，合成事件会先执行。但请注意，尽管可以在React组件中处理原生事件，但通常建议尽可能使用React的合成事件系统，以保持一致性和可维护性。</p><h4 id="React中的shouldComponentUpdate"><a href="#React中的shouldComponentUpdate" class="headerlink" title="React中的shouldComponentUpdate"></a>React中的shouldComponentUpdate</h4><p>在React中，<code>shouldComponentUpdate()</code> 是一个可选的生命周期方法，它允许你手动控制组件是否应该在其props或state变化时重新渲染。这个方法在React组件的更新阶段被调用，即在接收到新的props或state并准备重新渲染之前。</p><p><code>shouldComponentUpdate()</code> 方法接受两个参数：<code>nextProps</code> 和 <code>nextState</code>，分别表示下一个props和下一个state。如果该方法返回<code>true</code>，则组件将进行正常的更新过程，即调用<code>render()</code> 方法并更新DOM（如果必要的话）。如果返回<code>false</code>，则组件将跳过更新过程，不会调用<code>render()</code> 方法，也不会更新DOM。</p><p>这个方法的主要用途是提高React应用的性能。在默认情况下，当组件的props或state发生变化时，React会重新渲染该组件及其所有子组件。但是，在某些情况下，你可能知道某个props或state的变化并不会影响组件的输出，因此不需要重新渲染该组件。在这种情况下，你可以通过实现<code>shouldComponentUpdate()</code> 方法并返回<code>false</code>来避免不必要的渲染。</p><p>需要注意的是，虽然<code>shouldComponentUpdate()</code> 可以帮助提高性能，但它也可能使代码变得更加复杂和难以维护。因此，在使用该方法时应该谨慎，并确保你完全理解其工作原理和潜在的影响。</p><p>以下是一个简单的示例，展示了如何使用<code>shouldComponentUpdate()</code> 来控制组件的重新渲染：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 如果下一个props或state中的某个值没有变化，则不需要重新渲染  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>value <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 否则，重新渲染组件  </span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 渲染组件的UI  </span>    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>在这个示例中，如果<code>MyComponent</code>的<code>props.value</code>没有发生变化，那么<code>shouldComponentUpdate()</code> 将返回<code>false</code>，从而避免重新渲染组件。这可以帮助提高应用的性能，特别是当组件具有复杂的UI或包含大量子组件时。</p><h4 id="React中的setState是同步的还是异步的？"><a href="#React中的setState是同步的还是异步的？" class="headerlink" title="React中的setState是同步的还是异步的？"></a>React中的setState是同步的还是异步的？</h4><p>在React中，<code>setState</code> 的行为在大多数情况下是异步的，但在某些特定的上下文下，它也可以表现为同步的。这主要取决于<code>setState</code>是在哪里以及如何被调用的。</p><p><strong>异步行为</strong></p><p>当你在组件的事件处理器、生命周期方法（如<code>componentDidMount</code>、<code>componentDidUpdate</code>等）或其他React控制的回调中调用<code>setState</code>时，React会批量处理这些更新以提高性能。React可能会延迟这些更新，直到下一轮事件循环才实际进行渲染。这种批量处理的行为使得<code>setState</code>在这些情况下是异步的。</p><p>例如，在<code>componentDidUpdate</code>中调用<code>setState</code>：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里的setState是异步的  </span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这可能不会输出更新后的值  </span><span class="token punctuation">}</span></code></pre><p>在上面的例子中，由于<code>setState</code>是异步的，<code>console.log</code>可能会在<code>setState</code>实际更新state之前执行，因此输出的可能不是更新后的值。</p><p><strong>同步行为</strong></p><p>但是，在React的事件处理器（如点击事件、键盘事件等）的顶层调用中，<code>setState</code>是同步的。这意味着<code>setState</code>会立即更新state，并且之后的代码可以访问到更新后的state值。</p><pre class=" language-jsx"><code class="language-jsx">handleClick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里的setState是同步的  </span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这将输出更新后的值（或者React 18之前的版本中，由于批处理，它可能仍然输出旧值）  </span><span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">></span></span>Click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>但是，需要注意的是，在React 18中引入了新的并发模式（Concurrent Mode），以及React团队为了进一步提高性能而引入的自动批处理（Automatic Batching）。在这些新特性下，即使在事件处理器中，<code>setState</code>也可能表现为异步的，特别是当与<code>startTransition</code>或<code>useTransition</code>钩子结合使用时。</p><p><strong>解决方案</strong></p><p>如果你需要在<code>setState</code>之后立即访问更新后的state值，可以使用<code>setState</code>的回调函数。这个回调函数会在state更新且组件重新渲染之后被调用。</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这将输出更新后的值  </span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>总的来说，<code>setState</code>的行为可能是同步的，也可能是异步的，这取决于它在哪里以及如何被调用。了解这些差异并正确使用<code>setState</code>是编写高效且可靠的React组件的关键。</p><h4 id="React中useState的执行本质"><a href="#React中useState的执行本质" class="headerlink" title="React中useState的执行本质"></a>React中useState的执行本质</h4><p>在React中，<code>useState</code>的执行本质可以概括为以下几个关键点：</p><ol><li><strong>状态初始化</strong>：当你首次在函数组件中调用<code>useState</code>时，React会使用你提供的初始值来设置状态。这个初始值可以是任何类型的值，包括数字、字符串、对象、数组等。</li><li><strong>状态存储</strong>：<code>useState</code>并不是直接在组件实例上添加状态，而是与React的“fiber”数据结构相关联。每个组件都有一个与之关联的fiber，而每个fiber都有一个与之关联的state链表。当你调用<code>useState</code>时，React会在当前的fiber上添加一个新的state节点。</li><li><strong>状态更新</strong>：<code>useState</code>返回一个包含两个元素的数组。第一个元素是当前的state，第二个元素是一个可以更新这个state的函数（通常被称为<code>setState</code>函数）。当你调用这个<code>setState</code>函数时，React会重新渲染组件，并使用你提供的新值来更新state。</li><li><strong>批量更新</strong>：React会优化多个状态更新操作，将它们放入一个队列中，并在适当的时机进行合并和批量处理。这可以防止在单个事件期间多次重新渲染，并确保状态更新按照顺序进行。</li><li><strong>状态持久化</strong>：<code>useState</code>在组件的每次渲染中都会返回相同的状态对象。这意味着你可以在多次渲染之间保持对状态的引用，并在需要时更新它。这种持久化的状态使得函数组件能够在没有类组件的复杂生命周期方法的情况下管理状态。</li></ol><p>总的来说，<code>useState</code>是React Hooks中用于在函数组件中添加状态的基本Hook。它通过创建一个与当前组件实例相关联的状态对象，并在需要时更新该对象来实现状态管理。这种方式使得函数组件能够像类组件一样具有状态，但更加简洁和直观。</p><h4 id="React中useState的底层实现原理"><a href="#React中useState的底层实现原理" class="headerlink" title="React中useState的底层实现原理"></a>React中useState的底层实现原理</h4><p>React中的<code>useState</code> Hook 的底层实现原理相当复杂，涉及到React的许多内部机制。不过，以下是一个简化的概述来帮助你理解其工作原理：</p><ol><li><strong>Fiber架构</strong>：<br>React 使用一种称为 Fiber 的新架构来重新实现其核心算法。Fiber 架构使得 React 能够增量地渲染 UI，并且提供了更多的控制和灵活性。每个组件在 Fiber 架构中都有一个与之关联的 Fiber 节点，这些节点形成了一个链表结构。</li><li><strong>Hook链表</strong>：<br>当你在组件中调用<code>useState</code>时，React 会在当前的 Fiber 节点上创建一个与之关联的 Hook 对象。这个 Hook 对象包含了状态的值和更新状态的函数。React 使用一个链表（通常称为 Hook 链表）来跟踪每个组件中声明的所有 Hook。这个链表中的每个节点都对应一个 Hook。</li><li><strong>状态初始化</strong>：<br>当你首次调用<code>useState</code>时，React 会根据提供的初始值在 Hook 链表中创建一个新的 Hook 节点，并返回状态的值和更新状态的函数。这个状态值被存储在 Hook 节点中，以便在后续的渲染中能够访问和更新。</li><li><strong>状态更新</strong>：<br>当你调用更新状态的函数时，React 会更新 Hook 节点中的状态值，并安排一次重新渲染。这个重新渲染过程会遍历组件的 Fiber 节点和 Hook 链表，使用最新的状态值来更新组件的 UI。</li><li><strong>依赖追踪</strong>：<br>React 使用一种称为“依赖追踪”的机制来确保在状态更新时能够正确地重新渲染相关的组件。当组件的某个状态发生变化时，React 会遍历与该状态相关的所有组件（通过依赖关系图来确定），并重新渲染它们。</li><li><strong>并发模式</strong>：<br>在 Fiber 架构中，React 引入了并发模式的概念。这意味着 React 可以同时处理多个更新任务，并根据优先级来安排它们的执行顺序。这种并发模式使得 React 在处理复杂的 UI 更新时更加高效和灵活。</li></ol><p>需要注意的是，上述描述是对<code>useState</code>底层实现原理的简化概述。实际上，React 的内部机制要复杂得多，并且涉及到许多其他的概念和技术。但是通过理解这些基本原理，你可以更好地理解<code>useState</code>的工作原理以及它在 React 中的应用。</p><h4 id="React中useEffect的执行本质"><a href="#React中useEffect的执行本质" class="headerlink" title="React中useEffect的执行本质"></a>React中useEffect的执行本质</h4><p>React中的<code>useEffect</code> Hook的执行本质可以概括为以下几点：</p><ol><li><strong>副作用处理</strong>：<code>useEffect</code>允许你在函数组件中执行副作用操作，如数据获取、订阅和手动更改DOM等。这些操作是组件渲染过程中不可或缺的一部分，但通常与组件的渲染过程没有直接关系。</li><li><strong>依赖项追踪</strong>：<code>useEffect</code>接受一个回调函数（通常称为“effect”）作为第一个参数，并接受一个可选的依赖项数组作为第二个参数。如果提供了依赖项数组，React将仅当数组中的某个依赖项发生变化时才会重新执行该effect。这有助于减少不必要的effect执行，提高性能。</li><li><strong>执行时机</strong>：<code>useEffect</code>在React的commit阶段执行，即在DOM更新和屏幕渲染之后。这确保了在effect执行时，组件的DOM已经是最新的。同时，<code>useEffect</code>的执行是异步的，不会在每次渲染后立即执行，而是在所有DOM变更之后和浏览器绘制之前。</li><li><strong>销毁与清理</strong>：每个通过<code>useEffect</code>创建的effect都可以返回一个函数，该函数将在组件卸载或重新渲染前执行。这通常用于清理操作，如取消订阅、清除计时器或恢复之前更改的DOM。这有助于防止内存泄漏和不必要的副作用。</li><li><strong>底层原理</strong>：在React的渲染过程中，当遇到<code>useEffect</code>时，React会将其回调函数和依赖项（如果有）加入到一个effect链表中。当渲染过程完成后，React会遍历这个链表并执行其中的effect。同时，React会维护一个内部状态来跟踪哪些effect已经执行过，以便在组件重新渲染时能够正确地清理和重新执行它们。</li></ol><p>总的来说，<code>useEffect</code>的执行本质是在React的渲染过程中插入一个异步执行的副作用处理函数，该函数在DOM更新和屏幕渲染之后执行，并且可以根据依赖项的变化来优化执行频率。同时，<code>useEffect</code>还提供了清理机制来确保在组件卸载或重新渲染前能够正确地清理副作用。</p><h4 id="React中useCallback的执行本质"><a href="#React中useCallback的执行本质" class="headerlink" title="React中useCallback的执行本质"></a>React中useCallback的执行本质</h4><p>React中的<code>useCallback</code> Hook的执行本质可以概括为：缓存回调函数，避免不必要的重新创建和渲染。</p><p><code>useCallback</code>是一个Hook函数，它接收两个参数：一个回调函数和一个依赖项数组。这个Hook返回一个新的记忆化版本的回调函数，该回调函数只有在依赖项数组中的值发生变化时才会更新。如果依赖项数组没有变化，它将返回之前缓存的回调函数，而不是创建一个新的。</p><p>这种机制的主要目的是优化性能。在React组件中，如果父组件重新渲染，那么所有的子组件（无论其props是否改变）都可能会重新渲染。如果子组件在渲染时创建了新的函数（例如，在事件处理程序中），那么即使这些函数在逻辑上与前一个相同，它们也会被视为新的引用，这可能导致不必要的重新渲染。通过使用<code>useCallback</code>，你可以确保只有当依赖项发生变化时才会创建新的函数，否则将返回相同的函数引用，从而避免了不必要的重新渲染。</p><p>在<code>useCallback</code>的实现中，React会将每个通过<code>useCallback</code>创建的回调函数和它的依赖项数组加入到一个内部的管理队列中。当组件重新渲染时，React会检查这个队列中的每个回调函数，看其依赖项是否发生了变化。如果发生了变化，就创建一个新的回调函数；否则，就返回之前缓存的回调函数。这样，只有当依赖项发生变化时，才会创建新的函数，从而提高了应用的性能。</p><p>需要注意的是，虽然<code>useCallback</code>在某些情况下可以提高性能，但它并不是在所有情况下都需要使用的。过度使用<code>useCallback</code>可能会导致管理队列中的函数过多，从而增加额外的性能开销。因此，在决定是否使用<code>useCallback</code>时，需要根据具体的应用场景和性能需求进行权衡。</p><h4 id="Vue-和-React-对比有什么不同？"><a href="#Vue-和-React-对比有什么不同？" class="headerlink" title="Vue 和 React 对比有什么不同？"></a>Vue 和 React 对比有什么不同？</h4><p>Vue和React都是当前流行的JavaScript前端框架，它们各自有着独特的特点和优势。以下是Vue和React之间的一些主要差异：</p><ol><li>组件化：<ul><li>Vue和React都支持组件化开发，即将页面拆分成多个可复用的组件。然而，它们在组件化的实现上有所不同。Vue使用<code>.vue</code>文件来创建组件，每个<code>.vue</code>文件包含模板、脚本和样式。而React没有模板文件，所有内容都以JSX（JavaScript XML）语法编写在JS文件中。</li></ul></li><li>移动APP开发体验：<ul><li>在移动APP开发方面，Vue主要使用Weex进行移动端开发，而React则主要使用React Native。这两个框架都允许开发者使用JavaScript编写跨平台的移动应用，但它们在实现方式和性能上可能有所不同。</li></ul></li><li>监听数据变化的实现原理：<ul><li>Vue通过getter/setter以及一些函数的劫持知道数据的变化，当数据发生变化时，Vue会触发视图更新。而React则是通过diff算法来比较新旧虚拟DOM之间的差异，并只更新实际发生变化的DOM节点。</li></ul></li><li>数据流：<ul><li>Vue和React都强调单向数据流传递，但Vue通过MVVM（Model-View-ViewModel）框架实现了双向数据绑定。在Vue中，view和model虽然不能直接通信，但可以利用viewmodel中间件实现数据的双向同步。而React则更强调单向数据流，通过props和state来传递和更新数据。</li></ul></li><li>语法：<ul><li>Vue采用自己特有的模板语法，使用<code>.vue</code>文件组织组件。而React则使用JSX语法创建React元素，所有的内容都写在JS文件中。这使得Vue的模板语法更易于理解和使用，而React的JSX则更接近于JavaScript语言本身。</li></ul></li><li>框架轻量级：<ul><li>Vue相对于React来说更轻量级，学习成本低，上手更容易。Vue的设计哲学是“简单而强大”，它鼓励开发者使用简单的方式构建复杂的界面。而React则更强调“一切皆组件”的思想，通过组合简单的组件来构建复杂的界面。</li></ul></li><li>社区和生态系统：<ul><li>React由Facebook开发和维护，拥有庞大的社区和丰富的生态系统。React的文档和教程非常丰富，社区支持也很强大。Vue虽然起步较晚，但也在迅速发展中，其社区和生态系统也在不断壮大。</li></ul></li></ol><p>总的来说，Vue和React各有优势和特点，选择哪个框架取决于项目的具体需求和开发者的个人喜好。</p><h4 id="React的渲染原理"><a href="#React的渲染原理" class="headerlink" title="React的渲染原理"></a>React的渲染原理</h4><p>React的渲染原理主要基于其独特的虚拟DOM（Virtual DOM）和Diffing算法，以及近年来引入的Fiber架构。以下是React渲染原理的简要概述：</p><ol><li><p>虚拟DOM（Virtual DOM）</p><p>：</p><ul><li>React在内存中维护了一个虚拟DOM树，这是真实DOM树的一个轻量级副本。当状态或属性发生变化时，React会生成一个新的虚拟DOM树。</li><li>这个新的虚拟DOM树会与旧的虚拟DOM树进行比较（Diffing），以确定需要更新的最小数量的真实DOM节点。</li></ul></li><li><p>Diffing算法</p><p>：</p><ul><li>React使用了一种高效的Diffing算法（也称为“调和”算法）来比较新旧虚拟DOM树之间的差异。</li><li>该算法通过一些策略（如深度优先遍历、节点标记等）来减少不必要的DOM操作，从而提高性能。</li></ul></li><li><p>Fiber架构</p><p>：</p><ul><li>随着React版本的发展，React团队引入了Fiber架构来改进其内部渲染机制。</li><li>Fiber将渲染任务分解为可中断的小块（称为“工作单元”），使得React能够在不影响用户体验的情况下进行部分重渲染。</li><li>Fiber还引入了优先级的概念，使得React可以优先处理高优先级的任务（如用户交互），然后再处理低优先级的任务。</li></ul></li><li><p>渲染过程</p><p>：</p><ul><li>React的渲染过程可以分为三个阶段：计算阶段（Compute Phase）、渲染阶段（Render Phase）和提交阶段（Commit Phase）。<ul><li>在计算阶段，React会根据组件的更新优先级和调度策略，将工作单元分成多个批次进行处理。</li><li>在渲染阶段，React会根据工作单元的类型和优先级，执行相应的渲染操作，包括创建新的虚拟DOM节点、更新现有的虚拟DOM节点，以及卸载不再需要的组件。</li><li>在提交阶段，React会将更新后的虚拟DOM节点映射到实际的DOM，更新用户界面。这个阶段还会执行一些副作用操作，如执行<code>useEffect</code>。</li></ul></li></ul></li><li><p>并发模式（Concurrency Mode）</p><p>：</p><ul><li>React的并发模式是一种用于处理大型和复杂应用程序的特性，旨在提高应用程序的性能和响应能力。</li><li>并发模式允许React在不影响用户体验的情况下进行部分重渲染，并且提供了更多的控制和灵活性。</li></ul></li></ol><p>总的来说，React的渲染原理是通过虚拟DOM和Diffing算法来减少不必要的DOM操作，提高性能；同时，Fiber架构和并发模式进一步改进了React的内部渲染机制，使其能够更好地处理大型和复杂的应用程序。</p><h4 id="React-中组件的优化方法"><a href="#React-中组件的优化方法" class="headerlink" title="React 中组件的优化方法"></a>React 中组件的优化方法</h4><p>在React中，组件的优化方法有多种，以下是一些常用的优化技巧：</p><blockquote><ol><li><p>减少不必要的渲染</p><p>：</p><ul><li>使用<code>React.memo</code>或<code>PureComponent</code>来减少不必要的重新渲染。这些工具通过浅比较props或state来避免不必要的渲染。</li><li>对于函数组件，可以使用<code>React.memo</code>进行包裹，这样只有当传入的props发生变化时，组件才会重新渲染。</li><li>对于类组件，可以继承<code>React.PureComponent</code>或使用<code>shouldComponentUpdate</code>生命周期方法来进行手动比较和控制是否重新渲染。</li></ul></li><li><p>列表渲染性能优化</p><p>：</p><ul><li>在列表渲染中，为每个列表项提供一个唯一的<code>key</code>属性。这有助于React识别列表项的变化，减少不必要的渲染。</li><li>使用<code>React.Fragment</code>或空的占位元素（如<code>&lt;&gt;&lt;/&gt;</code>）来避免额外的DOM节点，从而减少渲染的复杂度。</li></ul></li><li><p>避免多层级的嵌套组件</p><p>：</p><ul><li>减少组件的嵌套层级，可以降低React的diff算法的复杂度和渲染时间。</li><li>使用高阶组件（HOC）或Render Props模式来替代深层嵌套的组件。</li></ul></li><li><p>懒加载组件</p><p>：</p><ul><li>对于不是立即需要的组件，可以使用React的懒加载（lazy loading）功能来按需加载它们。这可以减少初始渲染的体积和提高首屏加载速度。</li><li>使用<code>React.lazy</code>和<code>Suspense</code>组件来实现懒加载。</li></ul></li><li><p>利用缓存</p><p>：</p><ul><li>使用React的<code>useMemo</code>和<code>useCallback</code> Hooks来缓存昂贵的计算结果和函数，避免在每次渲染时都重新计算。</li><li>这些Hooks允许你提供一个计算函数和依赖项数组，只有当依赖项发生变化时，才会重新计算结果或函数。</li></ul></li><li><p>代码分割</p><p>：</p><ul><li>使用Webpack或其他打包工具进行代码分割，将代码拆分成多个小的包，并在需要时按需加载它们。这可以加快初始加载速度并减少内存使用。</li></ul></li><li><p>优化state更新</p><p>：</p><ul><li>避免在事件处理程序中直接修改state，而是使用setState方法。</li><li>批量更新state，以减少不必要的渲染和重新计算。</li></ul></li><li><p>使用Profiler API</p><p>：</p><ul><li>React Profiler API可以帮助你分析组件的渲染性能，找出性能瓶颈并进行优化。</li></ul></li><li><p>优化第三方库和依赖</p><p>：</p><ul><li>检查项目中使用的第三方库和依赖，确保它们是最新版本且性能良好。</li><li>尽量避免使用过大或性能较差的库，或者寻找替代方案。</li></ul></li><li><p>其他前端通用优化</p><p>：</p><ul><li>使用CSS3动画代替JavaScript动画，以提高性能。</li><li>减少DOM操作，尽量使用React的声明式语法来描述UI。</li><li>压缩和优化图片资源，减少网络传输时间。</li></ul></li></ol></blockquote><p>请注意，以上优化方法并非一成不变，应根据具体的应用场景和需求进行选择和调整。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 - Javascript</title>
      <link href="/2023/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Javascript/"/>
      <url>/2023/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Javascript/</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式（Design pattern），在项目开发过程中面临的一般问题的解决方案，包括JS常见设计模式以及应用场景，适合有JS基础的同学进阶学习。</p></blockquote><h3 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h3><p>​    </p><h4 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式 (Singleton Pattern)"></a>单例模式 (Singleton Pattern)</h4><blockquote><p><strong>简介：</strong> 单例模式是一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点来获取该实例。这在需要控制资源访问、配置管理以及避免重复创建对象时非常有用。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Singleton<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 在这里可以进行一些初始化操作</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      Singleton<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addData</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用单例</span><span class="token keyword">const</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span><span class="token function">addData</span><span class="token punctuation">(</span><span class="token string">'Item 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance2<span class="token punctuation">.</span><span class="token function">addData</span><span class="token punctuation">(</span><span class="token string">'Item 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: ["Item 1", "Item 2"]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1 <span class="token operator">===</span> instance2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: true，它们是同一个实例</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们定义了一个名为 <code>Singleton</code> 的类，构造函数中检查是否已经存在实例，如果不存在则进行初始化并保存实例。</li><li><code>addData</code> 和 <code>getData</code> 方法用于操作和获取数据。</li><li>使用 <code>new</code> 操作符创建对象实例时，始终返回同一个实例。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>全局资源管理：</strong> 单例模式常用于全局配置、日志记录、数据库连接池等场景中，确保只有一个实例用于管理全局资源。</li><li><strong>延迟加载：</strong> 单例模式可以用于延迟对象的创建，直到首次使用时才创建对象，节省资源。</li><li><strong>避免竞态条件：</strong> 在多线程环境中，单例模式可以用于避免竞态条件，确保只有一个实例被创建。</li></ol></blockquote><p>​    单例模式在需要确保只有一个实例存在的情况下非常有用，同时提供了一个全局访问点以方便访问该实例。</p><p>​    </p><h4 id="工厂模式-Factory-Pattern"><a href="#工厂模式-Factory-Pattern" class="headerlink" title="工厂模式 (Factory Pattern)"></a>工厂模式 (Factory Pattern)</h4><blockquote><p><strong>简介：</strong> 工厂模式是一种创建型设计模式，用于封装对象的创建过程，以便根据需要创建不同类型的对象。它将对象的创建与使用分离，使代码更具灵活性和可维护性。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 定义产品类</span><span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`This is a </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义工厂类</span><span class="token keyword">class</span> <span class="token class-name">ProductFactory</span> <span class="token punctuation">{</span>  <span class="token function">createProduct</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用工厂创建不同类型的产品</span><span class="token keyword">const</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProductFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> product1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">'Widget'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> product2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">'Gadget'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>product1<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "This is a Widget."</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>product2<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "This is a Gadget."</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们定义了一个产品类 <code>Product</code>，它有一个构造函数和一个 <code>getDescription</code> 方法。</li><li>工厂类 <code>ProductFactory</code> 包含一个 <code>createProduct</code> 方法，用于创建产品对象。</li><li>使用工厂类创建不同类型的产品对象，客户端代码只需要指定产品的名称，而不需要知道产品的创建细节。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong></p><ol><li><strong>隐藏对象创建细节：</strong> 工厂模式允许隐藏对象的具体创建方式和初始化过程，使客户端代码不需要关心对象的创建细节。</li><li><strong>统一接口：</strong> 工厂模式提供了一个统一的接口，用于创建不同类型的对象，使客户端代码可以通过相同的方式创建不同对象。</li><li><strong>降低耦合性：</strong> 客户端代码与具体对象的创建过程解耦，使代码更容易维护和扩展。如果需要更改对象的创建方式，只需修改工厂类而不影响客户端代码。</li><li><strong>对象池管理：</strong> 工厂模式可以用于创建和管理对象池，以提高性能和资源利用率。例如，数据库连接池可以使用工厂模式来管理连接对象。</li></ol></blockquote><p>   工厂模式通常在需要创建多个具有相似属性和方法的对象实例时使用，以减少重复的代码并提高代码的可维护性。</p><p>​    </p><h4 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式 (Abstract Factory Pattern)"></a>抽象工厂模式 (Abstract Factory Pattern)</h4><blockquote><p><strong>简介：</strong> 抽象工厂模式是一种创建型设计模式，用于创建一组相关或相互依赖的对象，而无需指定其具体类。它提供一个接口，用于创建产品的家族，而不需要知道具体产品的类。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 抽象工厂接口</span><span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>  <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体工厂类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>  <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>  <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 抽象产品类</span><span class="token keyword">class</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span>  <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体产品类</span><span class="token keyword">class</span> <span class="token class-name">ProductA1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation A1'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ProductB1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span>  <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation B1'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ProductA2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation A2'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ProductB2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span>  <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation B2'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用抽象工厂创建产品</span><span class="token keyword">function</span> <span class="token function">clientCode</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> productA <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> productB <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>productA<span class="token punctuation">.</span><span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Operation A1" 或 "Operation A2"</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>productB<span class="token punctuation">.</span><span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Operation B1" 或 "Operation B2"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用具体工厂1</span><span class="token keyword">const</span> factory1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clientCode</span><span class="token punctuation">(</span>factory1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用具体工厂2</span><span class="token keyword">const</span> factory2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clientCode</span><span class="token punctuation">(</span>factory2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们定义了一个抽象工厂接口 <code>AbstractFactory</code>，它包含两个方法 <code>createProductA()</code> 和 <code>createProductB()</code>。</li><li>有两个具体工厂类 <code>ConcreteFactory1</code> 和 <code>ConcreteFactory2</code>，它们分别实现了抽象工厂接口，负责创建一组相关的产品。</li><li>抽象产品类 <code>AbstractProductA</code> 和 <code>AbstractProductB</code> 定义了产品的接口。</li><li>具体产品类 <code>ProductA1</code>、<code>ProductB1</code>、<code>ProductA2</code> 和 <code>ProductB2</code> 实现了抽象产品类，提供具体的产品。</li></ul></blockquote><p>​    </p><p><strong>用途：</strong></p><blockquote><ol><li><strong>创建一组相关对象：</strong> 抽象工厂模式用于创建一组相关的产品，例如创建不同风格的用户界面组件，如按钮、文本框、和下拉框。</li><li><strong>确保产品一致性：</strong> 它确保创建的产品是一致的，因为每个具体工厂都负责创建一组产品，这些产品之间具有一致的风格和行为。</li><li><strong>隐藏对象创建细节：</strong> 抽象工厂模式隐藏了具体对象的创建细节，客户端代码只需要与抽象工厂接口交互，而不需要知道具体的产品类。</li><li><strong>支持产品族扩展：</strong> 可以轻松扩展产品族，只需创建新的具体工厂类，无需修改现有客户端代码。</li></ol></blockquote><p>​    抽象工厂模式通常在需要创建一组相关产品，同时保持这些产品一致性的情况下使用。</p><p>​    </p><h4 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式 (Builder Pattern)"></a>建造者模式 (Builder Pattern)</h4><blockquote><p>​    <strong>简介：</strong> 建造者模式是一种创建型设计模式，用于分步构建一个复杂对象。它将对象的构建过程与其表示分离，允许同一构建过程创建不同的表示。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 产品类</span><span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addPart</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parts<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">listParts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parts<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">', '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 抽象建造者</span><span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>  <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体建造者</span><span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>product<span class="token punctuation">.</span><span class="token function">addPart</span><span class="token punctuation">(</span><span class="token string">'Part A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>product<span class="token punctuation">.</span><span class="token function">addPart</span><span class="token punctuation">(</span><span class="token string">'Part B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>product<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 指挥者</span><span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用建造者构建产品</span><span class="token keyword">const</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> product <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Product Parts:'</span><span class="token punctuation">,</span> product<span class="token punctuation">.</span><span class="token function">listParts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Product Parts: Part A, Part B"</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个产品类 <code>Product</code>，它包含一个数组用于存储部件。</li><li>抽象建造者 <code>Builder</code> 定义了构建产品的步骤，包括 <code>buildPartA</code> 和 <code>buildPartB</code> 方法，以及获取最终产品的 <code>getResult</code> 方法。</li><li>具体建造者 <code>ConcreteBuilder</code> 继承了抽象建造者，并实现了具体的构建步骤。</li><li>指挥者 <code>Director</code> 接受一个建造者，并通过调用建造者的方法来构建产品。</li><li>最后，我们使用具体建造者来构建产品，并获取最终产品。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>构建复杂对象：</strong> 建造者模式用于创建复杂对象，其中构建过程包含多个步骤，不同步骤可以生成不同的表示。</li><li><strong>分离构建和表示：</strong> 它允许将对象的构建过程与其表示分离，从而使代码更加灵活，可以使用不同的构建过程来创建不同的对象。</li><li><strong>避免重叠构造器：</strong> 当有多个构造器参数时，可以使用建造者模式来避免创建多个重叠的构造器。</li></ol></blockquote><p>​    建造者模式常用于创建复杂的对象，例如创建配置对象、文档对象、以及图形对象等。</p><p>​    </p><h4 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式 (Prototype Pattern)"></a>原型模式 (Prototype Pattern)</h4><blockquote><p>​    <strong>简介：</strong>原型模式是一种创建型设计模式，用于创建对象的新实例，同时保持原始对象的原型。这允许通过复制现有对象来创建新对象，而无需重新创建它们。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 原型对象</span><span class="token keyword">class</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>property1 <span class="token operator">=</span> <span class="token string">'Default Value'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建新对象并复制原型属性</span>    <span class="token keyword">const</span> clone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">this<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    clone<span class="token punctuation">.</span>property1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property1<span class="token punctuation">;</span>    <span class="token keyword">return</span> clone<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体原型对象</span><span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">extends</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>property1 <span class="token operator">=</span> <span class="token string">'Custom Value'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用原型创建新对象</span><span class="token keyword">const</span> prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> clone1 <span class="token operator">=</span> prototype<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> clone2 <span class="token operator">=</span> prototype<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>clone1<span class="token punctuation">.</span>property1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Custom Value"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>clone2<span class="token punctuation">.</span>property1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Custom Value"</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个原型对象 <code>Prototype</code>，它包含一个属性 <code>property1</code> 和一个 <code>clone</code> 方法，用于创建新对象并复制原型属性。</li><li>具体原型对象 <code>ConcretePrototype</code> 继承了原型对象，并重写了属性 <code>property1</code>。</li><li>我们创建一个具体原型对象 <code>prototype</code>，然后通过调用 <code>clone</code> 方法来创建新对象 <code>clone1</code> 和 <code>clone2</code>。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>创建对象副本：</strong> 原型模式用于创建对象的副本，新对象包含与原始对象相同的属性和方法。</li><li><strong>避免构造函数调用：</strong> 原型模式创建对象时不会调用构造函数，可以提高性能和避免可能的副作用。</li><li><strong>支持动态配置：</strong> 可以在原型对象上设置默认属性，然后通过复制原型来创建对象，并根据需要更改属性值。</li></ol></blockquote><p>​    原型模式通常在需要创建多个类似对象实例，且这些对象共享某些初始属性或状态时使用。</p><h3 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h3><p>​    </p><h4 id="装饰器模式-Decorator-Pattern"><a href="#装饰器模式-Decorator-Pattern" class="headerlink" title="装饰器模式 (Decorator Pattern)"></a>装饰器模式 (Decorator Pattern)</h4><blockquote><p>​    <strong>简介：</strong>装饰器模式是一种结构型设计模式，用于动态地将新行为附加到对象上，而无需修改其代码。它允许你在运行时通过将对象包装在装饰器对象中来添加新的功能。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 基础组件</span><span class="token keyword">class</span> <span class="token class-name">Coffee</span> <span class="token punctuation">{</span>  <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Coffee'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 装饰器基类</span><span class="token keyword">class</span> <span class="token class-name">CoffeeDecorator</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>coffee<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>coffee <span class="token operator">=</span> coffee<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体装饰器类</span><span class="token keyword">class</span> <span class="token class-name">MilkDecorator</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeDecorator</span> <span class="token punctuation">{</span>  <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">', Milk'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SugarDecorator</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeDecorator</span> <span class="token punctuation">{</span>  <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">', Sugar'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用装饰器</span><span class="token keyword">const</span> plainCoffee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Plain Coffee:'</span><span class="token punctuation">,</span> plainCoffee<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Cost:'</span><span class="token punctuation">,</span> plainCoffee<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> coffeeWithMilk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MilkDecorator</span><span class="token punctuation">(</span>plainCoffee<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Coffee with Milk:'</span><span class="token punctuation">,</span> coffeeWithMilk<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Cost:'</span><span class="token punctuation">,</span> coffeeWithMilk<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> coffeeWithMilkAndSugar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SugarDecorator</span><span class="token punctuation">(</span>coffeeWithMilk<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Coffee with Milk and Sugar:'</span><span class="token punctuation">,</span> coffeeWithMilkAndSugar<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Cost:'</span><span class="token punctuation">,</span> coffeeWithMilkAndSugar<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们有一个基础组件 <code>Coffee</code>，它有 <code>cost</code> 和 <code>getDescription</code> 方法。</li><li>装饰器基类 <code>CoffeeDecorator</code> 包装了基础组件，并重写了相同的方法以添加额外的功能。</li><li>具体装饰器类 <code>MilkDecorator</code> 和 <code>SugarDecorator</code> 继承自装饰器基类，它们重写了 <code>cost</code> 和 <code>getDescription</code> 方法来添加牛奶和糖的功能。</li><li>我们可以创建一个基础组件对象，然后通过将装饰器对象包装在它上面来添加额外的功能。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>动态扩展对象功能：</strong> 装饰器模式允许你在不修改现有对象的情况下，动态地添加新功能。</li><li><strong>避免类爆炸：</strong> 它避免了通过创建多个子类来添加功能，从而减少了类的数量。</li><li><strong>开放封闭原则：</strong> 装饰器模式遵循开放封闭原则，允许你添加新功能而不修改已有代码。</li></ol></blockquote><p>​    装饰器模式通常在需要在运行时添加或删除对象的功能时使用。</p><p>​    </p><h4 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式 (Adapter Pattern)"></a>适配器模式 (Adapter Pattern)</h4><blockquote><p>​    <strong>简介：</strong>适配器模式是一种结构型设计模式，用于将一个类的接口转换成客户端所期望的另一个接口。它允许不兼容的接口能够一起工作。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 老接口</span><span class="token keyword">class</span> <span class="token class-name">OldSystem</span> <span class="token punctuation">{</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation A from Old System'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 新接口</span><span class="token keyword">class</span> <span class="token class-name">NewSystem</span> <span class="token punctuation">{</span>  <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation B from New System'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 适配器类</span><span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>newSystem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>newSystem <span class="token operator">=</span> newSystem<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>newSystem<span class="token punctuation">.</span><span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用适配器</span><span class="token keyword">const</span> newSystem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewSystem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span>newSystem<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newSystem<span class="token punctuation">.</span><span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Operation B from New System"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>adapter<span class="token punctuation">.</span><span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 输出: "Operation B from New System"</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们有一个老系统 <code>OldSystem</code>，它有一个名为 <code>operationA</code> 的方法。</li><li>我们引入了一个新系统 <code>NewSystem</code>，它有一个名为 <code>operationB</code> 的方法。</li><li>为了使老系统的 <code>operationA</code> 方法能够使用新系统的功能，我们创建了一个适配器 <code>Adapter</code>，它包装了新系统的实例并将 <code>operationA</code> 映射到新系统的 <code>operationB</code>。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>兼容新旧代码：</strong> 适配器模式允许在新旧系统之间创建一个桥梁，以便它们可以一起工作，而无需修改已有代码。</li><li><strong>接口转换：</strong> 当需要将一个接口转换成另一个接口时，适配器模式可以用于实现这种转换。</li><li><strong>解耦性：</strong> 适配器模式可以降低两个不同接口之间的耦合性，使系统更加灵活和可维护。</li></ol></blockquote><p>​        适配器模式通常在需要将已有接口与新接口协同工作，或者在整合不同系统时使用。</p><p>​    </p><h4 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式 (Proxy Pattern)"></a>代理模式 (Proxy Pattern)</h4><blockquote><p>​    <strong>简介：</strong>代理模式是一种结构型设计模式，它允许你提供一个代理对象来控制对另一个对象的访问。代理通常用于在访问对象之前或之后执行一些额外的操作，例如延迟加载、权限控制、日志记录等。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 真实主题</span><span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token punctuation">{</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'RealSubject: Handling request.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 代理</span><span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>realSubject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>realSubject <span class="token operator">=</span> realSubject<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>realSubject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">logAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 模拟权限检查</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Proxy: Checking access.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">logAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 模拟日志记录</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Proxy: Logging access.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> realSubject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>realSubject<span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们有一个真实主题 <code>RealSubject</code>，它实现了一个 <code>request</code> 方法。</li><li>代理类 <code>Proxy</code> 包装了真实主题，并在访问真实主题之前执行了权限检查和日志记录。</li><li>客户端代码通过代理对象来访问真实主题。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>远程代理：</strong> 代理模式可以用于实现远程对象的代理，允许客户端访问远程服务器上的对象。</li><li><strong>虚拟代理：</strong> 代理模式可以用于实现虚拟代理，延迟加载对象以节省资源。</li><li><strong>权限控制：</strong> 代理模式可以用于实现权限控制，只有具有适当权限的用户才能访问某些对象。</li><li><strong>日志记录：</strong> 代理模式可以用于记录对象的访问历史和行为，以便调试和监控。</li></ol></blockquote><p>​    代理模式通常在需要在访问对象之前或之后执行某些操作，或者在访问对象时控制访问的情况下使用。</p><p>​    </p><h4 id="桥接模式-Bridge-Pattern"><a href="#桥接模式-Bridge-Pattern" class="headerlink" title="桥接模式 (Bridge Pattern)"></a>桥接模式 (Bridge Pattern)</h4><blockquote><p>​    <strong>简介：</strong>桥接模式是一种结构型设计模式，用于将一个抽象与其实现部分分离，使它们可以独立地变化。它将一个大类或一组类分成两个独立的层次结构，使抽象和实现可以独立扩展。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 实现接口</span><span class="token keyword">class</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体实现类A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorA</span> <span class="token keyword">extends</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Concrete Implementor A Operation'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体实现类B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorB</span> <span class="token keyword">extends</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Concrete Implementor B Operation'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 抽象类</span><span class="token keyword">class</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>implementor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>implementor <span class="token operator">=</span> implementor<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>implementor<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体抽象类X</span><span class="token keyword">class</span> <span class="token class-name">ConcreteAbstractionX</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Concrete Abstraction X: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>implementor<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体抽象类Y</span><span class="token keyword">class</span> <span class="token class-name">ConcreteAbstractionY</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Concrete Abstraction Y: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>implementor<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> implementorA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> implementorB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementorB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> abstractionX <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteAbstractionX</span><span class="token punctuation">(</span>implementorA<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> abstractionY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteAbstractionY</span><span class="token punctuation">(</span>implementorB<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>abstractionX<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Concrete Abstraction X: Concrete Implementor A Operation"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>abstractionY<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Concrete Abstraction Y: Concrete Implementor B Operation"</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们有一个实现接口 <code>Implementor</code>，它包含一个 <code>operation</code> 方法。</li><li>具体实现类 <code>ConcreteImplementorA</code> 和 <code>ConcreteImplementorB</code> 分别实现了 <code>Implementor</code> 接口，并提供具体的操作。</li><li>抽象类 <code>Abstraction</code> 包含一个 <code>Implementor</code> 实例，并提供了一个 <code>operation</code> 方法，该方法调用 <code>Implementor</code> 实例的操作。</li><li>具体抽象类 <code>ConcreteAbstractionX</code> 和 <code>ConcreteAbstractionY</code> 继承自 <code>Abstraction</code>，并可以修改 <code>Implementor</code> 实例的操作结果。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>分离抽象和实现：</strong> 桥接模式将抽象和实现分离，允许它们独立变化，从而提高了代码的灵活性。</li><li><strong>多维度变化：</strong> 当一个类有多个独立的变化维度时，桥接模式可以避免类的指数性增长。</li></ol></blockquote><p>​    桥接模式通常在需要处理多个变化维度且希望避免创建多个类的情况下使用。</p><p>​    </p><h4 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式 (Composite Pattern)"></a>组合模式 (Composite Pattern)</h4><blockquote><p>​    <strong>简介：</strong>组合模式是一种结构型设计模式，用于将对象组合成树状结构以表示部分-整体层次结构。它使客户端可以统一地处理单个对象和组合对象。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 抽象组件</span><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 叶子组件</span><span class="token keyword">class</span> <span class="token class-name">Leaf</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Leaf </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is operated.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 复合组件</span><span class="token keyword">class</span> <span class="token class-name">Composite</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Composite </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is operated.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> child <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>      child<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">add</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">remove</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用组合模式</span><span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">'Root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> branch1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">'Branch 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> branch2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">'Branch 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> leaf1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">'Leaf 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> leaf2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">'Leaf 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> leaf3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">'Leaf 3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>branch1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaf1<span class="token punctuation">)</span><span class="token punctuation">;</span>branch1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaf2<span class="token punctuation">)</span><span class="token punctuation">;</span>branch2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaf3<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>branch1<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>branch2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用操作</span>root<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了抽象组件类 <code>Component</code>，它包含一个 <code>name</code> 属性和一个 <code>operation</code> 方法。</li><li>叶子组件 <code>Leaf</code> 继承自 <code>Component</code>，实现了具体的 <code>operation</code> 方法。</li><li>复合组件 <code>Composite</code> 也继承自 <code>Component</code>，它包含一个 <code>children</code> 数组来存储子组件，并实现了 <code>operation</code>、<code>add</code> 和 <code>remove</code> 方法。</li><li>我们创建了一个组合结构，包括根节点、分支节点和叶子节点，然后通过 <code>add</code> 方法将它们组合在一起。</li><li>最后，我们调用根节点的 <code>operation</code> 方法，它会递归执行所有子组件的 <code>operation</code> 方法。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>表示部分-整体层次结构：</strong> 组合模式用于表示具有部分-整体层次结构的对象，允许客户端一致地处理单个对象和组合对象。</li><li><strong>简化客户端代码：</strong> 客户端不需要知道具体的组合结构，只需与抽象组件类交互。</li><li><strong>支持递归操作：</strong> 组合模式支持递归操作，可以对整个组合结构执行操作。</li></ol></blockquote><p>​    组合模式通常在需要构建具有层次结构的对象，并希望客户端能够一致地处理不同层次的对象时使用。</p><h3 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h3><p>​    </p><h4 id="观察者模式-Observer-Pattern"><a href="#观察者模式-Observer-Pattern" class="headerlink" title="观察者模式 (Observer Pattern)"></a>观察者模式 (Observer Pattern)</h4><blockquote><p>​    <strong>简介：</strong>观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象可以自动收到被观察对象的状态变化通知并进行相应的处理。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 主题 (被观察者)</span><span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>observers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">removeObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> observer <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>      observer<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 观察者接口</span><span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>  <span class="token function">update</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体观察者</span><span class="token keyword">class</span> <span class="token class-name">ConcreteObserverA</span> <span class="token keyword">extends</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>  <span class="token function">update</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Observer A received the update from subject.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConcreteObserverB</span> <span class="token keyword">extends</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>  <span class="token function">update</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Observer B received the update from subject.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> observerA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserverA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> observerB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserverB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>observerA<span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>observerB<span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个主题（被观察者） <code>Subject</code>，它包含了一个观察者数组 <code>observers</code>，并提供了添加、移除、通知观察者的方法。</li><li>观察者接口 <code>Observer</code> 定义了一个 <code>update</code> 方法，具体的观察者需要实现这个方法。</li><li>具体观察者 <code>ConcreteObserverA</code> 和 <code>ConcreteObserverB</code> 继承自 <code>Observer</code>，并实现了 <code>update</code> 方法来处理主题的通知。</li><li>客户端代码创建了一个主题对象，然后添加了两个观察者，最后通过 <code>notifyObservers</code> 方法通知观察者。</li></ul></blockquote><p>​<br>​</p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>解耦性：</strong> 观察者模式可以将主题与观察者解耦，使主题不需要知道观察者的具体实现。</li><li><strong>一对多通知：</strong> 它允许一个主题通知多个观察者，每个观察者可以根据自己的需求对通知做出响应。</li><li><strong>动态变化：</strong> 观察者模式支持动态地添加或移除观察者，主题和观察者之间的关系可以随时变化。</li></ol></blockquote><p>​    观察者模式通常在需要实现发布-订阅系统、事件处理、用户界面组件更新等场景中使用。</p><p>​    </p><h4 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式 (Strategy Pattern)"></a>策略模式 (Strategy Pattern)</h4><blockquote><p> <strong>简介：</strong>策略模式是一种行为型设计模式，它定义了一系列算法，将每个算法封装成一个策略，使这些策略可以互相替换。客户端可以选择不同的策略来实现不同的行为。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 策略接口</span><span class="token keyword">class</span> <span class="token class-name">PaymentStrategy</span> <span class="token punctuation">{</span>  <span class="token function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体策略类：信用卡支付</span><span class="token keyword">class</span> <span class="token class-name">CreditCardPayment</span> <span class="token keyword">extends</span> <span class="token class-name">PaymentStrategy</span> <span class="token punctuation">{</span>  <span class="token function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Paid $</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>amount<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> with Credit Card.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体策略类：PayPal支付</span><span class="token keyword">class</span> <span class="token class-name">PayPalPayment</span> <span class="token keyword">extends</span> <span class="token class-name">PaymentStrategy</span> <span class="token punctuation">{</span>  <span class="token function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Paid $</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>amount<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> with PayPal.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体策略类：现金支付</span><span class="token keyword">class</span> <span class="token class-name">CashPayment</span> <span class="token keyword">extends</span> <span class="token class-name">PaymentStrategy</span> <span class="token punctuation">{</span>  <span class="token function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Paid $</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>amount<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> in Cash.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 环境类</span><span class="token keyword">class</span> <span class="token class-name">ShoppingCart</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>paymentStrategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paymentStrategy <span class="token operator">=</span> paymentStrategy<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">checkout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span> <span class="token punctuation">{</span>      total <span class="token operator">+</span><span class="token operator">=</span> item<span class="token punctuation">.</span>price<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paymentStrategy<span class="token punctuation">.</span><span class="token function">pay</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> cart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShoppingCart</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CreditCardPayment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cart<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Item 1'</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token number">25</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cart<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Item 2'</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cart<span class="token punctuation">.</span><span class="token function">checkout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个策略接口 <code>PaymentStrategy</code>，它包含一个 <code>pay</code> 方法。</li><li>具体策略类 <code>CreditCardPayment</code>、<code>PayPalPayment</code> 和 <code>CashPayment</code> 分别继承自 <code>PaymentStrategy</code>，并实现了 <code>pay</code> 方法来完成具体的支付方式。</li><li>环境类 <code>ShoppingCart</code> 接受一个支付策略，并包含一个 <code>items</code> 数组来存储购物车中的物品。</li><li>客户端代码创建了一个购物车对象，选择了信用卡支付策略，然后添加了两个物品并进行结算。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>多算法选择：</strong> 策略模式用于在运行时选择算法，使客户端能够灵活地选择不同的策略。</li><li><strong>解耦性：</strong> 它将算法的实现与客户端代码分离，提高了代码的可维护性。</li><li><strong>替代继承：</strong> 策略模式可以替代多层继承，避免类爆炸问题。</li></ol></blockquote><p>​    策略模式通常在需要动态地切换算法或在一个类有多种行为变体的情况下使用。</p><p>​    </p><h4 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式 (Command Pattern)"></a>命令模式 (Command Pattern)</h4><blockquote><p><strong>简介：</strong>命令模式是一种行为型设计模式，它将请求封装成一个对象，以便可以对请求的参数化、队列化、记录日志、撤销等操作，从而使系统更加灵活。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 命令接口</span><span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>  <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体命令类：打开电视</span><span class="token keyword">class</span> <span class="token class-name">TVOnCommand</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv <span class="token operator">=</span> tv<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">turnOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体命令类：关闭电视</span><span class="token keyword">class</span> <span class="token class-name">TVOffCommand</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv <span class="token operator">=</span> tv<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">turnOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接收者：电视</span><span class="token keyword">class</span> <span class="token class-name">TV</span> <span class="token punctuation">{</span>  <span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TV is ON'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">turnOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TV is OFF'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 遥控器（调用者）</span><span class="token keyword">class</span> <span class="token class-name">RemoteControl</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>commands <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addCommand</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>commands<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">pressButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> command <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commands<span class="token punctuation">)</span> <span class="token punctuation">{</span>      command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">undoButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> command <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commands<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      command<span class="token punctuation">.</span><span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> tv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> tvOnCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TVOnCommand</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> tvOffCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TVOffCommand</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> remoteControl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RemoteControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>remoteControl<span class="token punctuation">.</span><span class="token function">addCommand</span><span class="token punctuation">(</span>tvOnCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>remoteControl<span class="token punctuation">.</span><span class="token function">addCommand</span><span class="token punctuation">(</span>tvOffCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>remoteControl<span class="token punctuation">.</span><span class="token function">pressButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 打开电视</span>remoteControl<span class="token punctuation">.</span><span class="token function">undoButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 关闭电视</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个命令接口 <code>Command</code>，它包含 <code>execute</code> 和 <code>undo</code> 方法。</li><li>具体命令类 <code>TVOnCommand</code> 和 <code>TVOffCommand</code> 分别继承自 <code>Command</code>，并封装了打开和关闭电视的操作。</li><li>接收者 <code>TV</code> 包含了实际的电视操作。</li><li>遥控器 <code>RemoteControl</code> 包含了命令列表，并提供了 <code>pressButton</code> 和 <code>undoButton</code> 方法来执行和撤销命令。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>将请求封装成对象：</strong> 命令模式将请求和其参数封装成一个对象，可以用于参数化、队列化、撤销等操作。</li><li><strong>解耦性：</strong> 客户端不需要知道命令的具体实现，从而降低了命令发送者和接收者之间的耦合度。</li><li><strong>支持撤销操作：</strong> 命令模式支持撤销操作，通过 <code>undo</code> 方法可以还原之前的操作。</li></ol></blockquote><p>​    命令模式通常在需要将请求参数化、支持撤销操作或实现命令队列等场景中使用。</p><p>​    </p><h4 id="发布-订阅模式-Publish-Subscribe-Pattern"><a href="#发布-订阅模式-Publish-Subscribe-Pattern" class="headerlink" title="发布-订阅模式 (Publish-Subscribe Pattern)"></a>发布-订阅模式 (Publish-Subscribe Pattern)</h4><blockquote><p>​    <strong>简介：</strong>发布-订阅模式是一种行为型设计模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。<br>​    </p></blockquote><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 发布者 (发布事件的对象)</span><span class="token keyword">class</span> <span class="token class-name">Publisher</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">subscribe</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">notify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> subscriber <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">)</span> <span class="token punctuation">{</span>      subscriber<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 订阅者 (订阅事件的对象)</span><span class="token keyword">class</span> <span class="token class-name">Subscriber</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">update</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> received update with data: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> publisher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Publisher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> subscriberA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subscriber</span><span class="token punctuation">(</span><span class="token string">'Subscriber A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> subscriberB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subscriber</span><span class="token punctuation">(</span><span class="token string">'Subscriber B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> subscriberC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subscriber</span><span class="token punctuation">(</span><span class="token string">'Subscriber C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subscriberA<span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subscriberB<span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subscriberC<span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">'Message 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscriberB<span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">'Message 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个发布者 <code>Publisher</code>，它包含了一个订阅者数组 <code>subscribers</code>，并提供了订阅、取消订阅和通知的方法。</li><li>订阅者 <code>Subscriber</code> 有一个 <code>name</code> 属性，并实现了 <code>update</code> 方法来处理接收到的通知。</li><li>客户端代码创建了一个发布者对象，然后添加了三个订阅者，并发送两条通知消息。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>解耦性：</strong> 发布-订阅模式用于解耦发布者和订阅者，使它们可以独立演化。</li><li><strong>事件处理：</strong> 它常用于事件处理机制，让多个对象监听并响应事件。</li><li><strong>消息通信：</strong> 发布-订阅模式可用于消息通信，不同部分之间可以通过事件进行通信。</li></ol></blockquote><p>​    发布-订阅模式通常在需要实现松散耦合、事件驱动、多对多通信等场景中使用。</p><p>​    </p><h4 id="模块模式-Module-Pattern"><a href="#模块模式-Module-Pattern" class="headerlink" title="模块模式 (Module Pattern)"></a>模块模式 (Module Pattern)</h4><blockquote><p>​    <strong>简介：</strong>模块模式是一种设计模式，用于将代码组织成可维护和可重用的模块，同时隐藏了内部实现的细节。它通过使用闭包来创建私有变量和函数，提供了一种封装数据和行为的方法。</p></blockquote><p>​<br><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 模块</span><span class="token keyword">const</span> myModule <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 私有变量</span>  <span class="token keyword">let</span> privateVar <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 私有函数</span>  <span class="token keyword">function</span> <span class="token function">privateFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Private Function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    privateVar<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 公有接口（可以访问私有成员）</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    publicVar<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>    publicFunction<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Public Function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">privateFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    getPrivateVar<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> privateVar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 客户端代码</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myModule<span class="token punctuation">.</span>publicVar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 访问公有变量</span>myModule<span class="token punctuation">.</span><span class="token function">publicFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 调用公有函数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myModule<span class="token punctuation">.</span><span class="token function">getPrivateVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 获取私有变量</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们创建了一个匿名的立即执行函数，它返回一个包含公有接口的对象，这个对象可以访问模块内部的私有变量和函数。</li><li>模块内部定义了私有变量 <code>privateVar</code> 和私有函数 <code>privateFunction</code>，它们无法在模块外部直接访问。</li><li>公有接口包含了公有变量 <code>publicVar</code>、公有函数 <code>publicFunction</code> 和一个获取私有变量的方法 <code>getPrivateVar</code>。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>封装数据和行为：</strong> 模块模式用于将数据和行为封装在一个模块内，隐藏了内部实现的细节，提供了一个清晰的公共接口。</li><li><strong>单例模式：</strong> 模块模式可以用于创建单例对象，确保只有一个实例存在。</li><li><strong>避免全局污染：</strong> 使用模块模式可以避免将变量和函数添加到全局作用域，减少了命名冲突的可能性。</li></ol></blockquote><p>​    模块模式通常在需要封装一组相关的变量和函数，并将其隐藏在模块内部的情况下使用，以提高代码的可维护性和可复用性。</p><p>​    </p><h4 id="模板方法模式-Template-Method-Pattern"><a href="#模板方法模式-Template-Method-Pattern" class="headerlink" title="模板方法模式 (Template Method Pattern)"></a>模板方法模式 (Template Method Pattern)</h4><blockquote><p>​    <strong>简介：</strong>模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，将具体步骤的实现延迟到子类。模板方法使子类可以在不改变算法结构的情况下重新定义算法的某些步骤。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 模板类</span><span class="token keyword">class</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Game initialized.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Game ended.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体游戏类：Basketball</span><span class="token keyword">class</span> <span class="token class-name">BasketballGame</span> <span class="token keyword">extends</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>  <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Playing basketball.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体游戏类：Soccer</span><span class="token keyword">class</span> <span class="token class-name">SoccerGame</span> <span class="token keyword">extends</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>  <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Playing soccer.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> basketball <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasketballGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>basketball<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> soccer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoccerGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>soccer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个抽象的游戏类 <code>Game</code>，它包含了一个模板方法 <code>start</code>，以及初始化方法 <code>initialize</code>、游戏方法 <code>play</code> 和结束方法 <code>end</code>。</li><li><code>start</code> 方法按照固定的顺序调用了 <code>initialize</code>、<code>play</code> 和 <code>end</code> 方法，这个顺序定义了游戏的骨架。</li><li>具体游戏类 <code>BasketballGame</code> 和 <code>SoccerGame</code> 继承自 <code>Game</code> 并实现了 <code>play</code> 方法，从而定义了具体的游戏行为。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>定义算法骨架：</strong> 模板方法模式用于定义算法的骨架，将算法的步骤抽象出来，并允许子类提供具体实现。</li><li><strong>代码复用：</strong> 它提供了一种重用代码的方式，将通用部分放在模板方法中，将变化的部分留给子类。</li><li><strong>防止滥用继承：</strong> 模板方法模式避免了滥用继承，因为它允许在不改变算法结构的情况下重定义部分步骤。</li></ol></blockquote><p>​    模板方法模式通常在需要定义算法骨架、有多个子类共享一些公共行为、避免代码重复等情况下使用。</p><p>​    </p><h4 id="迭代器模式-Iterator-Pattern"><a href="#迭代器模式-Iterator-Pattern" class="headerlink" title="迭代器模式 (Iterator Pattern)"></a>迭代器模式 (Iterator Pattern)</h4><blockquote><p>​    <strong>简介：</strong>迭代器模式是一种行为型设计模式，用于提供一种顺序访问集合对象元素的方法，而不需要暴露集合的内部表示。它允许客户端访问集合对象中的元素，而不必了解底层数据结构。</p></blockquote><p>​<br><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 迭代器接口</span><span class="token keyword">class</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>collection <span class="token operator">=</span> collection<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体迭代器：数组迭代器</span><span class="token keyword">class</span> <span class="token class-name">ArrayIterator</span> <span class="token keyword">extends</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>  <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>collection<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>collection<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 集合类</span><span class="token keyword">class</span> <span class="token class-name">Collection</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> collection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Collection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>collection<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token string">'Item 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>collection<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token string">'Item 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>collection<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token string">'Item 3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> iterator <span class="token operator">=</span> collection<span class="token punctuation">.</span><span class="token function">getIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个迭代器接口 <code>Iterator</code>，它包含了 <code>hasNext</code> 和 <code>next</code> 方法。</li><li>具体迭代器 <code>ArrayIterator</code> 继承自 <code>Iterator</code>，实现了针对数组的迭代逻辑。</li><li>集合类 <code>Collection</code> 包含一个数组 <code>items</code> 和一个获取迭代器的方法 <code>getIterator</code>。</li><li>客户端代码创建了一个集合对象，添加了三个元素，然后获取了一个迭代器并使用 <code>while</code> 循环遍历元素。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>封装集合遍历逻辑：</strong> 迭代器模式封装了集合遍历的逻辑，使客户端代码不必了解底层数据结构。</li><li><strong>支持多种集合类型：</strong> 它可以为不同类型的集合提供通用的遍历方式，无需修改客户端代码。</li><li><strong>提供一致的接口：</strong> 迭代器模式为不同集合提供了一致的接口，简化了客户端代码。</li></ol></blockquote><p>​    迭代器模式通常在需要遍历集合对象、隐藏集合的内部结构、支持不同类型的集合等场景中使用。</p><p>​    </p><h4 id="责任链模式-Chain-of-Responsibility-Pattern"><a href="#责任链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="责任链模式 (Chain of Responsibility Pattern)"></a>责任链模式 (Chain of Responsibility Pattern)</h4><blockquote><p> <strong>简介：</strong>责任链模式是一种行为型设计模式，用于构建一个对象链，每个对象都有机会处理请求，但请求会在链上传递直到有一个对象处理它为止。责任链模式将请求发送者与接收者解耦，允许多个对象都有机会处理请求。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 处理请求的抽象处理者</span><span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">setSuccessor</span><span class="token punctuation">(</span>successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">=</span> successor<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体处理者 A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerA</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>  <span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>request <span class="token operator">===</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Handler A is handling the request.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>successor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体处理者 B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerB</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>  <span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>request <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Handler B is handling the request.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>successor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> handlerA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> handlerB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>handlerA<span class="token punctuation">.</span><span class="token function">setSuccessor</span><span class="token punctuation">(</span>handlerB<span class="token punctuation">)</span><span class="token punctuation">;</span>handlerA<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Handler A is handling the request.</span>handlerA<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Handler B is handling the request.</span>handlerA<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (No handler can handle the request.)</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个抽象的处理者类 <code>Handler</code>，它包含一个指向下一个处理者的引用 <code>successor</code> 和一个 <code>handleRequest</code> 方法。</li><li>具体处理者类 <code>ConcreteHandlerA</code> 和 <code>ConcreteHandlerB</code> 继承自 <code>Handler</code>，并实现了自己的 <code>handleRequest</code> 方法来处理请求。</li><li>客户端代码创建了两个具体处理者对象，然后通过 <code>setSuccessor</code> 方法设置它们的处理顺序，最后调用第一个处理者的 <code>handleRequest</code> 方法来处理请求。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>解耦发送者和接收者：</strong> 责任链模式将请求的发送者和接收者解耦，允许多个对象都有机会处理请求，从而降低了它们之间的依赖关系。</li><li><strong>动态构建责任链：</strong> 可以动态地添加、删除或修改处理者，以满足不同的请求处理需求。</li><li><strong>避免硬编码逻辑：</strong> 责任链模式可以避免硬编码请求的处理逻辑，使代码更加灵活和可维护。</li></ol></blockquote><p>​    责任链模式通常在需要动态决定请求的处理顺序、多个对象有机会处理请求、避免请求发送者和接收者之间紧密耦合的情况下使用。</p><p>​    </p><h4 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式 (State Pattern)"></a>状态模式 (State Pattern)</h4><blockquote><p>​    <strong>简介：</strong>状态模式是一种行为型设计模式，它允许对象在内部状态发生改变时改变它的行为。这种模式将状态封装成独立的类，并将上下文对象委托给当前状态对象，以便在状态发生变化时切换到不同的状态。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 状态接口</span><span class="token keyword">class</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>  <span class="token function">handle</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体状态类：开机状态</span><span class="token keyword">class</span> <span class="token class-name">PowerOnState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>  <span class="token function">handle</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TV is ON'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PowerOffState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体状态类：关机状态</span><span class="token keyword">class</span> <span class="token class-name">PowerOffState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>  <span class="token function">handle</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TV is OFF'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PowerOnState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 上下文类</span><span class="token keyword">class</span> <span class="token class-name">TVContext</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PowerOffState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">setState</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> tv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TVContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tv<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TV is OFF</span>tv<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TV is ON</span>tv<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TV is OFF</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个状态接口 <code>State</code>，它包含一个 <code>handle</code> 方法。</li><li>具体状态类 <code>PowerOnState</code> 和 <code>PowerOffState</code> 继承自 <code>State</code>，并分别实现了 <code>handle</code> 方法来处理开机和关机状态。</li><li>上下文类 <code>TVContext</code> 包含一个当前状态对象，并提供了 <code>setState</code> 和 <code>request</code> 方法。<code>setState</code> 方法用于切换当前状态，而 <code>request</code> 方法用于发出请求，委托给当前状态来处理。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong></p><ol><li><strong>封装状态：</strong> 状态模式将每个状态封装成一个独立的类，使状态的变化对上下文对象透明，提高了代码的可维护性。</li><li><strong>减少条件语句：</strong> 它避免了大量的条件语句，使代码更加清晰和可读。</li><li><strong>支持扩展性：</strong> 可以轻松地添加新的状态类，扩展系统的行为。</li></ol></blockquote><p>​    状态模式通常在需要对象在不同状态下执行不同操作的场景中使用，它有助于将状态转换和状态处理的逻辑封装起来，提高了代码的可扩展性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js设计与实现</title>
      <link href="/2023/06/12/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/06/12/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue的设计模式"><a href="#Vue的设计模式" class="headerlink" title="Vue的设计模式"></a>Vue的设计模式</h3><h4 id="MVC-和-MVVM-区别"><a href="#MVC-和-MVVM-区别" class="headerlink" title="MVC 和 MVVM 区别"></a>MVC 和 MVVM 区别</h4><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范</p><ul><li>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li><li>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</li><li>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据</li></ul><p>MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。</p><h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><p>MVVM 新增了 VM 类</p><blockquote><p>ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</p></blockquote><p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</p><p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p><blockquote><p>注意：Vue 并没有完全遵循 MVVM 的思想 这一点官网自己也有说明。严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</p></blockquote><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/../images/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/vue-life.jpg" alt="Vue生命周期"></p><blockquote><p><strong>beforeCreate</strong> 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问</p><p><strong>created</strong> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom</p><p><strong>beforeMount</strong> 在挂载开始之前被调用：相关的 render 函数首次被调用。</p><p><strong>mounted</strong> 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点</p><p><strong>beforeUpdate</strong> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p><p><strong>updated</strong> 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。</p><p><strong>beforeDestroy</strong> 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。</p><p><strong>destroyed</strong> Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p><p><strong>activated</strong> keep-alive 专属，组件被激活时调用</p><p><strong>deactivated</strong> keep-alive 专属，组件被销毁时调用</p></blockquote><h4 id="keep-alive-中的生命周期有哪些"><a href="#keep-alive-中的生命周期有哪些" class="headerlink" title="keep-alive 中的生命周期有哪些"></a>keep-alive 中的生命周期有哪些</h4><blockquote><p>​    keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存，在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。 如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。</p><p>​    同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。 当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期； 当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。</p></blockquote><h4 id="异步请求在哪一步发起？"><a href="#异步请求在哪一步发起？" class="headerlink" title="异步请求在哪一步发起？"></a>异步请求在哪一步发起？</h4><blockquote><p>可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p><p>如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面  loading 时间；</li><li>ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul></blockquote><h4 id="Vue-的父子组件生命周期钩子函数执行顺序"><a href="#Vue-的父子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父子组件生命周期钩子函数执行顺序"></a>Vue 的父子组件生命周期钩子函数执行顺序</h4><blockquote><p><strong>加载渲染过程:</strong></p><p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p><p><strong>子组件更新过程:</strong></p><p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p><p><strong>父组件更新过程:</strong></p><p>父 beforeUpdate-&gt;父 updated</p><p><strong>销毁过程:</strong></p><p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p></blockquote><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><h4 id="组件中为什么-data-是一个函数？"><a href="#组件中为什么-data-是一个函数？" class="headerlink" title="组件中为什么 data 是一个函数？"></a>组件中为什么 <code>data</code> 是一个函数？</h4><blockquote><p>在 Vue 组件中，为什么 <code>data</code> 是一个函数而不是一个对象的原因是为了确保每个组件实例都有其自己的数据副本。当组件被定义时，<code>data</code> 必须是一个函数。每次创建组件实例时，Vue 都会调用该函数来返回一个全新的数据对象。</p><p>这是因为 Vue 组件可以在应用中存在多个实例，每个实例都应该具有独立的状态和数据。如果 <code>data</code> 是一个对象，那么所有组件实例将共享相同的数据对象，这将导致一个实例的数据变化会影响到其他实例。</p><p>通过将 <code>data</code> 定义为函数，Vue 在创建组件实例时会为每个实例调用该函数，从而返回一个新的数据对象。这样，每个组件实例都有自己的数据副本，它们之间相互独立，可以独立地修改和维护各自的状态。</p></blockquote><h4 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h4><p>v-model 其实就是语法糖，v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><blockquote><p>text 和 textarea 元素使用 value property 和 input 事件；</p><p>checkbox 和 radio 使用 checked property 和 change 事件；</p><p>select 字段将 value 作为 prop 并将 change 作为事件。</p></blockquote><p>在普通标签上:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  //这一行等于下一行<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth <span class="token punctuation">=</span> $event.target.value<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>在组件上:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>currency-input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>price<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>currentcy-input</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--上行代码是下行的语法糖 &lt;currency-input :value="price" @input="price = arguments[0]">&lt;/currency-input>--></span><span class="token comment" spellcheck="true">&lt;!-- 子组件定义 --></span>Vue.component('currency-input', { template: `  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>    <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>input<span class="token punctuation">"</span></span>    <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span>    <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>input<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>   <span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> `, props: ['value'],})</code></pre><h4 id="Vue数据双向绑定原理"><a href="#Vue数据双向绑定原理" class="headerlink" title="Vue数据双向绑定原理"></a>Vue数据双向绑定原理</h4><h5 id="vue的响应式基本原理："><a href="#vue的响应式基本原理：" class="headerlink" title="vue的响应式基本原理："></a>vue的响应式基本原理：</h5><blockquote><p>1、vue会遍历此data中对象所有的属性，</p><p>2、并使用Object.defineProperty进行数据劫持，把这些属性全部转为getter/setter，</p><p>3、而每个组件实例都有watcher对象，</p><p>4、它会在组件渲染的过程中把属性记录为依赖，</p><p>5、之后当依赖项的 setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p></blockquote><p>eg：</p><p>Object.defineProperty( ):</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    name <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"My name is "</span> <span class="token operator">+</span> name  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span> person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jayhodon'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// My name is Jayhodon</span></code></pre><h5 id="vue的响应式原理设计三个重要对象："><a href="#vue的响应式原理设计三个重要对象：" class="headerlink" title="vue的响应式原理设计三个重要对象："></a>vue的响应式原理设计三个重要对象：</h5><blockquote><p>Observer对象：vue中的数据对象在初始化过程中转换为Observer对象。</p><p>Watcher对象：将模板和Observer对象结合在一起生成Watcher实例，Watcher是订阅者中的订阅者。</p><p>Dep对象：Watcher对象和Observer对象之间纽带，每一个Observer都有一个Dep实例，用来存储订阅者Watcher。</p></blockquote><p>当属性变化会执行主题对象Observer的dep.notify方法， 这个方法会遍历订阅者Watcher列表向其发送消息， Watcher会执行run方法去更新视图。模板编译过程中的指令和数据绑定都会生成Watcher实例，实例中的watch属性也会生成Watcher实例。</p><p>总的来说就是：</p><blockquote><p>1、在生命周期的initState方法中将data，prop，method，computed，watch中的数据劫持， 通过observe方法与Object.defineProperty方法将相关对象转为换Observer对象。</p><p>2、然后在initRender方法中解析模板，通过Watcher对象，Dep对象与观察者模式将模板中的 指令与对象的数据建立依赖关系，使用全局对象Dep.target实现依赖收集。</p><p>3、当数据变化时，setter被调用，触发Object.defineProperty方法中的dep.notify方法， 遍历该数据依赖列表，执行器update方法通知Watcher进行视图更新。</p></blockquote><h5 id="使用Object-defineProperty实现监听变量"><a href="#使用Object-defineProperty实现监听变量" class="headerlink" title="使用Object.defineProperty实现监听变量:"></a>使用Object.defineProperty实现监听变量:</h5><p>实现步骤：</p><p>Observer：</p><p> 用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Observer<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    walk<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            self<span class="token punctuation">.</span><span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    defineReactive<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> childObj <span class="token operator">=</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 递归遍历所有子属性</span>        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>            enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> getter <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断是否需要添加订阅者，并添加订阅者</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> val<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> setter <span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>                dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果数据发生了变化，则通知所有的订阅者</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>value <span class="token operator">||</span> <span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数</span><span class="token keyword">function</span> Dep <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Dep<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    addSub<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    notify<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code></pre><p>Watcher：</p><p> 可以收到属性的变化通知并执行相应的函数，从而更新视图。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> exp<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>exp <span class="token operator">=</span> exp<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将自己添加到订阅器的操作</span><span class="token punctuation">}</span>Watcher<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    update<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    run<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>exp<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> oldVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!==</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>cb<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 缓存自己</span>        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>exp<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">// 强制执行监听器里的get函数</span>        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 释放自己</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这时只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> SelfVue <span class="token punctuation">(</span>data<span class="token punctuation">,</span> el<span class="token punctuation">,</span> exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>exp<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化模板数据的值</span>    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> exp<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>完整版参考自：<a href="https://www.cnblogs.com/libin-1/p/6893712.html">vue的双向绑定原理及实现</a>    <a href="https://github.com/canfoo/self-vue/tree/master/v3">源 码</a></p><h5 id="使用ES6的proxy简单实现监听变量"><a href="#使用ES6的proxy简单实现监听变量" class="headerlink" title="使用ES6的proxy简单实现监听变量:"></a>使用ES6的proxy简单实现监听变量:</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> msg<span class="token punctuation">:</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//懒监听，去获取的时候才监听对象里面的对象，而不是直接递归循环监听</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//数组新增会执行两次，一次是修改length，一次是添加值</span>  <span class="token keyword">let</span> oldValue <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>oldValue<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//找不到老值，新增</span>  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>oldValue <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//老值和新值不相等，修改</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>proxy<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span></code></pre><p>区别：</p><blockquote><p>1、语法层面上</p><p>defineProperty只能响应首次渲染时候的属性，</p><p>defineProperty无法一次性监听所有属性，必须通过遍历或者递归的方式来实现且无法监听新增的属性，对于数组defineProperty则需要劫持数组方法。</p><p>Proxy需要的是整体监听，不需要关心里面有什么属性，而且Proxy的配置项有13种，可以做更细致的事情，这是之前的defineProperty无法达到的。</p><p>2、兼容层面上</p><p>vue2.x之所以只能兼容到IE8就是因为defineProperty无法兼容IE8,其他浏览器也会存在轻微兼容问题。</p><p>proxy的话除了IE，其他浏览器都兼容，这次vue3还是使用了它，说明vue3直接放弃了IE的兼容考虑。</p></blockquote><p> 为什么Vue 3 使用 Proxy 替代了 Vue 2 中的 Object.defineProperty：</p><blockquote><ol><li>更好的性能：Vue 3 使用 Proxy 可以提供比 Object.defineProperty 更高的性能。Proxy 可以拦截更多的操作，包括属性访问、属性设置、删除属性等，而 Object.defineProperty 只能拦截属性的读取和设置。</li><li>更好的扩展性：Proxy 提供了更多的拦截方法，可以针对更多的操作进行定制。这使得 Vue 3 在响应式系统的实现上更加灵活和可扩展。</li><li>更好的支持嵌套对象：Proxy 对于嵌套对象的响应式支持更加完善。Vue 3 的响应式系统可以追踪到嵌套对象的变化，并在需要时触发更新。</li><li>更好的 TypeScript 支持：Proxy 的类型推断更准确，可以提供更好的 TypeScript 支持，让开发者在编码过程中能够获得更准确的类型提示和错误检查。</li></ol></blockquote><p>​    总体来说，Vue 3 使用 Proxy 替代了 Vue 2 中的 Object.defineProperty，主要是为了提供更好的性能、更好的扩展性、更好的嵌套对象支持和更好的 TypeScript 支持。这些改进使得 Vue 3 在响应式系统的实现上更加先进和灵活，提供了更好的开发体验和性能优化。</p><h4 id="Vue-中的数据为什么频繁变化时只会更新一次-？"><a href="#Vue-中的数据为什么频繁变化时只会更新一次-？" class="headerlink" title="Vue 中的数据为什么频繁变化时只会更新一次 ？"></a>Vue 中的数据为什么频繁变化时只会更新一次 ？</h4><p>​    在 Vue 中，当数据频繁变化时，Vue 会对数据变化进行优化处理，以减少不必要的更新操作，从而提高性能。    </p><blockquote><p>Vue 使用了异步更新队列的机制，即将数据变化的通知放入队列中，然后在下一个事件循环周期中统一进行更新操作。这样做的好处是，当数据频繁变化时，不会立即触发更新，而是等待下一个事件循环周期进行批量更新，从而避免了频繁的更新操作。</p><p>具体来说，当多次修改数据时，Vue 会将这些修改操作合并为一个更新操作。例如，连续对同一个数据进行多次修改，只会触发一次更新操作，以最终的修改结果为准。</p><p>这种优化机制可以有效减少不必要的 DOM 操作和重新渲染，提升性能和效率。同时，也避免了频繁的更新导致的性能问题和不必要的资源消耗。</p></blockquote><p>​    然而，需要注意的是，由于异步更新机制，Vue 在某些特定场景下可能无法立即获取到最新的数据。如果需要在数据更新后立即执行某些操作，可以利用 Vue 提供的 <code>$nextTick</code> 方法或使用 Vue 的生命周期钩子函数来确保在更新完成后执行相应的操作。</p><p>​    总之，Vue 的更新机制保证了数据变化的高效处理，并通过合并操作减少了不必要的更新，提升了应用的性能和响应速度。</p><p>​    </p><h5 id="this-nextTick-作用及实现原理"><a href="#this-nextTick-作用及实现原理" class="headerlink" title="this.$nextTick() 作用及实现原理"></a>this.$nextTick() 作用及实现原理</h5><p>​    <code>this.$nextTick()</code> 是 Vue 实例提供的一个方法，用于在 DOM 更新完成后执行回调函数。它的作用是确保在下次 DOM 更新循环结束后执行回调函数，以获取到最新的 DOM 状态。</p><blockquote><p>实现原理：</p><ol><li>当调用 <code>this.$nextTick()</code> 方法时，Vue 会将传入的回调函数添加到一个队列中，该队列用于存储待执行的回调函数。</li><li>Vue 会检测当前是否存在微任务（Promise 或 MutationObserver）或宏任务（setTimeout 或 setImmediate）队列。</li><li>如果存在微任务或宏任务队列，则将回调函数添加到微任务或宏任务队列中，确保在下一个事件循环周期中执行。</li><li>如果当前不存在微任务或宏任务队列，则创建一个微任务队列，并将回调函数添加到其中。</li><li>在下一个事件循环周期中，Vue 会执行微任务队列中的所有回调函数，并将其从队列中移除。</li></ol></blockquote><p>​    通过这种机制，<code>this.$nextTick()</code> 方法可以保证在 DOM 更新完成后执行回调函数，以便获取到最新的 DOM 状态。这在某些场景下非常有用，比如在修改数据后立即获取更新后的 DOM 元素，或在更新后对某些 DOM 操作进行后续处理。</p><p>​    需要注意的是，由于 <code>this.$nextTick()</code> 方法使用了异步更新机制，因此回调函数的执行时机不是立即的，而是在下一个事件循环周期中。如果需要在回调函数执行完成后执行一些操作，可以在回调函数中进行处理，或者使用 <code>Promise</code> 或 <code>async/await</code> 来等待回调函数执行完成。</p><h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><h4 id="Vue-组件通讯有哪几种方式"><a href="#Vue-组件通讯有哪几种方式" class="headerlink" title="Vue 组件通讯有哪几种方式"></a>Vue 组件通讯有哪几种方式</h4><blockquote><ol><li><p>props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的</p></li><li><p>$parent,$children 获取当前组件的父组件和当前组件的子组件</p></li><li><p>父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用，用于跨级通讯)</p></li><li><p>$refs 获取组件实例</p></li><li><p>envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式</p></li><li><p>vuex 状态管理</p></li></ol></blockquote><p><strong>props &amp; $emit:</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>Son @changeData<span class="token operator">=</span><span class="token string">"changeData"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span> <span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'@/components/son'</span> <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>   name<span class="token punctuation">:</span><span class="token string">'Father'</span><span class="token punctuation">,</span>   components<span class="token punctuation">:</span><span class="token punctuation">{</span>Son<span class="token punctuation">}</span><span class="token punctuation">,</span>   methods<span class="token punctuation">:</span><span class="token punctuation">{</span>     <span class="token function">changeData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//来自子组件的数据</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>el<span class="token operator">-</span>button @click<span class="token operator">=</span><span class="token string">"handleEmit"</span><span class="token operator">></span>通知父组件需要更改数据了<span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span> <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>   name<span class="token punctuation">:</span><span class="token string">'Son'</span><span class="token punctuation">,</span>   methods<span class="token punctuation">:</span><span class="token punctuation">{</span>     <span class="token function">handleEmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'changeData'</span><span class="token punctuation">,</span><span class="token string">'这是来自子组件的数据'</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>$parent &amp; $children：</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>子组件<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span><span class="token string">"Son"</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>      sonData<span class="token punctuation">:</span> <span class="token string">'子组件的数据'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">sonHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'子组件的方法'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>fatherData<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//父组件的数据</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span><span class="token function">fantherHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//父组件的方法</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>Son<span class="token operator">></span>父组件<span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'./son.vue'</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'father'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    Son  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>      fatherData<span class="token punctuation">:</span> <span class="token string">'父组件的数据'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">fantherHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'父组件的方法'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sonTitle<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//子组件的数据</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sonHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//子组件的方法</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>这里要注意父组件要在mounted（）这个生命周期对子组件进行取值因为在这时候子组件才完成了 created 与 mounted，并且获取到的数据是一个数组的形式。</p><p><strong>provide $ inject：</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*父组件*/</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span> provide<span class="token punctuation">:</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span><span class="token punctuation">{</span>     provideData<span class="token punctuation">:</span> <span class="token string">'父组件的数据'</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*子组件*/</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  inject<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'provideData'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  created <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>provideName<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//"父组件的数据"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>$refs：</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>Son ref<span class="token operator">=</span><span class="token string">"son"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'./son.vue'</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'father'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    Son  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>son<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*组件实例*/</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>envetBus：</strong></p><p>需要先创建一个公共的eventBus.js，并将Vue实例暴露出去</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p> 在需要组件通信的组件A中引入eventBus.js，并通过$emit发布回调事件</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>组件A<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>el<span class="token operator">-</span>button @click<span class="token operator">=</span><span class="token string">"changeData"</span><span class="token operator">></span>修改数据A<span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>button<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../bus.js"</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">changeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"editData"</span><span class="token punctuation">,</span> <span class="token string">'这是修改后的数据'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>组件B中同样引入eventBus.js文件，并通过$on监听事件回调</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>组件B<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../bus.js"</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  mounted<span class="token punctuation">:</span><span class="token punctuation">{</span>    EventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'editData'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><h4 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h4><p>在 Vue 中，父子组件之间可以通过 props 和事件来进行通信。</p><ol><li><p>父组件向子组件传递数据：通过在父组件中使用 props 将数据传递给子组件。子组件可以在其模板中通过使用 props 来接收父组件传递的数据。</p><p>父组件：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>ChildComponent <span class="token punctuation">:</span>message<span class="token operator">=</span><span class="token string">"parentMessage"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">'./ChildComponent.vue'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      parentMessage<span class="token punctuation">:</span> <span class="token string">'Hello from parent'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>    ChildComponent<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>子组件：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre></li><li><p>子组件通过触发事件改变父组件的值：子组件可以通过 $emit 方法触发自定义事件，从而通知父组件进行相应的操作。</p><p>父组件：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>ChildComponent <span class="token punctuation">:</span>counter<span class="token operator">=</span><span class="token string">"counter"</span> @increment<span class="token operator">=</span><span class="token string">"handleIncrement"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>Counter<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> counter <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">'./ChildComponent.vue'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      counter<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>    ChildComponent<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">handleIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>子组件：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"handleClick"</span><span class="token operator">></span>Increment<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'counter'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre></li></ol><p>​    通过上述方式，父子组件可以进行数据的传递和通信。子组件可以通过触发事件的方式来改变父组件的值。需要注意的是，子组件不能直接修改父组件的 props 数据，而是通过事件向父组件发送请求，由父组件进行相应的操作来修改数据。</p><p>​    如果子组件需要修改父组件的数据，父组件可以将需要修改的数据作为 props 传递给子组件，然后子组件通过触发事件来请求父组件进行数据的修改。这样可以保持数据流的单向性，提高组件的可维护性和可预测性。</p><h4 id="平行组件通信"><a href="#平行组件通信" class="headerlink" title="平行组件通信"></a>平行组件通信</h4><p>在 Vue 中，平行组件之间的通信可以通过以下几种方式实现：</p><blockquote><ol><li>使用共享状态（Shared State）：可以创建一个共享的数据源，例如 Vuex 状态管理库或者一个全局的事件总线。所有的平行组件都可以访问和修改这个共享的状态，从而实现通信。</li><li>使用父组件作为中介：如果平行组件位于同一个父组件下，可以通过父组件作为中介来进行通信。平行组件通过将需要共享的数据或者方法传递给父组件，再由父组件将数据或者方法传递给其他平行组件。</li><li>使用事件总线：可以创建一个全局的事件总线，利用 Vue 的实例作为事件中心，平行组件通过订阅和触发事件来进行通信。</li><li>使用浏览器的事件系统：平行组件可以通过浏览器的事件系统（如 <code>window.dispatchEvent</code> 和 <code>window.addEventListener</code>）来进行通信。组件可以通过触发自定义事件，然后在其他组件中通过监听这些事件来实现通信。</li><li>使用非父子组件通信插件：可以使用一些 Vue 的插件来实现非父子组件之间的通信，例如 Vue Bus、mitt 等。</li></ol></blockquote><p>​    需要根据具体的场景和需求选择合适的通信方式。在选择通信方式时，可以考虑组件之间的关系、数据的复杂度以及通信的频率等因素。</p><h3 id="状态管理-Vuex"><a href="#状态管理-Vuex" class="headerlink" title="状态管理 - Vuex"></a>状态管理 - Vuex</h3><p>​    Vuex是Vue.js官方提供的状态管理模式和库。它被设计用于解决Vue应用中的状态管理问题。Vuex基于Flux架构和Redux模式，提供了一种集中管理和共享状态的机制。</p><p>Vuex的核心概念包括：</p><blockquote><ol><li>State（状态）：用于存储应用的状态数据，类似于组件中的data。它是响应式的，可以通过getter获取和修改。</li><li>Mutation（变更）：用于修改状态的方法，类似于组件中的methods。只能进行同步操作，且只能在mutation中修改状态。</li><li>Action（动作）：用于处理异步操作或复杂的业务逻辑，可以包含多个mutation的组合。可以触发mutation来修改状态。</li><li>Getter（获取器）：用于派生状态，类似于组件中的computed。可以对状态进行计算和包装，提供派生的数据。</li><li>Module（模块）：将大型应用的状态拆分为多个模块，每个模块有自己的state、mutation、action和getter。</li></ol></blockquote><p>​    通过使用Vuex，我们可以集中管理和共享应用的状态，使得状态的变化和处理逻辑更可控和可维护。它适用于大型的、状态复杂的应用，可以简化组件之间的通信，提高代码的可读性和可测试性。同时，Vuex也提供了开发工具和插件，方便调试和扩展。</p><p>​    在Vue应用中使用Vuex需要先安装和配置，然后在组件中引入和使用。通过定义state、mutations、actions和getters，我们可以在组件中访问和修改共享状态。Vuex还提供了一些辅助函数和工具，用于简化使用和处理异步操作。</p><h4 id="mutations-能不能做异步"><a href="#mutations-能不能做异步" class="headerlink" title="mutations 能不能做异步"></a>mutations 能不能做异步</h4><p>​    在Vuex中，mutations默认是同步操作，只能用于修改状态的同步变更。这是为了确保状态的变更是可追踪和可预测的。</p><p>​    在某些情况下，我们可能需要在mutations中进行异步操作，比如在异步请求数据后再修改状态。然而，直接在mutations中执行异步操作是不被推荐的做法，因为它会破坏状态变更的可追踪性。</p><p>​    如果需要进行异步操作，可以使用actions来处理。Actions可以包含异步操作，并且可以触发mutations来修改状态。这样可以保持状态变更的可追踪性，同时也可以方便地进行异步处理。</p><p>示例代码：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Vuex store</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>    count<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">increment</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">decrement</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">asyncIncrement</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在组件中使用</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'decrement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">asyncIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'asyncIncrement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>​    在上述示例中，通过<code>context.commit</code>来触发mutation的执行，<code>this.$store.dispatch</code>来触发action的执行。这样就可以实现异步操作并且保持状态变更的可追踪性。</p><p>​    虽然mutations默认是同步操作，但可以通过actions来处理异步操作，并在actions中触发mutations来修改状态。这样可以更好地控制和管理状态的变更过程。</p><h4 id="Vuex-页面刷新数据丢失怎么解决"><a href="#Vuex-页面刷新数据丢失怎么解决" class="headerlink" title="Vuex 页面刷新数据丢失怎么解决"></a>Vuex 页面刷新数据丢失怎么解决</h4><p>​    当刷新页面时，由于Vuex中的数据存储在内存中，数据会丢失。这是因为Vuex是基于客户端的状态管理库，数据不会被持久化保存。每次刷新页面都会重新初始化Vuex的状态。</p><p>​    为了解决刷新页面导致Vuex数据丢失的问题，可以考虑以下几种方法：</p><blockquote><ol><li>使用持久化方案：可以将Vuex的状态持久化保存到本地存储（如localStorage或sessionStorage）中。在应用初始化时，从本地存储中读取状态并还原到Vuex中。这样可以在刷新页面后重新加载保存的状态，避免数据丢失。</li><li>利用路由参数或URL查询参数传递数据：将需要持久化的数据通过路由参数或URL查询参数传递给其他页面。这样在刷新页面时，可以通过获取路由参数或URL查询参数来恢复数据。</li><li>使用后端存储方案：如果应用需要长期保存状态数据，并且在不同设备或浏览器中共享状态，可以考虑将状态数据存储在后端服务器或数据库中。在刷新页面时，可以通过请求后端获取保存的状态数据并还原到Vuex中。</li></ol></blockquote><p>​    vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件。推荐使用 <code>vuex-persist</code> 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中</p><blockquote><p>​    ps: 需要根据具体的应用场景和需求选择适合的方法。持久化方案和后端存储方案可能需要进行数据序列化和反序列化操作，以确保数据的正确保存和恢复。同时，需要注意数据的安全性和隐私保护，避免敏感数据泄露。</p></blockquote><h4 id="Vuex-和-localStorage-的区别"><a href="#Vuex-和-localStorage-的区别" class="headerlink" title="Vuex 和 localStorage 的区别"></a>Vuex 和 localStorage 的区别</h4><p>Vuex和localStorage是两种不同的概念和用途：</p><blockquote><ol><li>Vuex：Vuex是Vue.js官方提供的状态管理库。它用于在Vue应用中集中管理和共享状态。Vuex的目的是解决组件之间共享数据、状态管理和数据流的问题。Vuex提供了一种集中式的数据存储机制，可以在多个组件中访问和修改共享的状态，以实现组件之间的通信和数据同步。Vuex的数据存储在内存中，它是基于内存的状态管理解决方案，适用于应用内部的数据共享和状态管理。</li><li>localStorage：localStorage是Web浏览器提供的一种本地存储机制。它允许将数据以键值对的形式存储在浏览器的本地存储空间中，并且数据在页面刷新或关闭后仍然保持有效。localStorage提供了持久化的存储能力，可以在不同的页面和会话中共享数据。localStorage中的数据以字符串形式存储，需要进行数据的序列化和反序列化。</li></ol></blockquote><p>区别：</p><blockquote><ul><li>Vuex是专门为Vue应用设计的状态管理库，用于管理应用内的状态和数据流，解决组件之间的数据共享和状态管理问题。而localStorage是Web浏览器提供的一种本地存储机制，用于持久化地存储数据，并且在不同的浏览器会话中共享数据。</li><li>Vuex的数据存储在内存中，适用于应用内部的数据共享和状态管理，而localStorage的数据存储在浏览器的本地存储空间中，可以在不同的页面和会话中共享数据。</li><li>Vuex提供了一套API和机制用于管理和修改状态，包括使用mutation修改状态、使用action处理异步操作等。而localStorage是基于键值对的简单存储机制，只能通过setItem和getItem等方法进行基本的数据存储和读取，没有提供数据管理和状态变更的机制。</li></ul></blockquote><p>​    Vuex适用于Vue应用内部的状态管理和数据共享，而localStorage适用于持久化地存储和共享数据。在具体使用时，可以根据应用需求选择合适的方案或结合两者使用。</p><h3 id="虚拟-dom-和-diff-算法"><a href="#虚拟-dom-和-diff-算法" class="headerlink" title="虚拟 dom 和 diff 算法"></a>虚拟 dom 和 diff 算法</h3><p>​    虚拟DOM（Virtual DOM）和差异算法（Diff Algorithm）是前端领域中常用的概念，它们在优化页面渲染性能和提升开发效率方面发挥了重要作用。</p><blockquote><p>​    虚拟DOM是一种以JavaScript对象形式表示的轻量级的内存中的DOM表示。它是对真实DOM的一种抽象和模拟，在内存中进行操作和计算，然后再将结果批量更新到真实的DOM上。虚拟DOM的目的是在保持视图和状态同步的同时，减少对真实DOM的直接操作，从而提升性能和响应速度。</p><p>​    差异算法（Diff Algorithm）是虚拟DOM的核心算法之一，用于比较两个虚拟DOM树之间的差异，并将差异应用到真实的DOM上。通过比较新旧虚拟DOM树的差异，可以准确地找出需要更新的部分，避免全量更新整个DOM树，从而减少不必要的操作和性能损耗。</p></blockquote><p>​    Diff算法的基本原理是对比新旧虚拟DOM树的节点，找出发生变化的节点，然后根据变化类型（插入、更新、移除等）对真实DOM进行相应的操作。Diff算法通常采用深度优先遍历的方式，通过递归遍历虚拟DOM树的节点，对比节点之间的差异，生成更新操作的指令。</p><p>常用的Diff算法有两种实现方式：基于递归的Diff算法和基于循环的Diff算法。</p><blockquote><p>​    基于递归的Diff算法简单直观，但在处理大型虚拟DOM树时可能存在性能问题。</p><p>​    基于循环的Diff算法采用迭代的方式，通过循环遍历虚拟DOM树的节点，以较低的时间复杂度找出差异。</p></blockquote><p>​    虚拟DOM和差异算法是前端开发中用于优化页面渲染性能的重要技术。虚拟DOM提供了一种高效的内存中的DOM表示，而差异算法则能够准确地比较两个虚拟DOM树之间的差异，最小化对真实DOM的操作，从而提高页面的性能和响应速度。</p><h4 id="什么是虚拟-dom-？有什么用？"><a href="#什么是虚拟-dom-？有什么用？" class="headerlink" title="什么是虚拟 dom ？有什么用？"></a>什么是虚拟 dom ？有什么用？</h4><p>​    虚拟DOM（Virtual DOM）是一种在内存中构建和操作的虚拟的DOM树。它是对真实DOM的一种抽象和模拟，用JavaScript对象表示整个DOM结构及其属性。</p><p>​    虚拟DOM的基本思想是将页面的状态（数据）和视图（DOM）分离，通过对虚拟DOM的操作来更新视图，而不是直接操作真实的DOM。当数据发生变化时，会通过比较新旧虚拟DOM的差异（Diff算法），找出需要更新的部分，然后将更新应用到真实DOM上，从而保持页面和数据的同步。</p><p>虚拟DOM的主要优点包括：</p><blockquote><ol><li>性能优化：通过将DOM操作集中在虚拟DOM上，减少了直接操作真实DOM的次数，从而提高了性能。虚拟DOM可以批量更新真实DOM，避免了频繁的重绘和回流。</li><li>跨平台能力：虚拟DOM可以在不同的平台上运行，例如浏览器、移动端、服务器端等。这样可以实现一次编写，多平台复用。</li><li>方便的UI组件化：虚拟DOM可以将整个页面划分为组件，每个组件都有自己的虚拟DOM。这样可以实现组件的高度复用和模块化开发。</li><li>简化复杂的UI更新逻辑：通过比较新旧虚拟DOM的差异，可以精确地找出需要更新的部分，避免全量更新整个DOM树，从而简化了复杂的UI更新逻辑。</li></ol></blockquote><p>​    虚拟DOM通过在内存中构建和操作DOM的抽象表示，提供了一种高效、跨平台、组件化的方式来管理和更新页面的视图。它是现代前端框架（如React、Vue等）中的重要概念，能够提升开发效率和页面性能。</p><h5 id="虚拟DOM的解析过程"><a href="#虚拟DOM的解析过程" class="headerlink" title="虚拟DOM的解析过程:"></a>虚拟DOM的解析过程:</h5><p>虚拟DOM的解析过程可以简单分为三个步骤：<strong>创建</strong>、<strong>更新</strong>和<strong>渲染</strong>。</p><blockquote><ol><li>创建虚拟DOM（Virtual DOM）：在应用程序初始化时，通过使用特定的语法或调用相关API创建虚拟DOM。虚拟DOM是使用JavaScript对象表示整个DOM结构及其属性，它包括节点类型、标签名、属性、子节点等信息。</li><li>更新虚拟DOM：当应用程序的状态（数据）发生变化时，需要更新虚拟DOM以反映这些变化。这个过程通常由框架或库内部的更新机制自动处理，它会根据新的数据生成新的虚拟DOM，并与旧的虚拟DOM进行比较，找出差异（Diff算法）。</li><li>渲染虚拟DOM：在更新虚拟DOM后，需要将最新的虚拟DOM渲染到真实的DOM上，以更新页面的显示。这个过程通常由框架或库提供的渲染引擎负责处理，它会根据虚拟DOM的变化，将变化部分应用到真实DOM上，从而更新页面的内容。</li></ol></blockquote><p>具体来说，虚拟DOM的解析过程如下：</p><blockquote><ol><li>创建虚拟DOM：根据应用程序的需求，通过特定的语法或调用相关API创建虚拟DOM。这可以是手动创建的，也可以是由框架或库自动生成的。</li><li>更新虚拟DOM：当应用程序的状态发生变化时，生成新的虚拟DOM，并与旧的虚拟DOM进行比较，找出差异（Diff算法）。差异通常包括节点的增、删、改、移等操作。</li><li>应用差异：将差异应用到真实DOM上，更新页面的显示。这个过程可以通过操作真实DOM进行，也可以通过一些优化技术（例如批量更新、异步渲染等）来提高性能。</li><li>渲染页面：根据最新的虚拟DOM，将其渲染到真实DOM上，更新页面的内容。这可以是整个虚拟DOM的渲染，也可以是部分虚拟DOM的渲染，具体取决于差异的范围。</li></ol></blockquote><p>​    虚拟DOM的解析过程是一个通过创建、更新和渲染虚拟DOM来实现页面更新的过程。它通过比较差异，减少了对真实DOM的频繁操作，提高了性能和用户体验。</p><h4 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h4><p>​    Diff算法是虚拟DOM更新的核心算法，它用于比较新旧虚拟DOM之间的差异，并根据差异进行最小化的DOM操作，以提高更新效率。</p><p>​    Diff算法的基本原理是通过逐层比较新旧虚拟DOM的节点，找出节点之间的差异，并记录下来。它遵循以下几个基本规则：</p><blockquote><ol><li>同层比较：Diff算法会逐层比较新旧虚拟DOM的节点，并将它们进行一一对比。如果节点类型不同，直接替换节点；如果节点类型相同但属性不同，更新节点的属性；如果节点类型和属性都相同，继续比较其子节点。</li><li>列表比较：当比较的节点是列表（数组）类型时，Diff算法会使用特定的算法进行列表比较，例如使用唯一的key来标识列表项，以避免整个列表重新渲染。</li><li>唯一标识：Diff算法会使用唯一的标识（通常是key属性）来识别节点，以便在比较过程中准确定位节点的位置，从而进行精确的差异对比和操作。</li><li>递归比较：Diff算法会递归地比较节点的子节点，以确保所有层级的差异都能被发现和处理。</li></ol></blockquote><p>​    通过以上规则，Diff算法能够在比较的过程中找出两个虚拟DOM之间的差异，并生成一个差异对象（或称为补丁），记录下需要进行的DOM操作，例如插入、删除、更新等。然后，这个差异对象可以被应用到真实的DOM上，进行最小化的DOM操作，以实现页面的更新。</p><p>​    Diff算法的优点是能够准确地识别差异，并最小化DOM操作，提高页面更新的效率。然而，它也有一些限制和性能方面的考虑，例如当比较的虚拟DOM结构非常复杂时，Diff算法的性能可能会下降，需要合理地设计虚拟DOM结构和优化更新策略来提升性能。</p><p>​    Diff算法是虚拟DOM实现高效更新的核心，它通过比较新旧虚拟DOM之间的差异，实现最小化的DOM操作，从而提高页面更新的效率。</p><h4 id="Vue-中-key-的作用"><a href="#Vue-中-key-的作用" class="headerlink" title="Vue 中 key 的作用"></a>Vue 中 key 的作用</h4><p>在Vue中，key是用于识别VNode（虚拟DOM节点）的特殊属性。它的作用主要有以下几个方面：</p><blockquote><ol><li>提供唯一标识：每个VNode都应该具有唯一的key值，用于在diff算法中准确地识别VNode节点的变化。通过key，Vue可以精确地判断哪些VNode是新增的、哪些是删除的，从而最小化DOM操作，提高页面更新的效率。</li><li>优化列表渲染：当使用v-for指令进行列表渲染时，每个列表项都应该提供一个唯一的key值。这样，Vue可以基于key的变化来确定列表项的新增、删除、移动等操作，从而避免重新渲染整个列表，提高列表渲染的性能。</li><li>维持组件状态：当使用key在动态组件或条件渲染中切换组件时，key的变化可以强制Vue销毁旧组件并创建新组件。这样做可以保持组件的状态和避免重用旧组件的状态，确保组件能够正确地更新和重新渲染。</li></ol></blockquote><p>​    需要注意的是，key的值应该是稳定且唯一的。在使用v-for渲染列表时，推荐使用具有唯一性的属性值作为key，如ID或其他唯一标识符。避免使用索引作为key，因为索引在列表发生变化时可能会导致错误的渲染结果。</p><p>​    Vue中的key属性用于唯一标识VNode，它在diff算法中起着重要的作用，能够提高页面更新的效率、优化列表渲染，并维持组件的状态。合理使用key可以确保Vue能够准确地识别和处理VNode的变化，提供更好的性能和用户体验。</p><h3 id="Vue2-与-Vue3的区别"><a href="#Vue2-与-Vue3的区别" class="headerlink" title="Vue2 与 Vue3的区别"></a>Vue2 与 Vue3的区别</h3><h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><blockquote><ul><li>Vue2：Vue2的生命周期包括beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed等钩子函数。这些钩子函数允许我们在组件的不同生命周期阶段执行特定的操作，例如在created钩子函数中进行数据初始化，在mounted钩子函数中操作DOM元素等。</li><li>Vue3：Vue3保留了大部分Vue2的生命周期钩子函数，但也引入了新的钩子函数如setup。setup钩子函数用于代替Vue2中的beforeCreate和created钩子函数，它提供了更灵活的组合式函数编程方式，可以更好地封装组件逻辑和复用代码。</li></ul></blockquote><h4 id="Diff算法："><a href="#Diff算法：" class="headerlink" title="Diff算法："></a>Diff算法：</h4><blockquote><ul><li>Vue2：Vue2使用基于虚拟DOM的Diff算法来计算需要更新的最小操作，然后将这些操作应用于真实的DOM树。Vue2的Diff算法会比较新旧虚拟DOM树的差异，然后只对差异部分进行更新，以减少不必要的DOM操作，提高性能和渲染效率。</li><li>Vue3：Vue3在Diff算法方面进行了优化。首先，Vue3使用了基于Proxy的响应式系统，通过代理对象来监听数据的变化，从而减少了对getter和setter的劫持，提升了性能。其次，Vue3引入了静态标记，即在编译阶段对模板进行静态分析，标记出静态节点，从而避免在Diff算法中对这些静态节点进行比较，进一步提高了性能和渲染效率。</li></ul></blockquote><h4 id="数据响应式原理："><a href="#数据响应式原理：" class="headerlink" title="数据响应式原理："></a>数据响应式原理：</h4><blockquote><ul><li>Vue2：Vue2使用Object.defineProperty实现数据的响应式。当数据被访问或修改时，Vue2通过劫持数据的get和set方法来追踪数据的变化。这样一来，当数据发生变化时，Vue2能够检测到变化并通知相关的组件进行更新。</li><li>Vue3：Vue3使用Proxy对象实现数据的响应式。Proxy对象可以代理目标对象并拦截对目标对象的访问和修改操作。通过代理对象的监听和触发机制，Vue3能够实时地追踪数据的变化，并触发相应的更新操作，从而实现数据响应式。</li></ul></blockquote><h4 id="组件通讯："><a href="#组件通讯：" class="headerlink" title="组件通讯："></a>组件通讯：</h4><blockquote><ul><li>Vue2：Vue2中组件通讯主要通过props和$emit进行父子组件之间的通讯。父组件通过props将数据传递给子组件，子组件通过$emit触发自定义事件来通知父组件。此外，Vue2还提供了事件总线、Vuex等方式来实现非父子组件之间的通讯。</li><li>Vue3：Vue3保留了Vue2的组件通讯方式，即父子组件之间通过props和emit进行通讯。而与Vue2不同的是，Vue3引入了Composition API，提供了更灵活的组合式函数编程方式来处理组件之间的通讯。通过使用Composition API中的响应式函数、上下文传递等特性，我们可以更方便地在组件之间共享状态和方法。</li></ul></blockquote><h4 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h4><p>​    Composition API 是 Vue 3 中引入的一种新的 API 风格，用于编写组件的逻辑和复用代码。它是一种基于函数的 API，与 Vue 2 中的选项式 API（Options API）相比，Composition API 更加灵活、组合性更强，能够更好地组织和管理组件的代码。</p><p>​    使用 Composition API，我们可以将一个组件的相关逻辑聚合在一起，而不是按照选项的顺序分散在不同的生命周期钩子函数中。这使得组件的逻辑更加清晰、可读性更高，同时也方便代码的复用和测试。</p><p>​    Composition API 提供了一系列的函数和响应式的 API，例如 <code>setup</code> 函数、<code>ref</code>、<code>reactive</code>、<code>watch</code> 等，用于定义组件的状态和行为。下面是 Composition API 的一些特点和用法：</p><blockquote><ol><li><code>setup</code> 函数：在组件中使用 <code>setup</code> 函数来定义组件的状态和行为。<code>setup</code> 函数在组件创建之前执行，可以访问组件的 props 和 context，并返回一个对象，这个对象中的属性和方法将被暴露给组件的模板部分使用。</li><li><code>ref</code> 和 <code>reactive</code>：<code>ref</code> 和 <code>reactive</code> 是用于创建响应式数据的 API。<code>ref</code> 用于创建一个单一的响应式数据，而 <code>reactive</code> 用于创建一个包含多个属性的响应式对象。</li><li><code>watch</code>：<code>watch</code> 函数用于监听响应式数据的变化，并在数据变化时执行相应的操作。它可以监听单个数据或多个数据，还可以设置深度监听、异步监听等。</li><li>生命周期钩子函数：在 Composition API 中，生命周期钩子函数的命名发生了变化，例如 <code>beforeCreate</code> 和 <code>created</code> 改为了 <code>onBeforeMount</code> 和 <code>onMounted</code>。这些钩子函数可以在 <code>setup</code> 函数中使用，与其他逻辑代码一起组合。</li><li>自定义函数：在 Composition API 中，我们可以自定义函数来封装和复用一些逻辑代码，而不必依赖于特定的生命周期钩子函数。</li></ol></blockquote><p>​    使用 Composition API，我们能够更好地组织组件的代码，提高代码的可读性和维护性。它适用于编写中小型到大型复杂组件，并且提供了更好的代码复用和测试能力。</p><p>​    Vue3在许多其他方面也进行了改进和优化，如编译优化、TypeScript支持、组合式API等。开发者在选择Vue版本时，需要根据项目需求和实际情况综合考虑，以及考虑迁移成本和团队熟悉度等因素。</p><h4 id="vue2以及vue3的diff算法有了解吗-他们之间的不同是什么"><a href="#vue2以及vue3的diff算法有了解吗-他们之间的不同是什么" class="headerlink" title="vue2以及vue3的diff算法有了解吗 他们之间的不同是什么"></a>vue2以及vue3的diff算法有了解吗 他们之间的不同是什么</h4><p>Vue.js的diff算法是其用于比较新旧虚拟DOM树并确定最小更新集的核心机制。Vue 2和Vue 3的diff算法在设计和实现上有一些重要的不同。</p><p><strong>Vue 2的diff算法</strong></p><p>Vue 2的diff算法主要关注于组件级别的更新，而不是细粒度的DOM节点级别的比较。以下是Vue 2 diff算法的一些关键点：</p><ol><li><strong>同级比较</strong>：Vue 2的diff算法只比较同一层级的节点，不跨层级比较。</li><li><strong>双端比较</strong>：当列表更新时，Vue 2会采用双端比较的策略，从列表的头部和尾部开始比较，然后逐渐向中心逼近，以尽量减少节点的移动次数。</li><li><strong>更新策略</strong>：当无法通过头尾比较找到匹配的节点时，Vue 2会尝试复用旧节点，通过更新节点的属性或子节点来匹配新的虚拟节点，并将其移动到正确的位置。</li></ol><p>然而，Vue 2的diff算法也存在一些限制，例如它不会进行跨层级的节点比较，这可能导致一些不必要的DOM操作。</p><p><strong>Vue 3的diff算法</strong></p><p>Vue 3对diff算法进行了重大改进，以进一步提高性能并减少不必要的DOM操作。以下是Vue 3 diff算法的一些主要变化：</p><ol><li><strong>基于Proxy的响应式系统</strong>：Vue 3使用了基于Proxy的响应式系统，能够更精确地追踪数据变化，从而减少了不必要的计算和渲染。这使得diff算法在比较新旧虚拟DOM树时能够更准确地确定需要更新的部分。</li><li><strong>静态提升</strong>：Vue 3在编译阶段会对模板进行静态分析，将不会改变的静态节点提升到渲染函数之外。这样，在每次渲染时，这些静态节点就不会被重新创建和比较，从而减少了不必要的计算和DOM操作。</li><li><strong>块级更新</strong>：Vue 3引入了块级更新的概念，将组件树拆分为多个块，每个块都拥有自己的渲染函数和依赖关系。当某个块的数据发生变化时，只有该块及其子块会被重新渲染和比较，而不是整个组件树。这进一步减少了不必要的计算和DOM操作。</li><li><strong>事件监听器的优化</strong>：Vue 3对事件监听器进行了优化，使用了一种称为“事件委托”的技术来减少事件监听器的数量。这样，当事件触发时，Vue 3可以更快地找到并处理相应的事件监听器，从而提高了性能。</li></ol><p>总的来说，Vue 3的diff算法通过更精确的追踪数据变化、静态提升、块级更新和事件监听器的优化等手段，进一步提高了Vue应用的渲染性能和用户体验。</p><h4 id="Vue3相对于Vue2进行了哪些优化？"><a href="#Vue3相对于Vue2进行了哪些优化？" class="headerlink" title="Vue3相对于Vue2进行了哪些优化？"></a>Vue3相对于Vue2进行了哪些优化？</h4><ol><li><strong>更灵活的响应式系统</strong>：Vue 2.x 中响应式系统的核心是 <strong>Object.defineProperty</strong>，劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式。Vue 3.x 中使用 <strong>Proxy</strong>对象重写响应式系统。</li><li><strong>更快的渲染速度</strong>：Vue3 的编译器生成的渲染函数比 Vue2 生成的更高效。</li><li><strong>编译阶段</strong>：Vue 2.x 通过标记静态节点，优化 diff 的过程。Vue 3.x中<strong>标记和提升</strong>所有的静态节点，diff的时候<strong>只需要对比动态节点</strong>内容。</li><li><strong>更小的体积</strong>：Vue3 将源码拆分为多个独立的模块，这样就可以按需导入所需的模块，从而减小了整个库的体积。</li><li><strong>更好的 TypeScript 支持</strong>：Vue3 对 TypeScript 的支持更加友好，内部使用了更先进的 TypeScript 特性，并为其提供了更好的声明文件。</li><li><strong>更好的组件系统</strong>：比如，Vue3中引入了一个新的 <code>Fragment</code> 组件，它可以替代原来的 <code>template</code> 标签作为根节点</li><li><strong>新增了setup组合式API</strong></li></ol><h3 id="路由-vue-router"><a href="#路由-vue-router" class="headerlink" title="路由 - vue-router"></a>路由 - vue-router</h3><h4 id="vue-router-中常用的路由模式实现原理吗"><a href="#vue-router-中常用的路由模式实现原理吗" class="headerlink" title="vue-router 中常用的路由模式实现原理吗"></a>vue-router 中常用的路由模式实现原理吗</h4><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a><strong>hash 模式</strong></h5><ol><li>location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li><li>可以为 hash 的改变添加监听事件</li></ol><pre class=" language-javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"hashchange"</span><span class="token punctuation">,</span> funcRef<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了</p><blockquote><p>特点：兼容性好但是不美观</p></blockquote><h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a><strong>history 模式</strong></h5><p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p><p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p><blockquote><p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p></blockquote><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><p>路由守卫是在路由导航过程中进行拦截和控制的功能。</p><p>Vue Router 提供了以下几种类型的路由守卫：</p><blockquote><ol><li>全局前置守卫（Global Before Guards）：<ul><li><code>beforeEach(to, from, next)</code>：在每个路由跳转之前调用，可以用来进行全局的前置验证或处理逻辑。</li></ul></li><li>路由独享的守卫（Per-Route Guards）：<ul><li><code>beforeEnter(to, from, next)</code>：在某个特定路由配置中定义的守卫，只会对该路由生效。</li></ul></li><li>组件内的守卫（In-Component Guards）：<ul><li><code>beforeRouteEnter(to, from, next)</code>：在进入路由对应的组件之前调用，可以访问组件实例，但此时组件实例还没有被创建。</li><li><code>beforeRouteUpdate(to, from, next)</code>：在当前路由组件复用时调用，例如在同一路由下切换不同的参数。</li><li><code>beforeRouteLeave(to, from, next)</code>：在离开当前路由组件时调用，可以阻止离开或在离开前进行一些处理。</li></ul></li></ol></blockquote><p>这些守卫函数接收三个参数：</p><ul><li><code>to</code>：即将进入的目标路由对象</li><li><code>from</code>：当前导航正要离开的路由对象</li><li><code>next</code>：函数，用于进入下一个守卫或确认导航</li></ul><p>在守卫函数中，可以通过调用 <code>next()</code> 方法来进行导航控制：</p><ul><li>调用 <code>next()</code> 进行正常导航</li><li>调用 <code>next(false)</code> 中止当前导航</li><li>调用 <code>next(&#39;/path&#39;)</code> 或 <code>next(&#123; path: &#39;/path&#39; &#125;)</code> 进行重定向导航</li></ul><p>使用路由守卫可以实现诸如登录验证、权限控制、页面访问限制等功能，提供了灵活且强大的路由导航控制机制。 <a href="https://router.vuejs.org/guide/advanced/navigation-guards.html">Vue Router 的官方文档</a></p><h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><h4 id="Vue3中组合式Api对比选项式Api的区别与优势"><a href="#Vue3中组合式Api对比选项式Api的区别与优势" class="headerlink" title="Vue3中组合式Api对比选项式Api的区别与优势"></a>Vue3中组合式Api对比选项式Api的区别与优势</h4><p>Vue 3中引入的组合式API（Composition API）与Vue 2中的选项式API（Options API）在设计和使用上有一些明显的区别与优势。</p><p><strong>区别</strong>：</p><ol><li><strong>结构组织</strong>：选项式API基于对象的设计方式，将Vue实例的各个部分（如data、methods、computed、watch等）拆分成不同的选项，并在创建Vue实例时将它们作为选项传入。而组合式API允许将数据和方法组合在一起，以提供更灵活和可复用的逻辑代码。</li><li><strong>代码复用</strong>：随着应用规模的扩大和复杂度的增加，选项式API可能导致代码难以维护和理解。数据和逻辑被分散在多个选项中，很难一眼看出它们之间的关系。而组合式API通过将逻辑封装为自定义函数，可以更好地复用逻辑代码。</li><li><strong>类型推断</strong>：Vue 3的组合式API更适用于TypeScript等类型检查工具。使用组合式API，TypeScript可以更准确地推断和捕获类型信息，提供更好的代码补全和错误检测。</li></ol><p><strong>优势</strong>：</p><ol><li><strong>代码组织</strong>：组合式API可以更好地组织代码，将相关逻辑代码封装在函数中，按照功能和关注点进行组织。这使得代码更清晰、模块化，并且易于理解和维护。</li><li><strong>复用性</strong>：组合式API通过封装逻辑为可复用的函数，提高了代码的复用性。可以根据需要选择性地调用这些函数，并在多个组件之间共享它们。</li><li><strong>直观性</strong>：在Vue 3的组合式API中，生命周期钩子函数（如created、mounted、updated、destroyed等）被替代为更直观和一致的函数调用，这使得代码更易于理解和维护。</li></ol><p>总的来说，组合式API通过提供更好的代码组织、复用性和直观性，解决了选项式API在大型和复杂应用中可能遇到的问题。然而，这并不意味着选项式API已经完全被取代。在Vue 3中，对两种API都提供了支持，开发者可以根据项目的具体需求和自己的偏好来选择使用哪种API。对于简单的场景，使用选项式API可能更加简单方便；而对于需要强烈支持TypeScript或大量逻辑复用的场景，组合式API可能是更好的选择。</p><h4 id="Vue3中watch-和-watchEffect-的区别"><a href="#Vue3中watch-和-watchEffect-的区别" class="headerlink" title="Vue3中watch 和 watchEffect 的区别"></a>Vue3中watch 和 watchEffect 的区别</h4><p>在 Vue 3 中，<code>watch</code> 和 <code>watchEffect</code> 都是用于响应式地观察和响应 Vue 组件中的数据变化的方法，但它们之间有一些重要的区别。</p><p><strong>watch</strong></p><p><code>watch</code> 是 Vue 2.x 和 Vue 3 中都存在的一个功能，它用于侦听特定的数据源，并在其变化时执行回调函数。<code>watch</code> 需要明确指定要侦听的数据源和回调函数。</p><p><strong>特点：</strong></p><ol><li><strong>明确指定</strong>：你需要明确指定要侦听的数据源，以及当该数据源变化时要执行的回调函数。</li><li><strong>获取新旧值</strong>：在回调函数中，你可以获取到数据源变化前后的值（新值和旧值）。</li><li><strong>选项丰富</strong>：<code>watch</code> 提供了一些选项，如 <code>immediate</code>（是否在初始化时立即调用一次回调函数）和 <code>deep</code>（是否深度侦听对象内部值的变化）。</li></ol><p><strong>使用场景：</strong></p><ul><li>当你需要侦听某个特定的 prop 或 data 属性时。</li><li>当你需要在数据源变化时执行一些异步操作或开销较大的操作时。</li></ul><p><strong>watchEffect</strong></p><p><code>watchEffect</code> 是 Vue 3 中新增的一个功能，它用于自动追踪其回调函数中的响应式依赖，并在依赖变化时重新执行该函数。</p><p><strong>特点：</strong></p><ol><li><strong>自动追踪</strong>：<code>watchEffect</code> 会自动追踪其回调函数中所依赖的响应式数据。</li><li><strong>立即执行</strong>：默认情况下，<code>watchEffect</code> 在组件挂载后会立即执行一次回调函数，以捕获初始状态。</li><li><strong>无需明确指定依赖</strong>：与 <code>watch</code> 不同，你不需要明确指定要侦听哪些数据源，<code>watchEffect</code> 会自动帮你做这件事。</li></ol><p><strong>使用场景</strong>：</p><ul><li>当你需要自动追踪多个响应式依赖时。</li><li>当你需要在组件挂载后立即执行一些逻辑时（例如，获取初始数据）。</li></ul><p><strong>总结</strong></p><ul><li><code>watch</code> 适用于需要明确指定数据源和回调函数的情况，以及需要获取数据源变化前后值的情况。</li><li><code>watchEffect</code> 适用于自动追踪多个响应式依赖，并在依赖变化时重新执行回调函数的情况。它更加灵活和简洁，但可能不如 <code>watch</code> 那么精确。</li></ul><p>在选择使用 <code>watch</code> 还是 <code>watchEffect</code> 时，你应该根据你的具体需求和场景来决定。</p><h4 id="Vue3中render函数的作用"><a href="#Vue3中render函数的作用" class="headerlink" title="Vue3中render函数的作用"></a>Vue3中render函数的作用</h4><p>在 Vue 3 中，<code>render</code> 函数是一个高级特性，它允许你手动编写 JavaScript 来生成虚拟 DOM（Virtual DOM）节点，而不是使用模板语法。<code>render</code> 函数在 Vue 的运行时环境中扮演着将组件的逻辑转换为实际 DOM 结构的关键角色。</p><p><code>render</code> 函数接收一个名为 <code>createElement</code> 的函数作为参数，这个函数用于创建虚拟 DOM 节点。<code>createElement</code> 函数接受三个参数：</p><blockquote><ol><li><strong>标签名或组件对象</strong>：可以是原生 HTML 标签名（如 <code>&#39;div&#39;</code>、<code>&#39;span&#39;</code> 等），也可以是 Vue 组件对象。</li><li><strong>包含组件的 props/attributes 的数据对象</strong>：这个对象用于定义元素的属性、props、DOM 属性、类名、样式等。</li><li><strong>子虚拟节点数组</strong>：一个由 <code>createElement</code> 创建的虚拟节点数组，作为当前元素的子节点。</li></ol></blockquote><p><code>render</code> 函数通常用于以下场景：</p><blockquote><ol><li><strong>高级用法和自定义渲染</strong>：当你需要更细粒度的控制渲染逻辑时，可以使用 <code>render</code> 函数。例如，你可以动态地根据组件的状态和属性来渲染不同的 DOM 结构。</li><li><strong>与 JSX 或 TSX 配合使用</strong>：虽然 Vue 本身不直接支持 JSX（JavaScript XML），但你可以通过 Babel 插件（如 <code>@vue/babel-plugin-jsx</code>）将 JSX 转换为 Vue 的 <code>render</code> 函数。这样，你就可以在 Vue 组件中使用类似于 React 的 JSX 语法来编写渲染逻辑。</li><li><strong>渲染函数式组件</strong>：函数式组件（Functional Components）是那些没有状态（即没有响应式数据）和实例（即没有 <code>this</code> 上下文）的组件。这些组件只根据传入的 props 来渲染 DOM 结构，因此非常适合使用 <code>render</code> 函数来实现。</li></ol></blockquote><p>需要注意的是，尽管 <code>render</code> 函数提供了更大的灵活性，但在大多数情况下，使用 Vue 的模板语法已经足够满足需求。模板语法更加直观和易于理解，尤其是对于非专业前端开发者来说。因此，在不需要特殊渲染逻辑的情况下，建议使用模板语法来编写 Vue 组件。</p><h4 id="Vue3中的setup语法糖"><a href="#Vue3中的setup语法糖" class="headerlink" title="Vue3中的setup语法糖"></a>Vue3中的setup语法糖</h4><p>在 Vue 3 中，<code>setup</code> 函数是 Composition API 的入口点，它使得我们可以在组件中使用响应式数据、生命周期钩子、方法等，而不必依赖于传统的选项式 API（Options API）。然而，Vue 3 还引入了一种称为“语法糖”（Syntactic Sugar）的简化方式，以更简洁的方式使用 Composition API。</p><p>这种语法糖主要体现在两个方面：<code>&lt;script setup&gt;</code> 和 <code>ref</code>/<code>reactive</code> 的自动解构。</p><p><strong><code>&lt;script setup&gt;</code></strong></p><script setup> 是 Vue 3 单文件组件（SFC）中的一个新语法，允许你在 <script> 标签中使用 setup 函数，而无需显式地定义 setup 函数。这种语法会自动将 setup 函数的返回值暴露给模板。示例：```vue<template>    <button @click="increment"></button>  </template>    <script setup>  import { ref } from 'vue'    const count = ref(0)  const increment = () => {    count.value++  }  </script><pre><code>在这个示例中，我们使用了 `&lt;script setup&gt;` 语法，并在其中定义了响应式引用 `count` 和一个方法 `increment`。这些都被自动暴露给模板，使得我们可以在模板中直接使用它们。**`ref`/`reactive` 的自动解构**在 `&lt;script setup&gt;` 中，你还可以直接使用 `ref` 或 `reactive` 创建的响应式数据，而无需通过 `.value` 来访问它（在模板中除外）。这是因为 Vue 编译器会自动对 `ref` 进行解构。示例：```vue&lt;template&gt;    &lt;input v-model=&quot;message&quot; /&gt;    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;  &lt;/template&gt;    &lt;script setup&gt;  import &#123; ref &#125; from &#39;vue&#39;    const message = ref(&#39;&#39;)  &lt;/script&gt;</code></pre><p>在这个示例中，我们直接在 <code>&lt;script setup&gt;</code> 中定义了一个 <code>ref</code> 类型的响应式数据 <code>message</code>。在模板中，我们可以直接使用 <code>v-model=&quot;message&quot;</code> 而不是 <code>v-model=&quot;message.value&quot;</code>。在 <code>&lt;script setup&gt;</code> 的作用域内，我们可以直接通过 <code>message</code> 访问其值，但在模板中仍然需要使用 <code>message</code>（而不是 <code>message.value</code>）作为变量名。</p><p><strong>总结</strong></p><script setup> 和 ref/reactive 的自动解构是 Vue 3 中引入的两种语法糖，它们使得使用 Composition API 变得更加简洁和直观。这些特性允许我们更专注于组件的逻辑和功能，而不必花费太多精力在语法和结构上。#### Vue3中的ref、toRef、toRefs在 Vue 3 中，`ref`、`toRef` 和 `toRefs` 是与响应式引用（reactive references）紧密相关的 API，它们主要用于处理响应式数据。这些 API 允许你创建和管理响应式引用，以便在组件的模板和逻辑中使用。以下是这些 API 的简要说明：**1. `ref`**`ref` 函数用于创建一个响应式的引用（reference）。它接受一个初始值作为参数，并返回一个响应式的对象，该对象具有一个 `.value` 属性，用于访问或修改其值。```javascriptimport { ref } from 'vue';    const count = ref(0);    console.log(count.value); // 输出: 0    count.value++;  console.log(count.value); // 输出: 1```在模板中，你可以直接使用 `count`（不需要 `.value`），Vue 会自动为你处理。**2. `toRef`**`toRef` 函数用于为一个响应式对象的属性创建一个引用。与 `ref` 不同，`toRef` 创建的引用与原始对象保持连接，当原始对象的属性值发生变化时，引用也会更新。```javascriptimport { reactive, toRef } from 'vue';    const state = reactive({    count: 0  });    const countRef = toRef(state, 'count');    console.log(countRef.value); // 输出: 0    state.count++;  console.log(countRef.value); // 输出: 1```注意，如果你尝试通过 `countRef.value` 修改值，它只会影响 `state.count`，而不是创建一个新的响应式引用。**3. `toRefs`**`toRefs` 函数用于将一个响应式对象的所有属性转换为单独的响应式引用，并将它们收集到一个普通对象中。这在你需要将多个响应式属性传递给组件的 props 或在模板中大量使用它们时非常有用。```javascriptimport { reactive, toRefs } from 'vue';    const state = reactive({    count: 0,    name: 'Vue'  });    const refs = toRefs(state);    console.log(refs.count.value); // 输出: 0  console.log(refs.name.value); // 输出: 'Vue'    state.count++;  console.log(refs.count.value); // 输出: 1```在模板中，你可以通过解构（destructuring）`toRefs` 的结果来直接使用这些引用，而无需每次都写 `.value`。```vue<template>    <div>      <p></p> <!-- 直接使用 count，而不是 count.value -->      <p></p> <!-- 直接使用 name，而不是 name.value -->    </div>  </template>    <script>  import { reactive, toRefs } from 'vue';    export default {    setup() {      const state = reactive({        count: 0,        name: 'Vue'      });        return {        ...toRefs(state)      };    }  }  </script><pre><code>#### Vue3中的 reactive、 shallowReactive 函数在 Vue 3 的 Composition API 中，`reactive` 和 `shallowReactive` 是两个用于创建响应式对象的函数。它们之间的主要区别在于它们如何处理嵌套对象的响应性。**reactive**`reactive` 函数用于创建一个响应式对象，该对象的所有嵌套属性（包括子对象）都是响应式的。当这些属性的值发生变化时，视图将自动更新。```javascriptimport &#123; reactive &#125; from &#39;vue&#39;;    const state = reactive(&#123;    count: 0,    nested: &#123;      name: &#39;Vue&#39;,      version: 3    &#125;  &#125;);    // 改变顶级属性的值  state.count++;    // 改变嵌套对象的属性  state.nested.name = &#39;Vue.js&#39;;    // 这两个更改都会触发视图的更新</code></pre><p>在上面的例子中，<code>state</code> 是一个响应式对象，它的 <code>count</code> 属性和 <code>nested</code> 对象（包括其 <code>name</code> 和 <code>version</code> 属性）都是响应式的。</p><p><strong>shallowReactive</strong></p><p><code>shallowReactive</code> 函数也用于创建一个响应式对象，但与 <code>reactive</code> 不同的是，它只使对象的顶层属性变为响应式。对象的嵌套属性（即子对象）不会变为响应式，除非它们本身也是响应式的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> shallowReactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    nested<span class="token punctuation">:</span> <span class="token punctuation">{</span>      name<span class="token punctuation">:</span> <span class="token string">'Vue'</span><span class="token punctuation">,</span>      version<span class="token punctuation">:</span> <span class="token number">3</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 改变顶级属性的值  </span>state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 改变嵌套对象的属性（这里不会触发视图的更新，因为 nested 不是响应式的）  </span>state<span class="token punctuation">.</span>nested<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Vue.js'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 只有 count 的更改会触发视图的更新</span></code></pre><p>在上面的例子中，<code>state</code> 是一个响应式对象，但只有它的 <code>count</code> 属性是响应式的。<code>nested</code> 对象和其内部的 <code>name</code>、<code>version</code> 属性都不是响应式的。因此，只有对 <code>count</code> 的更改会触发视图的更新。</p><p><strong>何时使用 shallowReactive？</strong></p><p>在某些情况下，你可能不希望 Vue 追踪对象内部的所有嵌套属性变化，因为这可能会带来不必要的性能开销。例如，当你有一个大型对象，并且你只对它的顶层属性感兴趣时，<code>shallowReactive</code> 可能是一个更好的选择。但是，请注意，如果你试图修改嵌套对象的属性并期望视图更新，那么你需要确保这些嵌套对象也是响应式的，或者使用其他方法（如 Vuex）来管理你的状态。</p><h4 id="Vue3中setup语法下怎么设置name属性？"><a href="#Vue3中setup语法下怎么设置name属性？" class="headerlink" title="Vue3中setup语法下怎么设置name属性？"></a>Vue3中setup语法下怎么设置name属性？</h4><p>在 Vue 3 中，由于 <code>setup()</code> 函数是 Composition API 的一部分，并且它不直接绑定到组件实例上，因此你不能直接在 <code>setup()</code> 函数中设置组件的 <code>name</code> 属性，如同你在 Vue 2 的 <code>options</code> API 中所做的那样。</p><p>然而，<code>name</code> 属性主要用于开发工具中的调试和警告，它并不是组件功能所必需的。尽管如此，如果你确实需要在 Vue 3 中为组件设置一个 <code>name</code>，你仍然可以在组件的 <code>options</code> 部分（如果你同时使用 Composition API 和 Options API）或在 Vue 文件的 <code>&lt;script&gt;</code> 标签外（使用单文件组件）进行设置。</p><p><strong>使用 Options API 和 Composition API 混合</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'MyComponentName'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 设置组件名  </span>  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// ... 其他逻辑  </span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        count      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// ... 其他选项，如 methods、computed 等  </span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>仅使用 Composition API</strong></p><p>如果你完全使用 Composition API，并且希望保持单文件组件的整洁，你可以在 <code>&lt;script&gt;</code> 标签的外部设置 <code>name</code> 属性：</p><pre class=" language-vue"><code class="language-vue"><template>    <!-- 组件模板 -->  </template>    <script>  import { ref } from 'vue';    export default {    setup() {      const count = ref(0);      // ... 其他逻辑      return {        count      };    },    // 注意：这里不设置 name，因为我们在外部设置  };  </script>    <script setup>  // 这个 script setup 是 Vue 3 的单文件组件语法糖  // 由于它不支持直接设置 name，我们通常在外部设置  </script>    <style scoped>  /* 组件样式 */  </style>    <!-- 在单文件组件的外部设置 name -->  <script>  export default {    name: 'MyComponentName'  }  </script></code></pre><p>但请注意，在 <code>&lt;script setup&gt;</code> 外部再包裹一个 <code>&lt;script&gt;</code> 来设置 <code>name</code> 并不是官方推荐的做法，因为这可能会引入一些混淆。在实际开发中，大多数开发者会选择在 <code>export default</code> 对象中直接设置 <code>name</code>，即使他们主要使用 Composition API。</p><p>如果你只使用 <code>&lt;script setup&gt;</code> 并且确实需要 <code>name</code>（尽管通常不需要），你可能需要依赖于外部工具或配置来设置它，或者接受默认的行为（即不设置 <code>name</code>）。</p><h4 id="Vue3中的自定义指令"><a href="#Vue3中的自定义指令" class="headerlink" title="Vue3中的自定义指令"></a>Vue3中的自定义指令</h4><p>在 Vue 3 中，自定义指令是一种强大而灵活的功能，允许你创建可复用的 DOM 行为。与 Vue 2 类似，Vue 3 提供了自定义指令的 API，但有一些细微的差别。</p><p>在 Vue 3 中，你可以通过 <code>app.directive()</code> 方法在 Vue 应用实例上注册全局自定义指令，或者在组件的 <code>directives</code> 选项上注册局部自定义指令。</p><p>自定义指令接收两个参数：指令名和指令定义对象。指令定义对象可以包含以下几个钩子函数（都是可选的）：</p><blockquote><ul><li><code>bind(el, binding, vnode, prevVnode)</code>: 当被绑定的元素挂载到 DOM 中时……调用。只调用一次。</li><li><code>inserted(el, binding, vnode, prevVnode)</code>: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li><li><code>update(el, binding, vnode, prevVnode)</code>: 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</li><li><code>componentUpdated(el, binding, vnode, prevVnode)</code>: 指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li><code>unmount(el, binding, vnode, prevVnode)</code>: 指令与元素解绑（只调用一次）。</li></ul></blockquote><p>下面是一个全局自定义指令的示例，它用于将元素的颜色设置为指令的值：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    app<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-color'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当被绑定的元素挂载到 DOM 中时……  </span>  <span class="token function">bind</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// el 是指令所绑定的元素  </span>    <span class="token comment" spellcheck="true">// binding 是一个对象，包含以下属性：  </span>    <span class="token comment" spellcheck="true">//   - name: 指令名，不包括 v- 前缀。  </span>    <span class="token comment" spellcheck="true">//   - value: 指令的绑定值，例如：v-my-color="123" 中，绑定值为 123。  </span>    <span class="token comment" spellcheck="true">//   - oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。  </span>    <span class="token comment" spellcheck="true">//   - expression: 字符串形式的指令表达式。例如 v-my-color="1 + 1" 中，表达式为 "1 + 1"。  </span>    <span class="token comment" spellcheck="true">//   - arg: 传给指令的参数，可选。例如 v-my-color:red 中，参数为 "red"。  </span>    <span class="token comment" spellcheck="true">//   - modifiers: 一个包含修饰符的对象。例如：v-my-color.foo.bar 中，修饰符对象为 { foo: true, bar: true }。  </span>    <span class="token comment" spellcheck="true">// vnode 是 Vue 编译生成的虚拟节点  </span>    el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> binding<span class="token punctuation">.</span>value    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// ... 其他钩子函数  </span><span class="token punctuation">}</span><span class="token punctuation">)</span>    app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span></code></pre><p>然后你可以在模板中这样使用自定义指令：</p><pre class=" language-html"><code class="language-html">html复制代码<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-my-color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>red<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello World!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>这将会把文本 “Hello World!” 的颜色设置为红色。注意，我们在 <code>v-my-color</code> 中使用了单引号，这是因为我们实际上是在传递一个字符串字面量给指令。如果 <code>binding.value</code> 是一个变量或表达式，你可以直接写 <code>v-my-color=&quot;myColorVariable&quot;</code>。</p><h4 id="pinia：Vue3中的状态管理库"><a href="#pinia：Vue3中的状态管理库" class="headerlink" title="pinia：Vue3中的状态管理库"></a>pinia：Vue3中的状态管理库</h4><p>Pinia是一个专为Vue 3设计的状态管理库，它基于Vue 3的Composition API，并以Vuex的下一代构想为基础，设计了新的Vue存储状态管理库。Pinia的主要特点和优势包括：</p><blockquote><ol><li><strong>简洁和轻量级</strong>：Pinia的设计理念和API都非常直观和简洁，使得开发者可以快速上手。它的大小只有约1KB，是一个轻量级的状态管理工具。</li><li><strong>基于响应式系统</strong>：Pinia的状态管理是基于Vue 3的响应式系统的，这意味着当状态发生改变时，相关的组件会自动更新。</li><li><strong>模块化设计</strong>：Pinia支持多个store，这使得你可以将应用程序的状态按照功能或模块进行划分，提高了代码的可维护性和可读性。</li><li><strong>支持同步和异步操作</strong>：Pinia中的action支持同步和异步操作，这使得你可以更方便地处理异步逻辑，比如从服务器获取数据等。</li><li><strong>支持服务端渲染（SSR）</strong>：Pinia可以很好地与Vue的服务端渲染功能配合使用，使得你可以在服务器端就预先渲染出应用程序的状态。</li><li><strong>支持Vue Devtools</strong>：Pinia与Vue Devtools完美集成，使得你可以更方便地调试和查看应用程序的状态。</li></ol></blockquote><p>在Pinia中，核心概念是Store，它类似于Vuex中的Store，但是更加轻便和灵活。在Store中，你可以使用Vue 3的响应式系统来定义状态，并通过actions来定义修改状态的方法。</p><p>总的来说，Pinia是一个强大而灵活的状态管理库，它可以帮助你更好地管理Vue 3应用程序的状态，提高代码的可维护性和可读性。如果你正在使用Vue 3开发应用程序，那么Pinia是一个值得考虑的状态管理库。</p><h4 id="Vue3中怎么封装自定义插件并使用？"><a href="#Vue3中怎么封装自定义插件并使用？" class="headerlink" title="Vue3中怎么封装自定义插件并使用？"></a>Vue3中怎么封装自定义插件并使用？</h4><p>在Vue 3中，你可以通过创建一个包含<code>install</code>方法的对象来封装自定义插件，并使用<code>app.use()</code>方法来安装和使用这个插件。以下是一个简单的步骤说明和示例：</p><p><strong>步骤</strong></p><ol><li><p>定义插件</p><p>：</p><ul><li>创建一个对象，该对象至少应该有一个<code>install</code>方法。</li><li><code>install</code>方法接收两个参数：<code>app</code>（Vue应用实例）和<code>options</code>（传递给插件的选项）。</li></ul></li><li><p>编写插件功能</p><p>：</p><ul><li>在<code>install</code>方法中，你可以添加全局方法或属性、添加全局资源、添加组件选项等等。</li></ul></li><li><p>使用插件</p><p>：</p><ul><li>在你的Vue应用中，使用<code>app.use(你的插件)</code>来安装插件。</li></ul></li></ol><p><strong>示例</strong></p><p>假设我们要创建一个简单的全局提示插件：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// my-plugin.js  </span><span class="token keyword">const</span> MyPlugin <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// install 方法是插件的核心  </span>  <span class="token function">install</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 确保插件只被安装一次  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>app<span class="token punctuation">.</span>_installedPlugins<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 添加全局方法  </span>    app<span class="token punctuation">.</span>config<span class="token punctuation">.</span>globalProperties<span class="token punctuation">.</span>$alert <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 添加全局指令（如果需要）  </span>    app<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 指令定义  </span>      <span class="token function">mounted</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 指令挂载时的逻辑  </span>        el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'这是一个自定义指令'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 你可以在这里使用传入的options进行其他操作  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>someOption<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用了某个选项:'</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>someOption<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 添加到已安装插件列表  </span>    app<span class="token punctuation">.</span>_installedPlugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在你的main.js或main.ts中使用插件  </span><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>  <span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token punctuation">;</span>  <span class="token keyword">import</span> MyPlugin <span class="token keyword">from</span> <span class="token string">'./my-plugin'</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span>  app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">,</span> <span class="token punctuation">{</span> someOption<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传入选项（如果需要）  </span>app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面的示例中，我们创建了一个名为<code>MyPlugin</code>的插件，它添加了一个全局方法<code>$alert</code>和一个全局指令<code>v-my-directive</code>。然后，在<code>main.js</code>或<code>main.ts</code>中，我们导入了这个插件并使用<code>app.use()</code>方法进行了安装。</p><p>注意：在Vue 3中，Vue实例不再暴露<code>Vue.prototype</code>，因此我们使用<code>app.config.globalProperties</code>来添加全局方法或属性。同时，<code>app._installedPlugins</code>是一个内部属性，用于追踪已安装的插件，以确保插件只被安装一次。虽然这不是必需的，但在某些情况下可能很有用。</p><h4 id="Vue3中createApp-App-创建应用实例过程中都发生了什么？"><a href="#Vue3中createApp-App-创建应用实例过程中都发生了什么？" class="headerlink" title="Vue3中createApp(App)创建应用实例过程中都发生了什么？"></a>Vue3中createApp(App)创建应用实例过程中都发生了什么？</h4><p>在Vue 3中，<code>createApp(App)</code>方法用于创建一个新的Vue应用实例。当你调用这个方法时，Vue内部会执行一系列的操作来设置和初始化这个应用实例。以下是<code>createApp(App)</code>创建应用实例过程中大致发生的一些步骤：</p><blockquote><ol><li><strong>参数处理</strong>：<code>createApp</code>方法接收一个根组件对象（在你的例子中是<code>App</code>）作为参数。这个对象通常是一个Vue组件，包含了模板、数据、方法等。</li><li><strong>创建应用实例</strong>：Vue内部会基于提供的根组件对象创建一个新的应用实例。这个实例包含了Vue应用所需的所有核心功能和状态。</li><li><strong>初始化响应式系统</strong>：Vue的响应式系统是其核心特性之一，允许数据和DOM之间保持同步。在创建应用实例时，Vue会初始化响应式系统，将根组件的数据转换为响应式数据。</li><li><strong>设置渲染上下文</strong>：Vue需要知道如何将组件渲染到DOM中。在创建应用实例时，Vue会设置渲染上下文，包括挂载点（即DOM元素）和渲染器（用于将虚拟DOM转换为真实DOM）。</li><li><strong>注册组件和指令</strong>：如果你在应用实例中注册了全局组件或指令，Vue会在此时将它们添加到全局注册表中。这样，你就可以在应用中的任何地方使用这些组件和指令了。</li><li><strong>启动挂载过程</strong>：最后，当你调用<code>app.mount(&#39;#app&#39;)</code>时（其中<code>#app</code>是挂载点的选择器），Vue会开始挂载过程。这个过程包括创建组件的虚拟DOM树、比较虚拟DOM和真实DOM的差异、以及将差异应用到真实DOM上。</li></ol></blockquote><p>需要注意的是，这个过程是一个简化的概述，Vue内部的实际实现可能会更加复杂和详细。此外，Vue 3还引入了许多新特性和优化，如Composition API、Teleport、Suspense等，这些特性在创建和挂载应用实例时也可能会有所体现。</p><p>如果你对Vue 3的源码感兴趣，可以查阅Vue的官方文档或源码来了解更多关于<code>createApp</code>方法和应用实例创建过程的细节。</p><h4 id="Vue3中有哪些新的组件？"><a href="#Vue3中有哪些新的组件？" class="headerlink" title="Vue3中有哪些新的组件？"></a>Vue3中有哪些新的组件？</h4><p>在Vue 3中，引入了一些新的内置组件，这些组件为开发者提供了更多的灵活性和功能。以下是Vue 3中的一些新组件：</p><ol><li><p>Teleport</p><p>：</p><ul><li>Teleport 是一种能够将组件的 HTML 结构“传送”到 DOM 树中指定位置的技术。这在处理如模态框、弹出窗口等需要脱离正常文档流的组件时非常有用。</li><li>你可以使用 <code>Teleport</code> 组件来指定子组件应该被渲染到哪个 DOM 节点中，而不是在其父组件的模板中。</li></ul></li><li><p>Suspense</p><p>：</p><ul><li>Suspense 组件用于处理异步组件的加载状态。当组件在等待异步组件加载时，你可以指定一个 fallback 组件来显示加载中的状态。</li><li>这对于在加载异步数据或组件时提供用户反馈非常有用，尤其是在需要保持 UI 流畅性的情况下。</li></ul></li><li><p>Fragment</p><p>：</p><ul><li>在 Vue 2 中，组件的根节点只能有一个。但在 Vue 3 中，你可以使用 <code>&lt;Fragment&gt;</code> 或简单地不使用根节点来渲染多个根节点。</li><li>这使得组件的模板更加灵活，特别是在需要将多个元素作为根元素渲染到 DOM 中的情况下。</li></ul></li><li><p>Transition 和 TransitionGroup</p><p>：</p><ul><li>这些组件在 Vue 2 中已经存在，但在 Vue 3 中得到了改进。它们用于在元素或组件进入、离开或列表更新时应用过渡效果。</li><li>通过使用这些组件，你可以更轻松地创建复杂的动画和过渡效果。</li></ul></li></ol><p>需要注意的是，虽然这些组件是 Vue 3 的新特性，但它们并不是必须使用的。你可以根据自己的项目需求来选择是否使用这些组件。同时，Vue 社区也提供了许多第三方组件库和插件，这些库和插件也可以为你的项目提供额外的功能和灵活性。</p><h4 id="Vue3中Composition-API-和-React-Hook的区别"><a href="#Vue3中Composition-API-和-React-Hook的区别" class="headerlink" title="Vue3中Composition API 和 React Hook的区别"></a>Vue3中Composition API 和 React Hook的区别</h4><p>Vue3中的Composition API和React Hook在多个方面存在区别，这些区别主要体现在语法、概念、数据响应性等方面。</p><ol><li>语法和概念：</li></ol><ul><li>Vue 3的Composition API使用函数方式组织逻辑，引入了如<code>ref</code>、<code>reactive</code>、<code>computed</code>等新概念。这些函数和概念允许开发者将逻辑和状态管理逻辑分离，使代码更加清晰和可维护。</li><li>React Hooks则使用函数调用，主要包括<code>useState</code>、<code>useEffect</code>、<code>useContext</code>等。Hooks允许你在不编写class的情况下使用state以及其他的React特性，从而在不改变组件结构的情况下复用状态逻辑。</li></ul><ol><li>数据响应性：</li></ol><ul><li>Vue 3使用了响应性系统来管理数据的变化。通过使用<code>reactive</code>函数，你可以创建响应式对象，其属性会随着对象属性的改变而自动更新。这在状态管理和数据传递上非常有用。</li><li>React则没有内置的响应性系统。在React中，你需要使用<code>useState</code>来管理组件状态，并使用<code>useEffect</code>来处理副作用。然而，这些工具并不提供像Vue那样的自动数据响应性。</li></ul><ol><li>组件逻辑组织：</li></ol><ul><li>使用Composition API，你可以将组件的逻辑按照功能进行组织，而不是按照选项进行组织。这提高了代码的可读性和可维护性。</li><li>在React中，Hooks允许你在函数组件中“钩入”React state及生命周期等特性。这意味着你可以在无需编写class组件的情况下使用React的许多高级功能。</li></ul><p>总的来说，Vue3的Composition API和React Hook都是各自框架中用于提高代码复用性和组织性的重要工具。然而，它们在语法、概念和数据响应性等方面存在差异，这些差异可能会影响开发者在不同框架下的编码习惯和策略。在选择使用哪种技术时，需要根据具体项目的需求和个人偏好来做出决策。</p><h3 id="Vue相关"><a href="#Vue相关" class="headerlink" title="Vue相关"></a>Vue相关</h3><h4 id="vue-内置指令"><a href="#vue-内置指令" class="headerlink" title="vue 内置指令"></a>vue 内置指令</h4><p><img src="/../images/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/vue-command.jpg" alt="vue内置指令"></p><h4 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h4><p><code>v-if</code> 和 <code>v-show</code> 都是 Vue 中的条件渲染指令，用于根据条件来控制元素的显示和隐藏。它们之间的区别如下：</p><blockquote><ol><li>编译时机：<code>v-if</code> 是在编译阶段进行条件判断，如果条件为假，那么该元素及其子元素将不会被编译和渲染到 DOM 中。而 <code>v-show</code> 是在编译阶段将元素渲染到 DOM 中，然后通过 CSS 的 <code>display</code> 属性控制元素的显示和隐藏。</li><li>切换消耗：由于 <code>v-if</code> 是在编译阶段进行条件判断，当条件发生变化时，会触发元素的创建或销毁，因此切换时的消耗较大。而 <code>v-show</code> 只是通过修改 CSS 的 <code>display</code> 属性来切换元素的可见性，所以切换时的消耗较小。</li><li>初始渲染开销：由于 <code>v-if</code> 是在编译阶段进行条件判断，当条件为假时，元素及其子元素不会被编译和渲染，所以初始渲染的开销较小。而 <code>v-show</code> 在初始渲染时，会将元素及其子元素都渲染到 DOM 中，然后通过 CSS 控制其可见性，所以初始渲染的开销较大。</li><li>条件切换频率：如果需要频繁切换元素的显示和隐藏，建议使用 <code>v-show</code>，因为它只是通过修改 CSS 属性来切换，性能更好。如果切换频率较低，可以使用 <code>v-if</code>，因为它在条件为假时会销毁元素，可以减少页面中的 DOM 元素数量。</li></ol></blockquote><p>​    <code>v-if</code> 适用于条件切换频率较低的情况，可以节省初始渲染开销和内存占用；<code>v-show</code> 适用于频繁切换元素的可见性，可以减少切换消耗。根据具体的需求和场景选择合适的条件渲染指令。</p><h4 id="v-if-和-v-for-哪个优先级更高"><a href="#v-if-和-v-for-哪个优先级更高" class="headerlink" title="v-if 和 v-for 哪个优先级更高"></a>v-if 和 v-for 哪个优先级更高</h4><p>​    在 Vue 中，<code>v-for</code> 指令的优先级高于 <code>v-if</code> 指令。这意味着当一个元素同时使用了 <code>v-if</code> 和 <code>v-for</code>，<code>v-for</code> 将首先被解析和执行，然后在每个迭代的元素上进行 <code>v-if</code> 的条件判断。</p><p>​    具体来说，当使用 <code>v-if</code> 和 <code>v-for</code> 同时存在于同一个元素上时，Vue 的编译器会先处理 <code>v-for</code>，根据数据集合生成对应的元素列表。然后，在每个生成的元素上，会再依次应用 <code>v-if</code> 的条件判断。这意味着，如果 <code>v-if</code> 的条件为假，对应的元素将不会被渲染到最终的 DOM 中。</p><p>​    <code>v-for</code> 会先根据 <code>items</code> 数据集合生成对应的元素列表，然后在每个元素上应用 <code>v-if</code> 的条件判断。只有当 <code>item.visible</code> 的值为真时，对应的元素才会被渲染到最终的 DOM 中。</p><p>​    需要注意的是，在某些特定情况下，使用 <code>v-if</code> 和 <code>v-for</code> 同时存在可能会导致性能问题，因为每次迭代都需要进行条件判断。在这种情况下，可以考虑使用计算属性或过滤器来预先筛选数据集合，以减少渲染的元素数量，从而提升性能。</p><h4 id="slot（插槽）的作用"><a href="#slot（插槽）的作用" class="headerlink" title="slot（插槽）的作用"></a>slot（插槽）的作用</h4><p>​    插槽（Slot）是 Vue 中一种用于扩展组件内容的机制。通过插槽，你可以在组件的模板中预留出一些位置，然后在使用该组件时，将内容插入到这些位置上。</p><p>插槽的作用主要有以下几个方面：</p><blockquote><ol><li>内容分发：插槽允许组件的使用者向组件中传递内容，并在组件内部进行渲染。使用插槽可以将组件设计得更加灵活，使得组件可以接受不同的内容进行渲染，从而满足不同的需求。</li><li>组件组合：通过插槽，你可以将多个组件组合在一起，形成更复杂的组合组件。插槽使得组件之间的组合变得简单，你可以将多个组件的内容组合在一起，并且可以在父组件中决定如何组合它们。</li><li>默认内容：插槽可以设置默认内容，当使用组件时没有提供具体内容时，将会使用默认的插槽内容进行渲染。这样可以确保即使没有传入内容，组件仍然可以正常显示一些默认的内容。</li></ol></blockquote><p>​    在 Vue 中，有两种类型的插槽：具名插槽和默认插槽。具名插槽允许你为插槽指定名称，并在组件中根据名称进行内容分发。默认插槽是没有名称的，当组件中没有具名插槽时，会将内容分发到默认插槽中。</p><p>​    通过使用插槽，你可以将组件的结构和样式与具体的内容进行解耦，提高了组件的可复用性和灵活性。它是 Vue 中非常强大和常用的特性之一。</p><h4 id="关于-Vue-的单向数据流"><a href="#关于-Vue-的单向数据流" class="headerlink" title="关于 Vue 的单向数据流"></a>关于 Vue 的单向数据流</h4><p>​    数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><blockquote><p>注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</p></blockquote><p>​    如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改。</p><h4 id="computed-和-watch-的区别和运用的场景"><a href="#computed-和-watch-的区别和运用的场景" class="headerlink" title="computed 和 watch 的区别和运用的场景"></a>computed 和 watch 的区别和运用的场景</h4><p>​    computed 是<a href="https://juejin.cn/post/6956407362085191717">计算属性</a>，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。</p><p>​    <a href="https://juejin.cn/post/6954925963226382367">watch</a>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p><p>​    计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑计算属性原理详解 </p><h4 id="vue-中使用了哪些设计模式"><a href="#vue-中使用了哪些设计模式" class="headerlink" title="vue 中使用了哪些设计模式"></a>vue 中使用了哪些设计模式</h4><blockquote><p>1.工厂模式 - 传入参数即可创建实例</p><p>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p><p>2.单例模式 - 整个程序有且仅有一个实例</p><p>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉</p><p>3.发布-订阅模式 (vue 事件机制)</p><p>4.观察者模式 (响应式数据原理)</p><p>5.装饰模式: (@装饰器的用法)</p><p>6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="Vue-模板编译原理"><a href="#Vue-模板编译原理" class="headerlink" title="Vue 模板编译原理"></a>Vue 模板编译原理</h4><p>Vue 的模板编译原理主要包括以下步骤：</p><blockquote><ol><li>解析：Vue 的模板编译器将模板字符串解析为抽象语法树（AST）。AST 是一个树状结构，表示了模板中的各个节点和它们之间的关系。</li><li>优化：在解析完成后，编译器会对生成的 AST 进行优化。这个优化过程包括静态节点标记、静态根节点提升和事件侦听器的缓存等。这些优化可以提高渲染性能和减少运行时的开销。</li><li>代码生成：在优化完成后，编译器会根据 AST 生成渲染函数。渲染函数是一个 JavaScript 函数，它接收数据作为参数，返回一个虚拟 DOM 树。渲染函数可以将模板中的数据和逻辑转换为实际的 DOM 操作。</li><li>组件化编译：如果模板中包含组件，编译器会递归地对组件进行编译。这样可以将组件的模板编译为渲染函数，并生成组件的渲染逻辑。</li></ol></blockquote><p>​    在运行时，Vue 实例会通过编译后的渲染函数生成虚拟 DOM，并将其与实际的 DOM 进行比对，只更新需要改变的部分，以提高性能。</p><p>​    Vue 的模板编译原理将模板字符串解析为 AST，经过优化后生成渲染函数，然后在运行时使用渲染函数生成虚拟 DOM，并进行差异比对来更新视图。这种编译的过程使得 Vue 具有高效的渲染性能和灵活的组件化开发能力。</p><h4 id="Vue-的性能优化"><a href="#Vue-的性能优化" class="headerlink" title="Vue 的性能优化"></a>Vue 的性能优化</h4><p>Vue 的性能优化可以从以下几个方面考虑：</p><blockquote><ol><li>减少不必要的重新渲染：Vue 使用响应式系统来跟踪数据的变化并更新视图。为了减少不必要的重新渲染，可以使用合理的计算属性和侦听器，避免不必要的计算和更新。另外，使用 v-if 和 v-show 来条件渲染元素，只渲染当前需要显示的部分。</li><li>列表渲染优化：在使用 v-for 渲染列表时，使用唯一的 key 属性来提高性能。Vue 使用 key 来跟踪每个节点的身份，以便在更新过程中进行重用和重新排序，而不是完全重新创建和销毁 DOM 节点。</li><li>懒加载和异步组件：对于大型的页面或组件，可以使用懒加载和异步组件来延迟加载和渲染。这可以加快初始加载时间并减少首屏渲染的工作量。</li><li>使用 v-if 和 v-for 的选择：在需要根据条件动态渲染的元素上使用 v-if，而不是在列表上使用 v-for。因为 v-if 在条件不满足时会完全销毁和重建元素，而 v-for 只是在数据发生变化时更新元素。</li><li>使用虚拟列表或无限滚动：当需要处理大量数据列表时，可以使用虚拟列表或无限滚动的技术来提高性能。这样可以减少一次性渲染的节点数量，只渲染可见部分，从而减少内存占用和渲染时间。</li><li>合理使用异步更新：Vue 提供了 nextTick 方法和 $nextTick 实例方法来在下次 DOM 更新周期之后执行回调。合理使用异步更新可以将多个更新合并成一次，减少不必要的计算和渲染。</li><li>基于路由的代码分割：通过合理的路由配置和动态导入，将页面的代码拆分成更小的块，按需加载和渲染，提高初始加载速度和页面切换的响应性。</li><li>合理使用缓存：对于一些计算开销较大的结果或静态数据，可以使用缓存来避免重复计算或请求。例如，使用计算属性的缓存选项或使用工具库进行数据缓存。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器相关</title>
      <link href="/2023/05/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/05/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h3><h4 id="Chrome-架构：仅仅打开了-1-个页面，为什么有-4-个进程"><a href="#Chrome-架构：仅仅打开了-1-个页面，为什么有-4-个进程" class="headerlink" title="Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程"></a>Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程</h4><blockquote><p><strong>线程和进程区别</strong>：多线程可以并行处理任务，线程不能单独存在，它是由进程来启动和管理的。一个进程是一个程序的运行实例。</p><p><strong>线程和进程的关系</strong>：1、进程中任意一线程执行出错，都会导致整个进程的崩溃。2、线程之间共享进程中的数据。3、当一个进程关闭后，操作系统会回收进程所占用的内存。4、进程之间的内容相互隔离。</p><p><strong>单进程 浏览器</strong>：1、不稳定。单进程中的插件、渲染线程崩溃导致整个浏览器崩溃。2、不流畅。脚本（死循环）或插件会使浏览器卡顿。3、不安全。插件和脚本可以获取到操作系统任意资源。</p><p><strong>多进程浏览器</strong>：1、解决不稳定。进程相互隔离，一个页面或者插件崩溃时，影响仅仅时当前插件或者页面，不会影响到其他页面。2、解决不流畅。脚本阻塞当前页面渲染进程，不会影响到其他页面。3、解决不安全。采用多进程架构使用沙箱。沙箱看成时操作系统给进程上来一把锁，沙箱的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据。</p><p><strong>多进程架构</strong>：分为 浏览器进程、渲染进程、GPU 进程、网络进程、插件进程。</p><p><strong>缺点</strong>：1、资源占用高。2、体系架构复杂。</p><p><strong>面向服务架构</strong>：把原来的各种模块重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过 IPC 通讯，使得系统更内聚、松耦合、易维护和拓展。</p></blockquote><h4 id="TCP-协议：如何保证页面文件能被完整送达浏览器"><a href="#TCP-协议：如何保证页面文件能被完整送达浏览器" class="headerlink" title="TCP 协议：如何保证页面文件能被完整送达浏览器"></a>TCP 协议：如何保证页面文件能被完整送达浏览器</h4><blockquote><ul><li>IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息；</li><li>UDP 头中除了目的端口，还有源端口号等信息；</li><li>IP 负责把数据包送达目的主机；</li><li>UDP 负责把数据包送达具体应用；</li><li>对于错误的数据包，UDP 不提供重发机制，只是丢弃当前的包，不能保证数据的可靠性，但是传输速度非常块；</li><li>TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接；</li></ul></blockquote><h4 id="HTTP-请求流程：为什么很多站点第二次打开速度会很快"><a href="#HTTP-请求流程：为什么很多站点第二次打开速度会很快" class="headerlink" title="HTTP 请求流程：为什么很多站点第二次打开速度会很快"></a>HTTP 请求流程：为什么很多站点第二次打开速度会很快</h4><blockquote><ul><li>浏览器中的 HTTP 请求从发起到结束一共经历如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接；</li><li>构建请求。浏览器构建请求行，构建好后，准备发起网络请求；</li><li>查找缓存。在真正发起请求前浏览器会查询缓存中是否有请求资源副本，有则拦截请求，返回资源副本，否则进入网络请求；</li><li>准备 IP 地址和端口。HTTP 网络请求需要和服务器建立 TCP 连接，而建立 TCP 连接需要准备 IP 地址和端口号，浏览器需要请求 DNS 返回域名对应的 IP，同时会缓存域名解析结果，供下次查询使用；</li><li>等待 TCP 队列。Chrome 机制，同一个域名同时最多只能建立 6 个 TCP 连接；</li><li>建立 TCP 连接。TCP 通过“三次握手”建立连接，传输数据，“四次挥手”断开连接；</li><li>发送 HTTP 请求。建立 TCP 连接后，浏览器就可以和服务器进行 HTTP 数据传输了，首先会向服务器发送请求行，然后以请求头形式发送一些其他信息，如果是 POST 请求还会发送请求体；</li><li>服务器处理请求。首先服务器会返回响应行，随后，服务器向浏览器发送响应头和响应体。通常服务器返回数据，就要关闭 TCP 连接，如果请求头或者响应头有 Connection:keep-alive TCP 保持打开状态；</li></ul></blockquote><h4 id="导航流程：从输入-URL-到页面展示这中间发生了什么"><a href="#导航流程：从输入-URL-到页面展示这中间发生了什么" class="headerlink" title="导航流程：从输入 URL 到页面展示这中间发生了什么"></a>导航流程：从输入 URL 到页面展示这中间发生了什么</h4><blockquote><ul><li><p>用户输入 URL 并回车</p></li><li><p>浏览器进程检查 URL，组装协议，构成完整 URL</p></li><li><p>浏览器进程通过进程通信（IPC）把 URL 请求发送给网络进程</p></li><li><p>网络进程接收到 URL 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</p></li><li><p>如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下：</p></li><li><ul><li>进行 DNS 解析，获取服务器 IP 地址，端口</li><li>利用 IP 地址和服务器建立 tcp 连接</li><li>构建请求头信息</li><li>发送请求头信息</li><li>服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li></ul></li><li><p>网络进程解析响应流程：</p></li><li><ul><li>检查状态码，如果是 301/302，则需要重定向，从 Location 自动读取地址，重新进行第 4 步，如果是 200，则继续处理请求</li><li>200 响应处理：检查响应类型 Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续渲染。如果是 html 则通知浏览器进程准备渲染进程进行渲染</li></ul></li><li><p>准备渲染进程</p></li><li><ul><li>浏览器进程检查当前 URL 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li></ul></li><li><p>传输数据、更新状态</p></li><li><ul><li>渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”</li><li>渲染进程接收完数据后，向浏览器发送“确认提交”</li><li>浏览器进程接收到确认消息后 engine 浏览器界面状态：安全、地址 URL、前进后退的历史状态、更新 web 页面</li></ul></li></ul></blockquote><h3 id="浏览器渲染相关"><a href="#浏览器渲染相关" class="headerlink" title="浏览器渲染相关"></a>浏览器渲染相关</h3><h4 id="渲染流程：HTML、CSS-和-JavaScript-是如何变成页面的"><a href="#渲染流程：HTML、CSS-和-JavaScript-是如何变成页面的" class="headerlink" title="渲染流程：HTML、CSS 和 JavaScript 是如何变成页面的"></a>渲染流程：HTML、CSS 和 JavaScript 是如何变成页面的</h4><blockquote><ul><li><p>浏览器不能直接理解 HTML 数据，需要将其转化为 DOM 树结构；</p></li><li><p>生成 DOM 树后，根据 CSS 样式表，计算出 DOM 树所有节点样式；</p></li><li><p>创建布局树：遍历 DOM 树所有可见节点，把这些节点加到布局中，不可见节点忽略，如 head 标签下所有内容，display: none 元素；</p></li><li><p>分层：层叠上下文属性的元素（比如定位属性元素、透明属性元素、CSS 滤镜属性元素）提升为单独的一层，需要裁剪的地方（比如出现滚动条）也会被创建为图层；</p></li><li><p>图层绘制：完成图层树构建后，渲染引擎会对图层树每一层进行绘制，把一个图层拆分成小的绘制指令，再把指令按照顺序组成一个带绘制列表；</p></li><li><p>有些情况图层很大，一次绘制所有图层内容，开销太大，合成线程会将图层划分为图块（256x256 或者 512x512）；</p></li><li><p>合成线程将图块提交给栅格线程进行栅格化，将图块转换为位图。栅格化过程都会使用 GPU 加速，生成的位图保存周期 GPU 内存中；</p></li><li><p>一旦所有图块都被栅格化，合成线程会生成一个绘制图块命令（DrawQuad），然会将命令提交给浏览器进程，viz 组件接收到该指令，将页面内容绘制到内存中，显示在屏幕上；</p></li><li><p>重排：通过 JavaScript 或者 CSS 修改元素几何位置属性，会触发重新布局，解析后面一系列子阶段；重绘：不引起布局变换，直接进入绘制及其以后子阶段；合成：跳过布局和绘制阶段，执行的后续操作，发生在合成线程，非主线程；</p></li></ul></blockquote><h4 id="渲染流水线：CSS-如何影响首次加载时的白屏时间？"><a href="#渲染流水线：CSS-如何影响首次加载时的白屏时间？" class="headerlink" title="渲染流水线：CSS 如何影响首次加载时的白屏时间？"></a>渲染流水线：CSS 如何影响首次加载时的白屏时间？</h4><blockquote><ul><li>DOM 构建结束之后，css 文件还未下载完成，渲染流水线空闲，因为下一步是合成布局树，合成布局树需要 CSSOM 和 DOM，这里需要等待 CSS 加载结束并解析成 CSSOM；</li><li>CSSOM 两个作用：提供给 JavaScript 操作样式表能力，为布局树的合成提供基础样式信息；</li><li>在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转化为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</li></ul></blockquote><h4 id="为什么操作-DOM-慢？"><a href="#为什么操作-DOM-慢？" class="headerlink" title="为什么操作 DOM 慢？"></a>为什么操作 DOM 慢？</h4><p>操作DOM（文档对象模型）慢的原因主要有以下几点：</p><blockquote><ol><li><strong>DOM操作引起浏览器的重绘（Repaint）和重排（Reflow）</strong>：每次DOM操作（如添加、修改、删除节点或改变样式）都可能导致浏览器需要重新计算元素的几何属性（重排），并重新绘制页面上的部分内容或全部内容（重绘）。这两个过程都是相当耗时的，特别是当页面包含大量元素或复杂布局时。</li><li><strong>DOM操作与ECMAScript实现的分离</strong>：在浏览器中，DOM的实现和ECMAScript（JavaScript的核心语言规范）的实现是分离的。这意味着当通过JavaScript代码操作DOM时，实际上是在两个相互独立的模块之间进行交互。这种跨模块的调用相比于在同一个模块内部进行调用，其性能损耗会更高。</li><li><strong>频繁的DOM查询和样式操作</strong>：如果在代码中频繁地进行DOM查询或样式操作，会进一步增加浏览器的渲染负担。因为每次查询或操作都可能导致浏览器重新计算元素的属性或重新绘制页面。</li><li><strong>不必要的渲染</strong>：如果对DOM进行不必要的操作（如频繁地改变元素的样式或位置），即使这些变化对最终的用户界面没有实际影响，也会导致浏览器进行额外的渲染工作，从而降低性能。</li></ol></blockquote><p>为了提高DOM操作的性能，可以采取以下策略：</p><blockquote><ol><li><strong>最小化DOM访问</strong>：在JavaScript代码中尽可能减少对DOM的访问和操作。可以通过在循环外缓存DOM引用、使用局部变量等方式来减少DOM查询的次数。</li><li><strong>批量修改DOM</strong>：如果需要对多个DOM元素进行修改，可以尝试将它们从文档流中移除（如使用<code>display: none</code>或<code>detach()</code>方法），对其进行批量修改后再重新插入到文档中。这样可以减少页面的重绘和重排次数。</li><li><strong>使用事件委托</strong>：在父节点上监听事件，而不是在每个子节点上单独监听。这样可以减少事件处理程序的数量，提高性能。</li><li><strong>使用CSS类来修改样式</strong>：尽量避免直接通过JavaScript修改DOM元素的样式属性。相反，可以使用CSS类来定义样式，并通过JavaScript来切换元素的类名。这样可以减少浏览器的重绘和重排次数。</li><li><strong>使用文档碎片（DocumentFragment）</strong>：将多个DOM节点插入到文档碎片中，然后再将文档碎片一次性插入到文档中。这样可以减少页面的重绘次数。</li></ol></blockquote><h4 id="什么情况阻塞渲染？-解析cssom-与-解析js-会阻碍渲染流程吗？"><a href="#什么情况阻塞渲染？-解析cssom-与-解析js-会阻碍渲染流程吗？" class="headerlink" title="什么情况阻塞渲染？ 解析cssom 与 解析js 会阻碍渲染流程吗？"></a>什么情况阻塞渲染？ 解析cssom 与 解析js 会阻碍渲染流程吗？</h4><p>在浏览器的渲染过程中，有几种情况可能会导致渲染被阻塞：</p><blockquote><ol><li><strong>CSSOM的解析</strong>：<ul><li>当浏览器在构建渲染树时，它需要完整的DOM树和CSSOM树。如果CSSOM树还没有构建完成，那么渲染树的构建会被阻塞，从而导致页面渲染被延迟。这是因为页面渲染需要DOM树和CSS树合并成渲染树，然后才能开始渲染过程。</li><li>另外，如果JavaScript代码在执行过程中访问了某个元素的样式（即CSSOM），那么浏览器需要等待该样式被下载和解析完成才能继续执行JavaScript代码。这也可以看作是CSS阻塞了JavaScript的执行，从而间接地阻塞了渲染流程。</li></ul></li><li><strong>JavaScript的解析和执行</strong>：<ul><li>当HTML解析器遇到<code>&lt;script&gt;</code>标签时，它会暂停DOM的解析，将控制权移交给JavaScript引擎来执行JavaScript代码。这意味着在JavaScript代码执行期间，DOM的解析和页面的渲染都会被阻塞。</li><li>如果<code>&lt;script&gt;</code>标签没有使用<code>async</code>或<code>defer</code>属性，那么浏览器会按照HTML文档中的顺序来加载和执行JavaScript代码。这可能会导致渲染被长时间阻塞，尤其是在JavaScript文件较大或网络较慢的情况下。</li></ul></li></ol></blockquote><p>为了避免CSS和JavaScript阻塞渲染流程，可以采取以下策略：</p><blockquote><ol><li><strong>将CSS放在<code>&lt;head&gt;</code>中</strong>：将CSS样式表放在HTML文档的<code>&lt;head&gt;</code>部分中，可以确保在DOM解析过程中尽早开始CSS的加载和解析。</li><li><strong>使用JavaScript的<code>async</code>和<code>defer</code>属性</strong>：<code>async</code>属性允许浏览器异步加载和执行JavaScript代码，而不会阻塞DOM的解析。但是，使用<code>async</code>的JavaScript代码可能会按照不同的顺序执行，因此需要确保代码之间没有依赖关系。<code>defer</code>属性则会让浏览器在解析完整个HTML文档后再加载和执行JavaScript代码，这样可以确保在JavaScript代码执行时DOM已经完全解析完成。</li><li><strong>代码拆分和懒加载</strong>：将JavaScript代码拆分成多个小文件，并使用懒加载技术来按需加载代码。这可以减少首次加载时需要加载的代码量，提高页面加载速度。</li><li><strong>使用Web Workers</strong>：对于计算密集型任务，可以使用Web Workers在后台线程中执行JavaScript代码，而不会阻塞页面的渲染。但是需要注意的是，Web Workers不能直接访问DOM和CSSOM，因此它们主要用于执行与页面渲染无关的任务。</li></ol></blockquote><h3 id="浏览器进程和线程相关"><a href="#浏览器进程和线程相关" class="headerlink" title="浏览器进程和线程相关"></a>浏览器进程和线程相关</h3><h4 id="介绍一下浏览器中的进程和线程"><a href="#介绍一下浏览器中的进程和线程" class="headerlink" title="介绍一下浏览器中的进程和线程"></a>介绍一下浏览器中的进程和线程</h4><p>浏览器中的进程和线程是操作系统中用于管理和执行代码的基本单位，它们在浏览器中扮演着不同的角色，共同协作以实现浏览器的各种功能。</p><p>首先，我们来看进程。进程是操作系统分配资源的基本单位，每个进程都有自己的独立内存空间和系统资源。在浏览器中，主要有以下几种进程：</p><blockquote><ol><li>浏览器进程：这是浏览器的主进程，负责协调和管理其他子进程。它的主要功能包括浏览器的界面显示、与用户交互（如前进、后退等）、管理各个页面、创建和销毁其他进程、网络资源的管理和下载等。</li><li>渲染进程（Renderer进程）：通常被称为浏览器内核，是页面渲染的核心进程。每个渲染进程内部都是多线程的，主要负责页面的渲染、脚本的执行、事件的处理等。默认情况下，每打开一个新的标签页会开启一个新的渲染进程，以确保不同标签页之间代码的互不影响。</li><li>GPU进程：最多一个，用于3D绘制等图形处理任务。</li><li>网络进程：负责网络资源的加载和管理，包括处理用户的网络请求、下载资源等。网络进程内部会启动多个线程来处理不同的网络任务。</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li></ol></blockquote><p>接下来是线程。线程是操作系统中能够被CPU调度和执行的最小单位。一个进程可以包含多个线程，它们共享进程的内存空间和资源，但每个线程都有自己的堆栈和局部变量等信息。线程可以看作是进程中的独立执行流，具有自己的执行路径、状态和优先级等属性。在浏览器中，主要有以下几种线程：</p><blockquote><ol><li>UI主线程：负责协调浏览器的整体运转，包括界面的渲染、用户交互的处理等。</li><li>JS引擎线程：负责执行JavaScript代码，包括解释执行js代码、处理用户输入、网络请求等。</li><li>GUI线程：负责渲染页面，绘制用户界面。由于JS可以操作DOM元素，进而影响到GUI的渲染效果，因此JS引擎线程与GUI渲染线程是互斥的，即当JS引擎线程处于运行状态时，GUI渲染线程将处于冻结状态。</li><li>HTTP网络请求线程：负责网络通信，处理用户的网络请求，并在返回结果后将回调函数推入任务队列。</li><li>定时触发器线程：负责计时，当setTimeout、setInterval等待时间结束后，将执行函数推入任务队列中。</li><li>浏览器事件处理线程：负责监听各种事件，如click、mouse等交互事件，并将这些事件放入事件队列中。</li></ol></blockquote><p>总的来说，浏览器中的进程和线程共同协作，以实现浏览器的各种功能和性能优化。每个进程和线程都有自己的特定角色和任务，通过它们之间的交互和协作，浏览器能够高效地加载、渲染和交互网页内容。</p><h4 id="什么情况下会导致浏览器的内存泄露-？如何避免"><a href="#什么情况下会导致浏览器的内存泄露-？如何避免" class="headerlink" title="什么情况下会导致浏览器的内存泄露 ？如何避免?"></a>什么情况下会导致浏览器的内存泄露 ？如何避免?</h4><p>浏览器的内存泄露通常发生在以下几种情况：</p><blockquote><ol><li><strong>全局变量</strong>：JavaScript对未声明的变量处理方式是在全局对象（在浏览器环境中为window对象）上创建该变量的引用。这些全局变量在窗口关闭或重新刷新页面之前都不会被释放，如果它们缓存了大量的数据，就会导致内存泄露。为了避免这种情况，应减少不必要的全局变量，并使用严格模式（’use strict’）来避免意外创建全局变量。</li><li><strong>闭包</strong>：闭包可以读取函数内部的变量，并让这些变量始终保存在内存中。如果在使用闭包后没有正确清除其中的局部变量，就可能导致内存泄露。因此，需要在使用完闭包后及时解除其中的变量引用。</li><li><strong>事件监听</strong>：对同一个事件重复监听但没有移除监听器，也会导致内存泄露。为了避免这种情况，应确保在不需要事件监听器时及时移除它们。</li><li><strong>控制台日志</strong>：使用console.log打印的对象在控制台中不会被垃圾回收，这可能会导致内存泄露。因此，在生产环境中应避免使用console.log，或者在使用后及时清除控制台日志。</li></ol></blockquote><p>为了避免浏览器的内存泄露，可以采取以下措施：</p><blockquote><ol><li><strong>减少全局变量的使用</strong>：尽量使用局部变量，并在使用完后及时清除它们的引用。</li><li><strong>合理使用闭包</strong>：在闭包使用完毕后，及时清除其中的变量引用，确保内存得到释放。</li><li><strong>管理事件监听器</strong>：在不需要事件监听器时及时移除它们，避免重复监听和内存泄露。</li><li><strong>避免在控制台中保留大量数据</strong>：在生产环境中避免使用console.log，或者在使用后及时清除控制台日志。</li><li><strong>使用浏览器开发者工具</strong>：利用浏览器的开发者工具来监控内存使用情况，及时发现并解决内存泄露问题。</li><li><strong>优化代码逻辑</strong>：组织好代码逻辑，避免死循环等导致浏览器卡顿或崩溃的问题。</li></ol></blockquote><p>通过采取以上措施，可以有效地避免浏览器的内存泄露问题，提高浏览器的性能和稳定性。</p><h4 id="Js是单线程还是多线程，浏览器如何支持多个Js线程？"><a href="#Js是单线程还是多线程，浏览器如何支持多个Js线程？" class="headerlink" title="Js是单线程还是多线程，浏览器如何支持多个Js线程？"></a>Js是单线程还是多线程，浏览器如何支持多个Js线程？</h4><p><strong>JavaScript是单线程语言</strong>。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM（文档对象模型）。这种用途决定了它只能是单线程，否则会带来很复杂的同步问题。</p><p>然而，尽管JavaScript本身是单线程的，但现代浏览器通过一些技术使得JavaScript可以并发执行，从而支持多个线程。这主要通过<strong>Web Workers</strong>实现。Web Workers是一种浏览器端的后台线程，用于执行JavaScript代码。这些线程在后台运行，独立于其他脚本，不会影响页面的性能。Web Workers可以处理大量计算任务，而不会阻塞主线程，从而提高了Web应用的响应性和性能。</p><p>Web Workers可以分为两种类型：专用线程（Dedicated Worker）和共享线程（Shared Worker）。专用线程与创建它的脚本连接在一起，它可以与其他的worker或是浏览器组件通信，但不能与DOM通信。而共享线程可以在多个浏览器窗口或者标签页之间共享。</p><p>需要注意的是，虽然Web Workers可以创建多个线程，但这些线程之间的通信是通过消息传递实现的，而不是直接共享内存。因此，在传递大量数据时可能会出现性能问题。此外，Web Workers API只能在浏览器环境中使用，Node.js不支持Web Workers API。</p><h4 id="介绍下-Worker-线程"><a href="#介绍下-Worker-线程" class="headerlink" title="介绍下 Worker 线程"></a>介绍下 Worker 线程</h4><p>Worker线程，特别是在Web编程中，是一种在后台运行的JavaScript线程，它独立于其他脚本，不会影响页面的性能。Worker线程主要用于处理那些计算密集型或高延迟的任务，从而避免阻塞主线程，保证Web应用的流畅运行。</p><p>以下是关于Worker线程的一些关键特点和使用场景：</p><ol><li><strong>基本概念</strong>：Worker线程是一种独立运行的进程或线程，可以与主程序并行工作，执行一些耗时较长或需要大量计算资源的任务。通过将这些任务分配给不同的Worker线程，可以实现并发处理，从而提高程序运行效率。</li><li><strong>类型</strong>：</li></ol><ul><li><strong>专用工作线程（Dedicated Worker）</strong>：与创建它的脚本连接在一起，它可以与其他的worker或是浏览器组件通信，但不能与DOM通信。</li><li><strong>共享工作线程（Shared Worker）</strong>：可以在多个浏览器窗口或者标签页之间共享。</li></ul><ol><li><strong>工作原理</strong>：Web Worker是通过创建一个独立的后台线程来工作的。在主线程中可以创建和管理Web Worker，并向其发送消息。Worker线程接收消息并执行相应的任务，然后将结果返回给主线程。这样可以避免在主线程中执行耗时的任务，提高页面的性能和响应速度。</li><li><strong>适用场景</strong>：适用于需要进行大量计算、数据处理或其他耗时任务的情况，例如数据分析、图像处理、加密解密等。</li><li><strong>注意事项</strong>：由于Worker线程是运行在后台的，它们不能直接访问DOM，也不能访问全局变量或函数。它们只能通过消息传递与主线程进行通信。</li></ol><p>总的来说，Worker线程是一种强大的工具，可以帮助开发者在Web应用中实现高效的并发处理，提升用户体验。</p><h4 id="Worker-线程有两种你知道吗？"><a href="#Worker-线程有两种你知道吗？" class="headerlink" title="Worker 线程有两种你知道吗？"></a>Worker 线程有两种你知道吗？</h4><p><strong>是的，Worker线程主要有两种：专用工作线程（Dedicated Web Worker）和共享工作线程（Shared Web Worker）</strong>。</p><ol><li><strong>专用工作线程（Dedicated Web Worker）</strong>：这是最简单的Web Worker线程。网页中的脚本可以创建专用工作线程来执行在“页面线程之外”的其他任务。这些任务可以是计算密集型的，也可以是I/O密集型的，比如网络请求或文件读写。由于专用工作线程和主线程是完全独立的，它们之间的通信需要通过消息传递来实现。</li><li><strong>共享工作线程（Shared Web Worker）</strong>：共享工作线程允许多个脚本共享同一个工作线程。这对于需要在多个脚本之间共享数据或状态的场景非常有用。与专用工作线程不同，共享工作线程的生命周期由所有使用它的脚本共同控制。</li></ol><p>在Web Worker线程中，直接运行JavaScript代码，但是不能操作DOM节点，也不能使用window对象的默认方法和属性、不能使用webSockets, IndexedDB等数据存储机制。主线程或Worker线程中，可以通过postMessage方法向另一个线程发送消息，使用onmessage事件函数来接收另一个线程发送的消息。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="浏览器底层基础"><a href="#浏览器底层基础" class="headerlink" title="浏览器底层基础"></a>浏览器底层基础</h3><h4 id="变量提升：javascript-代码是按顺序执行的吗"><a href="#变量提升：javascript-代码是按顺序执行的吗" class="headerlink" title="变量提升：javascript 代码是按顺序执行的吗"></a>变量提升：javascript 代码是按顺序执行的吗</h4><blockquote><ul><li>JavaScript 代码在执行之前需要先编译，在编译阶段，变量和函数会被存放到变量环境中，变量默认值会被设置为 undefined；</li><li>在代码执行阶段，JavaScript 引擎会从变量环境中查找自定义的变量和函数；</li><li>如果在编译阶段，窜爱两个相同的函数，那么最终放在变量环境中的是最后定义的那个，后定义的覆盖先定义的；</li></ul></blockquote><h4 id="调用栈：为什么-JavaScript-代码会出现栈溢出"><a href="#调用栈：为什么-JavaScript-代码会出现栈溢出" class="headerlink" title="调用栈：为什么 JavaScript 代码会出现栈溢出"></a>调用栈：为什么 JavaScript 代码会出现栈溢出</h4><blockquote><ul><li>每调用一个函数，JavaScript 引擎会为其创建执行上下文压入调用栈，然后，JavaScript 引擎开始执行函数代码。</li><li>如果一个函数 A 调用另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</li><li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li></ul></blockquote><h4 id="块级作用域：var-缺陷以及为什么要引入-let-和-const"><a href="#块级作用域：var-缺陷以及为什么要引入-let-和-const" class="headerlink" title="块级作用域：var 缺陷以及为什么要引入 let 和 const"></a>块级作用域：var 缺陷以及为什么要引入 let 和 const</h4><blockquote><ul><li>let、const 申明的变量不会被提升。在 javascript 引擎编译后，会保存在词法环境中。</li><li>块级作用域在代码执行时，将 let、const 变量存放在词法环境的一个单独的区域。词法环境内部维护一个小型的栈结构，作用域内部变量压入栈顶。作用域执行完，从栈顶弹出。</li></ul></blockquote><h4 id="作用域链和闭包：代码中出现相同的变量，JavaScript-引擎如何选择"><a href="#作用域链和闭包：代码中出现相同的变量，JavaScript-引擎如何选择" class="headerlink" title="作用域链和闭包：代码中出现相同的变量，JavaScript 引擎如何选择"></a>作用域链和闭包：代码中出现相同的变量，JavaScript 引擎如何选择</h4><blockquote><ul><li>使用一个变量，JavaScript 引擎会在当前的执行上下文中查找变量，如果没有找到，会继续在 outer（执行环境指向外部执行上下文的引用）所指向的执行上下文中查找；</li><li>JavaScript 执行过程，作用域链是由词法作用域决定，而词法作用域是由代码中函数声明的位置决定；</li><li>根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使外部函数已经执行结束了，但是内部函数引用外部函数的变量依旧保存在内存中，把这些变量的集合称为闭包；</li></ul></blockquote><h4 id="this：从-JavaScript-执行上下文视角讲-this"><a href="#this：从-JavaScript-执行上下文视角讲-this" class="headerlink" title="this：从 JavaScript 执行上下文视角讲 this"></a>this：从 JavaScript 执行上下文视角讲 this</h4><blockquote><p>当执行 new CreateObj 的时候，JavaScript 引擎做了四件事：</p><ul><li>首先创建一个控对象 tempObj；</li><li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 createObj 的执行上下文创建时，它的 this 就指向 tempObj 对象；</li><li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向 tempObj 对象；</li><li>最后返回 tempObj 对象。</li></ul><p>this 的使用分为：</p><ul><li>当函数最为对象的方法调用时，函数中的 this 就是该对象；</li><li>当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；</li><li>嵌套函数中的 this 不会继承外层函数的 this 值；</li><li>箭头函数没有自己的执行上下文，this 是外层函数的 this。</li></ul></blockquote><h4 id="DOM-树：JavaScript-是如何影响-DOM-树构建的"><a href="#DOM-树：JavaScript-是如何影响-DOM-树构建的" class="headerlink" title="DOM 树：JavaScript 是如何影响 DOM 树构建的"></a>DOM 树：JavaScript 是如何影响 DOM 树构建的</h4><blockquote><ul><li>HTML 解析器（HTMLParse）负责将 HTML 字节流转换为 DOM 结构；</li><li>HTML 解析器并不是等整个文档加载完成之后再解析，而是网络进程加载流多少数据，便解析多少数据；</li><li>字节流转换成 DOM 三个阶段：1、字节流转换为 Token；2、维护一个 Token 栈，遇到 StartTag Token 入栈，遇到 EndTag Token 出栈；3、为每个 Token 创建一个 DOM 节点；</li><li>JavaScript 文件和 CSS 样式表文件都会阻塞 DOM 解析；</li></ul></blockquote><h4 id="宏任务和微任务：不是所有的任务都是一个待遇"><a href="#宏任务和微任务：不是所有的任务都是一个待遇" class="headerlink" title="宏任务和微任务：不是所有的任务都是一个待遇"></a>宏任务和微任务：不是所有的任务都是一个待遇</h4><blockquote><ul><li>消息队列中的任务为宏任务。渲染进程内部会维护多个消息队列，比如延时执行队列和普通消息队列，主线程采用 for 循环，不断地从这些任务队列中取出任务并执行；</li><li>微任务是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前；</li><li>V8 在执行 javascript 脚本时，会为其创建一个全局执行上下文，同时会创建一个微任务队列；</li><li>执行微任务过程中产生的微任务不会推迟到下个宏任务中执行，而是在当前宏任务中继续执行；</li></ul></blockquote><h4 id="使用-Promise-告别回调函数"><a href="#使用-Promise-告别回调函数" class="headerlink" title="使用 Promise 告别回调函数"></a>使用 Promise 告别回调函数</h4><ul><li>使用 Promise 解决了回调地狱问题，消灭嵌套和多次处理；</li><li>模拟实现 Promise</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Bromise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> _onResolve <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>then <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>onResolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _onResolve <span class="token operator">=</span> onResolve  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">_onResolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="async-await-使用同步方式写异步代码"><a href="#async-await-使用同步方式写异步代码" class="headerlink" title="async await 使用同步方式写异步代码"></a>async await 使用同步方式写异步代码</h4><blockquote><ul><li>生成器函数是一个带星号函数，而且是可以暂停执行和回复执行的；</li><li>生成器函数内部执行一段代码，遇到 yield 关键字，javascript 引擎返回关键字后面的内容给外部，并且暂停该函数的执行；</li><li>外部函数可以同步 next 方法恢复函数的执行；</li><li>协程是一种比线程更加轻量级的存在，协程可以看成是跑在线程上的任务，一个线程可以存在多个协程，但是同时只能执行一个协程，如果 A 协程启动 B 协程，A 为 B 的父协程；</li><li>协程不被操作协同内核所管理，而完全由程序所控制，这样性能提升；</li><li><code>await xxx</code> 会创建一个 Promise 对象，将 <code>xxx</code> 任务提交给微任务队列；</li><li>暂停当前协程的执行，将主线程的控制权力转交给父协程执行，同时将 Promise 对象返回给父协程，继续执行父协程；</li><li>父协程执行结束之前会检查微任务队列，微任务队列中有 <code>resolve(xxx)</code> 等待执行，触发 then 的回调函数；</li><li>回调函数被激活后，会将主线程的控制权交给协程，继续执行后续语句，完成后将控制权还给父协程。</li></ul></blockquote><h4 id="webapi：setTimeout-是怎么实现的"><a href="#webapi：setTimeout-是怎么实现的" class="headerlink" title="webapi：setTimeout 是怎么实现的"></a>webapi：setTimeout 是怎么实现的</h4><blockquote><ul><li>JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程会创建一个回调任务，延时执行队列存放定时器任务；</li><li>当定时器任务到期，就会从延时队列中取出并执行；</li><li>如果当前任务执行时间过久，会影响延时到期定时器任务的执行；</li><li>如果 setTimeout 存在嵌套调用（5 次以上），判断该函数方法被阻塞，那么系统会设置最短时间间隔为 4 秒；</li><li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒，目的是为了降低加载损耗；</li><li>延时执行时间最大值是 24.8 天，因为延时值是以 32 个 bit 存储的；</li><li>setTimeout 设置的回调函数中的 this 指向全局 window。</li></ul></blockquote><h4 id="webapi：XMLHttpRequest-是怎么实现的"><a href="#webapi：XMLHttpRequest-是怎么实现的" class="headerlink" title="webapi：XMLHttpRequest 是怎么实现的"></a>webapi：XMLHttpRequest 是怎么实现的</h4><blockquote><ul><li>XMLHttpRequest onreadystatechange 处理流程：未初始化 -&gt; OPENED -&gt; HEADERS_RECEIVED -&gt; LOADING -&gt; DONE；</li><li>渲染进程会将请求发送给网络进程，然后网络进程负责资源下载，等网络进程接收到数据后，利用 IPC 通知渲染进程；</li><li>渲染进程接收到消息之后，会将 xhr 回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，会根据相关状态来调用回调函数。</li></ul></blockquote><h3 id="浏览器运行机制"><a href="#浏览器运行机制" class="headerlink" title="浏览器运行机制"></a>浏览器运行机制</h3><h4 id="栈空间和堆空间：数据是如何存储的"><a href="#栈空间和堆空间：数据是如何存储的" class="headerlink" title="栈空间和堆空间：数据是如何存储的"></a>栈空间和堆空间：数据是如何存储的</h4><blockquote><p>动态语言：在使用时需要检查数据类型的语言。<br>弱类型语言：支持隐式转换的语言。</p><p>JavaScript 中的 8 种数据类型，它们可以分为两大类——原始类型和引用类型。<br>原始类型数据存放在栈中，引用类型数据存放在堆中。堆中的数据是通过引用与变量关系联系起来的。</p><p>从内存视角了解闭包：词法扫描内部函数，引用了外部函数变量，堆空间创建一个“closure”对象，保存变量。</p></blockquote><h4 id="什么是浏览器的垃圾回收机制？垃圾回收的方式有哪些？"><a href="#什么是浏览器的垃圾回收机制？垃圾回收的方式有哪些？" class="headerlink" title="什么是浏览器的垃圾回收机制？垃圾回收的方式有哪些？"></a>什么是浏览器的垃圾回收机制？垃圾回收的方式有哪些？</h4><p>浏览器的垃圾回收机制是指浏览器通过自动回收不再使用的内存来管理内存的一种机制。在浏览器中，JavaScript程序在运行过程中会动态地分配内存，但当这些内存不再被使用时，如果没有适当的回收机制，可能会导致内存泄漏，进而影响浏览器的性能和稳定性。</p><p>浏览器的垃圾回收机制主要基于以下两种回收方式：</p><ol><li>标记清除（Mark-and-Sweep）：</li></ol><ul><li>标记阶段：垃圾回收器从根对象（如全局变量、当前正在执行的函数等）开始遍历内存中的所有对象，标记所有仍然被使用的对象。对于无法访问到的对象，垃圾回收器会将其标记为不可达对象。</li><li>清除阶段：垃圾回收器会清除所有被标记为不可达对象的内存空间，将其回收，以便后续的内存分配。</li></ul><p>这种方式在现代浏览器中得到了广泛应用，如IE9+、Firefox、Opera、Chrome、Safari等浏览器的JavaScript实现都使用了标记清除的垃圾回收策略或类似的策略。</p><ol><li>引用计数（Reference Counting）：</li></ol><ul><li>原理：通过记录每个对象被引用的次数来判断对象是否可回收。当一个对象被创建时，它的引用计数为1；当它被其他对象引用时，引用计数加1；当它被其他对象释放时，引用计数减1；当它的引用计数为0时，它就可以被回收。</li><li>缺点：无法处理循环引用的情况，即两个或多个对象相互引用，但没有被其他对象引用，这样它们的引用计数永远不会为0，导致内存泄漏。</li></ul><p>需要注意的是，虽然引用计数是一种较早的垃圾回收方法，但在现代浏览器中并不常用，主要是因为其无法处理循环引用的问题。</p><p>此外，浏览器的垃圾回收机制还涉及到数据的存储方式，即栈内存和堆内存。栈内存用于存储原始类型的数据，而堆内存则用于存储引用类型的值。因此，浏览器的垃圾回收机制也分为栈垃圾回收和堆垃圾回收。栈垃圾回收主要发生在函数执行结束后，通过向下移动ESP指针（记录调用栈当前执行状态的指针）来销毁函数保存在栈中的执行上下文。而堆垃圾回收则需要垃圾回收器来回收堆空间中的垃圾数据。</p><h4 id="垃圾回收：垃圾数据如何自动回收"><a href="#垃圾回收：垃圾数据如何自动回收" class="headerlink" title="垃圾回收：垃圾数据如何自动回收"></a>垃圾回收：垃圾数据如何自动回收</h4><blockquote><ul><li>栈中数据回收：执行状态指针 ESP 在执行栈中移动，移过某执行上下文，就会被销毁；</li><li>堆中数据回收：V8 引擎采用标记-清除算法；</li><li>V8 把堆分为两个区域——新生代和老生代，分别使用副、主垃圾回收器；</li><li>副垃圾回收器负责新生代垃圾回收，小对象（1 ～ 8M）会被分配到该区域处理；</li><li>新生代采用 scavenge 算法处理：将新生代空间分为两半，一半空闲，一半存对象，对对象区域做标记，存活对象复制排列到空闲区域，没有内存碎片，完成后，清理对象区域，角色反转；</li><li>新生代区域两次垃圾回收还存活的对象晋升至老生代区域；</li><li>主垃圾回收器负责老生区垃圾回收，大对象，存活时间长；</li><li>新生代区域采用标记-清除算法回收垃圾：从根元素开始，递归，可到达的元素活动元素，否则是垃圾数据；</li><li>为了不造成卡顿，标记过程被切分为一个个子标记，交替进行。</li></ul></blockquote><h4 id="【马上消费】如何最快的执行垃圾回收机制？"><a href="#【马上消费】如何最快的执行垃圾回收机制？" class="headerlink" title="【马上消费】如何最快的执行垃圾回收机制？"></a>【马上消费】如何最快的执行垃圾回收机制？</h4><p>在JavaScript中，垃圾回收机制是由浏览器或JavaScript引擎自动管理的，因此你不能直接“执行”垃圾回收机制。但是，你可以通过一些编程实践来优化内存使用，从而间接地提高垃圾回收的效率。</p><p>以下是一些建议，可以帮助你优化JavaScript的内存使用，从而加快垃圾回收的过程：</p><blockquote><ol><li><strong>避免全局变量的使用</strong>：全局变量在整个程序的生命周期内都存在，因此它们会占用更多的内存。尽量使用局部变量，并在不再需要时将其设为<code>null</code>，以便垃圾回收器可以回收它们占用的内存。</li><li><strong>手动解除引用</strong>：当你不再需要某个对象时，确保将其所有引用都设为<code>null</code>。这可以帮助垃圾回收器更快地识别并回收该对象占用的内存。</li><li><strong>避免不必要的对象创建</strong>：尽量减少不必要的对象创建，以减少内存分配和垃圾回收的开销。你可以使用对象池、缓存或其他技术来重用对象。</li><li><strong>使用适当的数据结构和算法</strong>：选择适当的数据结构和算法可以显著减少内存使用。例如，使用数组而不是对象来存储一组有序的元素，使用哈希表来存储键值对等。</li><li><strong>优化循环和递归</strong>：循环和递归是常见的内存消耗源。确保你的循环和递归逻辑是高效的，并避免在循环中创建大量对象。</li><li><strong>使用内存分析工具</strong>：使用内存分析工具（如Chrome DevTools的内存面板）来检查你的程序的内存使用情况。这些工具可以帮助你找到内存泄漏和不必要的内存使用，并为你提供优化建议。</li></ol></blockquote><p>请注意，虽然这些建议可以帮助你优化JavaScript的内存使用，但垃圾回收机制仍然是由浏览器或JavaScript引擎自动管理的。因此，你不应该尝试直接控制或执行垃圾回收机制。相反，你应该专注于编写高效、内存友好的代码，并让垃圾回收器自动管理内存回收的过程。</p><h4 id="如何减少垃圾回收"><a href="#如何减少垃圾回收" class="headerlink" title="如何减少垃圾回收?"></a>如何减少垃圾回收?</h4><p>减少垃圾回收是提高程序性能和内存管理效率的关键。以下是一些减少垃圾回收的策略和技巧：</p><blockquote><ol><li>优化数据结构<ul><li>选择合适的数据结构来存储数据，避免不必要的数据复制和内存分配。</li><li>使用对象池或缓存来重用对象，而不是频繁地创建和销毁它们。</li></ul></li><li>减少不必要的对象创建<ul><li>避免在循环中创建对象，尽量在循环外部创建对象，并在循环内部重复使用。</li><li>使用字符串连接操作符（如 <code>+</code>）时要小心，因为它可能导致大量的临时字符串被创建。考虑使用 <code>StringBuilder</code> 或其他类似的方法来构建字符串。</li></ul></li><li>及时解除对象引用<ul><li>一旦对象不再需要，确保将其引用设为 <code>null</code> 或从集合中移除。这有助于垃圾回收器更快地识别并回收不再使用的对象。</li><li>避免长时间持有不必要的对象引用，这可能导致内存泄漏。</li></ul></li><li>使用 <code>WeakMap</code> 和 <code>WeakSet</code><ul><li>在JavaScript中，<code>WeakMap</code> 和 <code>WeakSet</code> 是两种特殊的集合类型，它们允许对象作为键或成员，但对这些对象的引用是“弱”的，这意味着它们不会阻止垃圾回收。当这些对象没有其他引用时，它们可以被垃圾回收器回收。</li></ul></li><li>避免全局变量<ul><li>全局变量在整个程序的生命周期内都存在，因此它们会占用更多的内存。尽量使用局部变量，并在不再需要时将其设为 <code>null</code>。</li></ul></li><li>内存管理库和工具<ul><li>使用内存管理库或工具来帮助你跟踪和管理内存使用情况。这些工具可以帮助你识别内存泄漏和不必要的内存占用。</li></ul></li><li>使用合适的垃圾回收算法<ul><li>如果你正在开发一个需要高性能内存管理的应用程序，考虑使用一种具有更好垃圾回收性能的编程语言或框架。不同的语言和框架使用不同的垃圾回收算法，有些算法可能更适合你的应用程序。</li></ul></li><li>代码审查和测试<ul><li>定期进行代码审查和测试，以确保你的代码没有内存泄漏或其他内存管理问题。使用自动化测试工具可以帮助你更轻松地识别和修复这些问题。</li></ul></li><li>关注内存泄漏<ul><li>内存泄漏是减少垃圾回收的一个重要问题。了解常见的内存泄漏场景（如闭包、事件监听器等），并学会如何避免它们。</li></ul></li><li>更新和升级<ul><li>保持你的浏览器、JavaScript引擎和库更新到最新版本。新版本可能包含性能改进和内存管理优化，这可以帮助减少垃圾回收的开销。</li></ul></li></ol></blockquote><h4 id="编译器和解析器：V8-如何执行一段-JavaScript-代码的"><a href="#编译器和解析器：V8-如何执行一段-JavaScript-代码的" class="headerlink" title="编译器和解析器：V8 如何执行一段 JavaScript 代码的"></a>编译器和解析器：V8 如何执行一段 JavaScript 代码的</h4><blockquote><ul><li>计算机语言可以分为两种：编译型和解释型语言。编译型语言经过编译器编译后保留机器能读懂的二进制文件，比如 C/C++，go 语言。解释型语言是在程序运行时通过解释器对程序进行动态解释和执行，比如 Python，JavaScript 语言。</li><li>编译型语言的编译过程：编译器首先将代码进行词法分析、语法分析，生成抽象语法树（AST），然后优化代码，最后生成处理器能够理解的机器码；</li><li>解释型语言解释过程：解释器会对代码进行词法分析、语法分析，并生产抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后根据字节码执行程序；</li><li>AST 的生成：第一阶段是分词（词法分析），将一行行源码拆解成一个个 token（语法上不可再分、最小单个字符）。第二阶段是解析（语法分析），将上一步生成的 token 数据，根据语法规则转为 AST，这一阶段会检查语法错误；</li><li>字节码存在的意义：直接将 AST 转化为机器码，执行效率是非常高，但是消耗大量内存，从而先转化为字节码解决内存问题；</li><li>解释器 ignition 在解释执行字节码，同时会手机代码信息，发现某一部分代码是热点代码（HotSpot），编译器把热点的字节码转化为机器码，并保存起来，下次使用；</li><li>字节码配合解释器和编译器的计数实现称为即时编译（JIT）。</li></ul></blockquote><h4 id="v8垃圾回收处理机制"><a href="#v8垃圾回收处理机制" class="headerlink" title="v8垃圾回收处理机制"></a>v8垃圾回收处理机制</h4><p>V8是Google开源的JavaScript和WebAssembly引擎，用C++编写，主要用于Chrome和Node.js等。关于V8的垃圾回收处理机制，以下是一些关键信息：</p><blockquote><ol><li><strong>内存管理</strong>：JavaScript使用自动内存管理，这被称为“垃圾回收机制”（garbage collector）。V8的内存管理是基于这个原理的，它会自动跟踪哪些对象仍在使用，哪些对象可以被回收。</li><li><strong>内存限制</strong>：在64位操作系统上，V8可以使用大约1.4G的内存；在32位操作系统上，它可以使用大约0.7G的内存。</li><li><strong>堆（Heap）</strong>：在V8中，堆是用于动态存放对象的内存空间。当需要存放对象时，所需的内存空间会从堆中被分配给应用程序（mutator）。一旦堆被对象占满，垃圾回收器（GC）就会启动，从而分配可用空间。</li><li><strong>可达性（Reachability）</strong>：在V8中，“可达”是指那些以某种方式可访问或可用的值。这些值一定是存储在内存中的。垃圾回收器会标记所有可达的对象，并回收那些不可达的对象。</li><li><strong>Mutator</strong>：Mutator是用于更改GC对象间引用关系的实体，即“应用程序”。它会生成新的对象或更新指针，这些操作会改变对象间的引用关系。在mutator执行过程中，垃圾可能会产生，而GC就是负责回收这些垃圾的机制。</li><li><strong>优化策略</strong>：V8的垃圾回收器采用了多种优化策略来提高性能，例如分代回收（generational garbage collection）和增量回收（incremental garbage collection）等。</li></ol></blockquote><p>请注意，以上信息仅概述了V8垃圾回收处理机制的基本原理和关键概念。具体的实现细节和算法可能会因V8的版本和具体应用场景而有所不同。如果你对V8的垃圾回收处理机制有更深入的兴趣，建议查阅相关的技术文档或研究论文。</p><h4 id="v8引擎的垃圾回收算法讲一下"><a href="#v8引擎的垃圾回收算法讲一下" class="headerlink" title="v8引擎的垃圾回收算法讲一下"></a>v8引擎的垃圾回收算法讲一下</h4><p>V8引擎的垃圾回收算法主要基于分代式垃圾回收（Generational Garbage Collection）机制，它将内存中的对象分为不同的代（Generation），并为每一代采用不同的垃圾回收策略。以下是V8引擎中主要的垃圾回收算法：</p><blockquote><ol><li>新生代（Young Generation）<ul><li><strong>Scavenge算法（也称为Cheney算法）</strong>：新生代中的对象主要通过Scavenge算法进行垃圾回收。Scavenge算法是一种复制式的垃圾回收算法，它将新生代堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中（称为From空间），另一个处于闲置状态（称为To空间）。当分配对象时，先在From空间进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，并将这些存活对象复制到To空间中，同时释放非存活对象占用的空间。完成复制后，From空间和To空间的角色发生对换，称为翻转。</li><li><strong>对象晋升（Promotion）</strong>：新生代中的对象在经历一次或多次垃圾回收后仍然存活，它们会被移动到老生代中，采用更适合老生代的垃圾回收算法进行管理。</li></ul></li><li>老生代（Old Generation）<ul><li><strong>标记清除（Mark-Sweep）</strong>：对于老生代中的对象，V8采用了标记清除算法进行垃圾回收。该算法分为标记和清除两个阶段。在标记阶段，垃圾回收器会从根对象开始遍历所有可达的对象，并将它们标记为活动对象。在清除阶段，垃圾回收器会释放所有未被标记为活动对象的内存空间。</li><li><strong>标记压缩（Mark-Compact）</strong>：为了解决内存碎片问题，V8还采用了标记压缩算法。在标记压缩算法中，除了标记阶段外，还增加了一个压缩阶段。在压缩阶段，垃圾回收器会将所有活动对象移动到内存的一端，从而消除内存碎片，提高内存利用率。</li></ul></li><li><strong>增量标记（Incremental Marking）</strong>：为了减少主线程停顿时间，V8还引入了增量标记算法。该算法允许垃圾回收器在主线程执行JavaScript代码的同时进行标记工作。通过将标记任务拆分成多个小任务，并在主线程空闲时执行这些任务，增量标记算法可以显著减少主线程的停顿时间。</li></ol></blockquote><p>需要注意的是，V8引擎的垃圾回收算法是一个复杂的系统，它还包括许多其他的优化技术和策略，如内存优化、并发回收等。这些技术和策略共同协作，以确保V8引擎能够高效地管理内存并提供出色的性能。</p><h4 id="消息队列和事件循环：页面是怎么活起来的"><a href="#消息队列和事件循环：页面是怎么活起来的" class="headerlink" title="消息队列和事件循环：页面是怎么活起来的"></a>消息队列和事件循环：页面是怎么活起来的</h4><blockquote><ul><li>每个渲染进程都有一个主线程，主线程会处理 DOM，计算样式，处理布局，JavaScript 任务以及各种输入事件；</li><li>维护一个消息队列，新任务（比如 IO 线程）添加到消息队列尾部，主线程循环地从消息队列头部读取任务，执行任务；</li><li>解决处理优先级高的任务：消息队列的中的任务称为宏任务，每个宏任务中都会包含一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，将该变化添加到微任务队列中；</li><li>解决单个任务执行时长过久：JavaScript 通过回调功能来规避。</li></ul></blockquote><h4 id="分层和合成机制：为什么-CSS-动画比-JavaScript-高效"><a href="#分层和合成机制：为什么-CSS-动画比-JavaScript-高效" class="headerlink" title="分层和合成机制：为什么 CSS 动画比 JavaScript 高效"></a>分层和合成机制：为什么 CSS 动画比 JavaScript 高效</h4><blockquote><ul><li>显示器固定刷新频率是 60HZ，即每秒更新 60 张图片，图片来自显卡的前缓冲区；</li><li>显卡的职责是合成新的图像，保存在后缓冲区，然后后缓冲区和前缓冲区互换，显卡更新频率和显示前刷新频率不一致，就会造成视觉上的卡顿；</li><li>渲染流水线生成的每一副图片称为一帧，生成一帧的方式有重排、重绘和合成三种；</li><li>重排会根据 CSSOM 和 DOM 计算布局树，重绘没有重新布局阶段；</li><li>生成布局树之后，渲染引擎根据布局树特点转化为层树，每一层解析出绘制列表；</li><li>栅格线程根据绘制列表中的指令生成图片，每一层对应一张图片，合成线程将这些图片合成一张图片，发送到后缓存区；</li><li>合成线程会将每个图层分割成大小固定的图块，优先绘制靠近视口的图块；</li></ul></blockquote><h3 id="浏览器性能优化"><a href="#浏览器性能优化" class="headerlink" title="浏览器性能优化"></a>浏览器性能优化</h3><h4 id="页面性能：如何系统优化页面"><a href="#页面性能：如何系统优化页面" class="headerlink" title="页面性能：如何系统优化页面"></a>页面性能：如何系统优化页面</h4><blockquote><ul><li>加载阶段：减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数；</li><li>交互阶段：减少 JavaScript 脚本执行时间，避免强制同步布局：操作 DOM 的同时获取布局样式会引发，避免布局抖动：多次执行强制布局和抖动，合理利用 CSS 合成动画：标记 will-change，避免频繁的垃圾回收；</li><li>CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程中执行，这个过程称为合成，它不会触发重排或者重绘；</li></ul></blockquote><h4 id="虚拟-DOM：虚拟-DOM-和真实-DOM-有何不同"><a href="#虚拟-DOM：虚拟-DOM-和真实-DOM-有何不同" class="headerlink" title="虚拟 DOM：虚拟 DOM 和真实 DOM 有何不同"></a>虚拟 DOM：虚拟 DOM 和真实 DOM 有何不同</h4><blockquote><ul><li>当有数据更新时， React 会生产一个新的虚拟 DOM，然会拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程找出变化的节点，然后将变化的节点应用到 DOM 上；</li><li>最开始的时候，比较两个 DOM 的过程是在一个递归函数里执行的，其核心算法是 reconciliation。通常情况，这个比较过程执行很快，不过虚拟 DOM 比较复杂时，执行比较函数可能占据主线程比较久的时间，这样会导致其他任务的等待，造成页面卡顿。React 团队重写了 reconciliation 算法，称为 Fiber reconciler，之前老的算法称为 Stack reconciler；</li></ul></blockquote><h4 id="HTTP1：HTTP1-性能优化"><a href="#HTTP1：HTTP1-性能优化" class="headerlink" title="HTTP1：HTTP1 性能优化"></a>HTTP1：HTTP1 性能优化</h4><blockquote><ul><li>HTTP/0.9 基于 TCP 协议，三次握手建立连接，发送一个 GET 请求行（没有请求头和请求体），服务器接收请求之后，读取对应 HTML 文件，数据以 ASCII 字符流返回，传输完成断开连接；</li><li>HTTP/1.0 增加请求头和响应头来进行协商，在发起请求时通过请求头告诉服务器它期待返回什么类型问题、什么形式压缩、什么语言以及文件编码。引入来状态吗，Cache 机制等；</li><li>HTTP/1.1 改进持久化连接，解决建立 TCP 连接、传输数据和断开连接带来的大量开销，支持在一个 TCP 连接上可以传输多个 HTTP 请求，目前浏览器对于一个域名同时允许建立 6 个 TCP 持久连接；</li><li>HTTP/1.1 引入 Chunk transfer 支持动态生成内容：服务器将数据分割成若干任意大小的数据块，每个数据块发送时附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。在 HTTP/1.1 需要在响应头中设置完整的数据大小，如 Content-Length。</li></ul></blockquote><h4 id="HTTP2：如何提升网络速度"><a href="#HTTP2：如何提升网络速度" class="headerlink" title="HTTP2：如何提升网络速度"></a>HTTP2：如何提升网络速度</h4><blockquote><ul><li>HTTP/1.1 主要问题：TCP 慢启动；同时开启多条 TCP 连接，会竞争固定宽带；对头阻塞问题；</li><li>HTTP/2 在一个域名下只使用一个 TCP 长连接和消除对头阻塞问题；</li><li>多路复用的实现：HTTP/2 添加了二进制分帧层，将发送或响应数据经过二进制分帧处理，转化为一个个带有请求 ID 编号的帧，服务器或者浏览器接收到响应帧后，根据相同 ID 帧合并为一条完整信息；</li><li>设置请求优先级：发送请求可以设置请求优先级，服务器可以优先处理；</li><li>服务器推送：请求一个 HTML 页面，服务器可以知道引用了哪些 JavaScript 和 CSS 文件，附带一起发送给浏览器；</li><li>头部压缩：对请求头和响应头进行压缩；</li></ul></blockquote><h4 id="HTTP3：甩掉-TCP、TCL-包袱，构建高效网络"><a href="#HTTP3：甩掉-TCP、TCL-包袱，构建高效网络" class="headerlink" title="HTTP3：甩掉 TCP、TCL 包袱，构建高效网络"></a>HTTP3：甩掉 TCP、TCL 包袱，构建高效网络</h4><blockquote><ul><li>虽然 HTTP/2 解决了应用层面的对头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议，而 TCP 最初是为了单连接而设计；</li><li>TCP 可以看成是计算机之间的一个虚拟管道，数据从一端发送到另一端会被拆分为一个个按照顺序排列的数据包，如果在传输过程中，有一个数据因为网络故障或者其他原因丢失，那么整个连接会处于暂停状态，只有等到该数据重新传输；</li><li>由于 TCP 协议僵化，也不可能使用新的协议，HTTP/3 选择了一个折衷的方法，基于现有的 UDP 协议，实现类似 TC 片多路复用，传输可靠等功能，称为 QULC 协议；</li><li>QULC 实现类似 TCP 流量控制，传输可靠功能；集成 TLS 加密功能；实现多路复用功能；</li></ul></blockquote><h3 id="浏览器相关小贴士"><a href="#浏览器相关小贴士" class="headerlink" title="浏览器相关小贴士"></a>浏览器相关小贴士</h3><h4 id="同源策略：为什么-XMLHttpRequst-不能跨域请求"><a href="#同源策略：为什么-XMLHttpRequst-不能跨域请求" class="headerlink" title="同源策略：为什么 XMLHttpRequst 不能跨域请求"></a>同源策略：为什么 XMLHttpRequst 不能跨域请求</h4><blockquote><ul><li>协议、域名和端口号相同的 URL 是同源的；</li><li>同源策略会隔离不同源的 DOM、页面数据和网络通信；</li><li>页面可以引用第三方资源，不过暴露出诸如 XSS 问题，引入内容安全策略 CSP 限制；</li><li>默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，引入跨域资源共享（CORS）进行跨域访问控制；</li></ul></blockquote><h4 id="跨站脚本攻击-XSS：为什么-cookie-中有-httpOnly-属性"><a href="#跨站脚本攻击-XSS：为什么-cookie-中有-httpOnly-属性" class="headerlink" title="跨站脚本攻击 XSS：为什么 cookie 中有 httpOnly 属性"></a>跨站脚本攻击 XSS：为什么 cookie 中有 httpOnly 属性</h4><blockquote><ul><li>XSS 跨站脚本，往 HTML 文件中注入恶意代码，对用户实施攻击；</li><li>XSS 攻击主要有存储型 XSS 攻击、反射型 XSS 攻击和 DOM 的 XSS 攻击；</li><li>阻止 XSS 攻击：服务器对脚本进行过滤或转码，利用 CSP 策略，使用 HttpOnly；</li></ul></blockquote><h4 id="CSRF-攻击：陌生连接不要随便点"><a href="#CSRF-攻击：陌生连接不要随便点" class="headerlink" title="CSRF 攻击：陌生连接不要随便点"></a>CSRF 攻击：陌生连接不要随便点</h4><blockquote><ul><li>CSRF 跨站请求伪造，利用用户的登录状态，通过第三方站点攻击；</li><li>避免 CSRF 攻击：利用 SameSite（三种模式：Strict、Lax、None） 让浏览器禁止第三方站点发起请求携带关键 Cookie；验证请求的来源站点，请求头中的 Referer 和 Origin 属性；利用 CSRF Token；</li></ul></blockquote><h4 id="沙盒：页面和系统之间的隔离墙"><a href="#沙盒：页面和系统之间的隔离墙" class="headerlink" title="沙盒：页面和系统之间的隔离墙"></a>沙盒：页面和系统之间的隔离墙</h4><blockquote><ul><li>浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核石油网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程；</li><li>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程；</li><li>站点隔离（Site Isolation）将同一站点（包含相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行；</li><li>实现站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此无法攻击其他站点；</li></ul></blockquote><h4 id="HTTPS：让数据传输更安全"><a href="#HTTPS：让数据传输更安全" class="headerlink" title="HTTPS：让数据传输更安全"></a>HTTPS：让数据传输更安全</h4><blockquote><ul><li>在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密；</li><li>对称加密：浏览器发送加密套件列表和一个随机数 client-random，服务器会从加密套件中选取一个加密套件，然后生成一个随机数 service-random，返回给浏览器。这样浏览器和服务器都有相同 client-random 和 service-random，再用相同的方法将两者混合生成一个密钥 master secret，双方就可以进行数据加密传输了；</li><li>对称加密缺点：client-random 和 service-random 的过程都是明文，黑客可以拿到协商的加密套件和双方随机数，生成密钥，数据可以被破解；</li><li>非对称加密：浏览器发送加密套件列表给服务器，服务器选择一个加密套件，返回加密套件和公钥，浏览器用公钥加密数据，服务器用私钥解密；</li><li>非对称加密缺点：加密效率太低，不能保证服务器发送给浏览器的数据安全，黑客可以获取公钥；</li><li>对称加密结合非对称加密：浏览器发送对称加密套件列表、非对称加密列表和随机数 client-random 给服务器，服务器生成随机数 service-random，选择加密套件和公钥返回给浏览器，浏览器利用 client-random 和 service-random 计算出 pre-master，然后利用公钥给 pre-master 加密，向服务器发送加密后的数据，服务器用私钥解密出 pre-master 数据，结合 client-random 和 service-random 生成对称密钥，使用对称密钥传输加密数据；</li><li>引入数字证书是为了证明“我就是我”，防止 DNS 被劫持，伪造服务器；</li><li>证书的作用：一个是向浏览器证明服务器的身份，另一个是包含服务器公钥；</li><li>数字签名过程：CA 使用 Hash 函数技术明文信息，得出信息摘要，然后 CA 使用私钥对信息摘要进行加密，加密后的秘文就是数字签名；</li><li>验证数字签名：读取证书明文信息，使用相同 Hash 函数计算得到信息摘要 A，再利用 CA 的公钥解密得到 B，对比 A 和 B，如果一致，则确认证书合法；</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack相关</title>
      <link href="/2023/04/19/Webpack%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/04/19/Webpack%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​        <strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 <em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p></blockquote><h3 id="Webpack构建流程"><a href="#Webpack构建流程" class="headerlink" title="Webpack构建流程"></a>Webpack构建流程</h3><p>webpack 整个庞大的体系大致可以抽象为三方面的知识：</p><blockquote><ol><li><strong>构建的核心流程</strong></li><li><strong>loader 的作用</strong></li><li><strong>plugin 架构与常用套路</strong></li></ol></blockquote><p>三者协作构成 webpack 的主体框架 ：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_arch.png" alt="主题架构"></p><p>​    </p><h4 id="核心流程解析"><a href="#核心流程解析" class="headerlink" title="核心流程解析"></a>核心流程解析</h4><p>​        首先，我们要理解一个点，Webpack 最核心的功能：</p><p>​        也就是将各种类型的资源，包括图片、css、js等，转译、组合、拼接、生成 JS 格式的 bundler 文件。官网首页的动画很形象地表达了这一点：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_bundle.png" alt="bundler"></p><p>这个过程核心完成了 <strong>内容转换 + 资源合并</strong> 两种功能，实现上包含三个阶段：</p><ol><li><p>初始化阶段：</p></li><li><ol><li><strong>初始化参数</strong>：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li><li><strong>创建编译器对象</strong>：用上一步得到的参数创建 <code>Compiler</code> 对象</li><li><strong>初始化编译环境</strong>：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li><li><strong>开始编译</strong>：执行 <code>compiler</code> 对象的 <code>run</code> 方法</li><li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件，调用 <code>compilition.addEntry</code> 将入口文件转换为 <code>dependence</code> 对象</li></ol></li><li><p>构建阶段：</p></li><li><ol><li>**编译模块(make)**：根据 <code>entry</code> 对应的 <code>dependence</code> 创建 <code>module</code> 对象，调用 <code>loader</code> 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><strong>完成模块编译</strong>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 <strong>依赖关系图</strong></li></ol></li><li><p>生成阶段：</p></li><li><ol><li>**输出资源(seal)**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>**写入文件系统(emitAssets)**：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol></li></ol><p>​    </p><p>​        单次构建过程自上而下按顺序执行，下面会展开聊聊细节，在此之前，对上述提及的各类技术名词不太熟悉的同学，可以先看看简介：</p><blockquote><ul><li><code>Entry</code>：编译入口，webpack 编译的起点</li><li><code>Compiler</code>：编译管理器，webpack 启动后会创建 <code>compiler</code> 对象，该对象一直存活知道结束退出</li><li><code>Compilation</code>：单次编辑过程的管理器，比如 <code>watch = true</code> 时，运行过程中只有一个 <code>compiler</code> 但每次文件变更触发重新编译时，都会创建一个新的 <code>compilation</code> 对象</li><li><code>Dependence</code>：依赖对象，webpack 基于该类型记录模块间依赖关系</li><li><code>Module</code>：webpack 内部所有资源都会以“module”对象形式存在，所有关于资源的操作、转译、合并都是以 “module” 为基本单位进行的</li><li><code>Chunk</code>：编译完成准备输出时，webpack 会将 <code>module</code> 按特定的规则组织成一个一个的 <code>chunk</code>，这些 <code>chunk</code> 某种程度上跟最终输出一一对应</li><li><code>Loader</code>：资源内容转换器，其实就是实现从内容 A 转换 B 的转换器</li><li><code>Plugin</code>：webpack构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程</li></ul></blockquote><p>​        webpack 编译过程都是围绕着这些关键对象展开的，更详细完整的信息，可以参考 Webpack 知识图谱 。</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><h5 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h5><p>初始化过程：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_init.png" alt="webpack初始化"></p><blockquote><p> 解 读：</p><ol><li>将 <code>process.args + webpack.config.js</code> 合并成用户配置</li><li>调用 <code>validateSchema</code> 校验配置</li><li>调用 <code>getNormalizedWebpackOptions + applyWebpackOptionsBaseDefaults</code> 合并出最终配置</li><li>创建 <code>compiler</code> 对象</li><li>遍历用户定义的 <code>plugins</code> 集合，执行插件的 <code>apply</code> 方法</li><li>调用 <code>new WebpackOptionsApply().process</code> 方法，加载各种内置插件</li></ol></blockquote><p>​        主要逻辑集中在 <code>WebpackOptionsApply</code> 类，webpack 内置了数百个插件，这些插件并不需要我们手动配置，<code>WebpackOptionsApply</code> 会在初始化阶段根据配置内容动态注入对应的插件，包括：</p><ul><li>注入 <code>EntryOptionPlugin</code> 插件，处理 <code>entry</code> 配置</li><li>根据 <code>devtool</code> 值判断后续用那个插件处理 <code>sourcemap</code>，可选值：<code>EvalSourceMapDevToolPlugin</code>、<code>SourceMapDevToolPlugin</code>、<code>EvalDevToolModulePlugin</code></li><li>注入 <code>RuntimePlugin</code> ，用于根据代码内容动态注入 webpack 运行时</li></ul><p>​        到这里，<code>compiler</code> 实例就被创建出来了，相应的环境参数也预设好了，紧接着开始调用 <code>compiler.compile</code> 函数：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 取自 webpack/lib/compiler.js </span><span class="token function">compile</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">newCompilationParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>beforeCompile<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// ...</span>      <span class="token keyword">const</span> compilation <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">newCompilation</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>make<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span>compilation<span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>finishMake<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span>compilation<span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// ...</span>          process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            compilation<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              compilation<span class="token punctuation">.</span><span class="token function">seal</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>​        Webpack 架构很灵活，但代价是牺牲了源码的直观性，比如说上面说的初始化流程，从创建 <code>compiler</code> 实例到调用 <code>make</code> 钩子.</p><p>逻辑链路很长：</p><blockquote><ul><li>启动 webpack ，触发 <code>lib/webpack.js</code> 文件中 <code>createCompiler</code> 方法</li><li><code>createCompiler</code> 方法内部调用 <code>WebpackOptionsApply</code> 插件</li><li><code>WebpackOptionsApply</code> 定义在 <code>lib/WebpackOptionsApply.js</code> 文件，内部根据 <code>entry</code> 配置决定注入 <code>entry</code> 相关的插件，包括：<code>DllEntryPlugin</code>、<code>DynamicEntryPlugin</code>、<code>EntryPlugin</code>、<code>PrefetchPlugin</code>、<code>ProgressPlugin</code>、<code>ContainerPlugin</code></li><li><code>Entry</code> 相关插件，如 <code>lib/EntryPlugin.js</code> 的 <code>EntryPlugin</code> 监听 <code>compiler.make</code> 钩子</li><li><code>lib/compiler.js</code> 的 <code>compile</code> 函数内调用 <code>this.hooks.make.callAsync</code></li><li>触发 <code>EntryPlugin</code> 的 <code>make</code> 回调，在回调中执行 <code>compilation.addEntry</code> 函数</li><li><code>compilation.addEntry</code> 函数内部经过一坨与主流程无关的 <code>hook</code> 之后，再调用 <code>handleModuleCreate</code> 函数，正式开始构建内容</li></ul></blockquote><h4 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h4><h5 id="基本流程-1"><a href="#基本流程-1" class="headerlink" title="基本流程"></a>基本流程</h5><p>​            构建阶段从 <code>entry</code> 开始递归解析资源与资源的依赖，在 <code>compilation</code> 对象内逐步构建出 <code>module</code> 集合以及 <code>module</code> 之间的依赖关系，核心流程：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_build.png" alt="webpack构建"></p><blockquote><p> 构建阶段从入口文件开始：</p><ol><li>调用 <code>handleModuleCreate</code> ，根据文件类型构建 <code>module</code> 子类</li><li>调用 loader-runner 仓库的 <code>runLoaders</code> 转译 <code>module</code> 内容，通常是从各类资源类型转译为 JavaScript 文本</li><li>调用 acorn 将 JS 文本解析为AST</li><li>遍历 AST，触发各种钩子</li><li>AST 遍历完毕后，调用 <code>module.handleParseResult</code> 处理模块依赖</li><li>对于 <code>module</code> 新增的依赖，调用 <code>handleModuleCreate</code> ，控制流回到第一步</li><li>所有依赖都解析完毕后，构建阶段结束</li></ol></blockquote><p>​    </p><p>​        这个过程中数据流 <code>module =&gt; ast =&gt; dependences =&gt; module</code> ，先转 AST 再从 AST 找依赖。这就要求 <code>loaders</code> 处理完的最后结果必须是可以被 acorn 处理的标准 JavaScript 语法，比如说对于图片，需要从图像二进制转换成类似于 <code>export default &quot;data:image/png;base64,xxx&quot;</code> 这类 base64 格式或者 <code>export default &quot;http://xxx&quot;</code> 这类 url 格式。</p><p>​        <code>compilation</code> 按这个流程递归处理，逐步解析出每个模块的内容以及 <code>module</code> 依赖关系，后续就可以根据这些内容打包输出。</p><h5 id="示例：层级递进"><a href="#示例：层级递进" class="headerlink" title="示例：层级递进"></a>示例：层级递进</h5><p>​    假如有如下图所示的文件依赖树：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_example_1.png" alt="示例：层级递进"></p><p>​        其中 <code>index.js</code> 为 <code>entry</code> 文件，依赖于 a/b 文件；a 依赖于 c/d 文件。初始化编译环境之后，<code>EntryPlugin</code> 根据 <code>entry</code> 配置找到 <code>index.js</code> 文件，调用 <code>compilation.addEntry</code> 函数触发构建流程，构建完毕后内部会生成这样的数据结构：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/example_first_step.png" alt="第一步"></p><p>​        此时得到 <code>module[index.js]</code> 的内容以及对应的依赖对象 <code>dependence[a.js]</code> 、<code>dependence[b.js]</code> 。OK，这就得到下一步的线索：a.js、b.js，根据上面流程图的逻辑继续调用 <code>module[index.js]</code> 的 <code>handleParseResult</code> 函数，继续处理 a.js、b.js 文件，递归上述流程，进一步得到 a、b 模块：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/example_second_step.png" alt="第二步"></p><p>​        从 a.js 模块中又解析到 c.js/d.js 依赖，于是再再继续调用 <code>module[a.js]</code> 的 <code>handleParseResult</code> ，再再递归上述流程：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/example_third_step.png" alt="第三步"></p><p>​        到这里解析完所有模块后，发现没有更多新的依赖，就可以继续推进，进入下一步。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><ul><li><p>Webpack 编译过程会将源码解析为 AST 吗？webpack 与 babel 分别实现了什么？</p><ul><li><p>构建阶段会读取源码，解析为 AST 集合。</p></li><li><p>Webpack 读出 AST 之后仅遍历 AST 集合；babel 则对源码做等价转换</p></li></ul></li><li><p>Webpack 编译过程中，如何识别资源对其他资源的依赖？</p><ul><li>Webpack 遍历 AST 集合过程中，识别 <code>require/ import</code> 之类的导入语句，确定模块对其他资源的依赖关系</li></ul></li><li><p>相对于 grant、gulp 等流式构建工具，为什么 webpack 会被认为是新一代的构建工具？</p><ul><li>Grant、Gulp 仅执行开发者预定义的任务流；而 webpack 则深入处理资源的内容，功能上更强大</li></ul></li></ul></blockquote><ul><li></li></ul><h4 id="生成阶段"><a href="#生成阶段" class="headerlink" title="生成阶段"></a>生成阶段</h4><h5 id="基本流程-2"><a href="#基本流程-2" class="headerlink" title="基本流程"></a>基本流程</h5><p>​        构建阶段围绕 <code>module</code> 展开，生成阶段则围绕 <code>chunks</code> 展开。经过构建阶段之后，webpack 得到足够的模块内容与模块关系信息，接下来开始生成最终资源了。代码层面，就是开始执行 <code>compilation.seal</code> 函数：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 取自 webpack/lib/compiler.js </span><span class="token function">compile</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">newCompilationParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>beforeCompile<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// ...</span>      <span class="token keyword">const</span> compilation <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">newCompilation</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>make<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span>compilation<span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>finishMake<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span>compilation<span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// ...</span>          process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            compilation<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              <span class="token operator">**</span>compilation<span class="token punctuation">.</span>seal<span class="token operator">**</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>​        <code>seal</code> 原意密封、上锁，我个人理解在 webpack 语境下接近于 <strong>“将模块装进蜜罐”</strong> 。<code>seal</code> 函数主要完成从 <code>module</code> 到 <code>chunks</code> 的转化，核心流程：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_seal.png" alt="seal"></p><blockquote><p> 简单梳理一下：</p><ol><li>构建本次编译的 <code>ChunkGraph</code> 对象；</li><li>遍历 <code>compilation.modules</code> 集合，将 <code>module</code> 按 <code>entry/动态引入</code> 的规则分配给不同的 <code>Chunk</code> 对象；</li><li><code>compilation.modules</code> 集合遍历完毕后，得到完整的 <code>chunks</code> 集合对象，调用 <code>createXxxAssets</code> 方法</li><li><code>createXxxAssets</code> 遍历 <code>module/chunk</code> ，调用 <code>compilation.emitAssets</code> 方法将 <code>assets</code> 信息记录到 <code>compilation.assets</code> 对象中</li><li>触发 <code>seal</code> 回调，控制流回到 <code>compiler</code> 对象</li></ol></blockquote><p>​        这一步的关键逻辑是将 <code>module</code> 按规则组织成 <code>chunks</code> ，webpack 内置的 <code>chunk</code> 封装规则比较简单：</p><ul><li><code>entry</code> 及 entry 触达到的模块，组合成一个 <code>chunk</code></li><li>使用动态引入语句引入的模块，各自组合成一个 <code>chunk</code></li></ul><p>​        <code>chunk</code> 是输出的基本单位，默认情况下这些 <code>chunks</code> 与最终输出的资源一一对应，那按上面的规则大致上可以推导出一个 <code>entry</code> 会对应打包出一个资源，而通过动态引入语句引入的模块，也对应会打包出相应的资源，我们来看个示例。</p><h5 id="示例：多入口打包"><a href="#示例：多入口打包" class="headerlink" title="示例：多入口打包"></a>示例：多入口打包</h5><p>假如有这样的配置：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  mode<span class="token punctuation">:</span> <span class="token string">"development"</span><span class="token punctuation">,</span>  context<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">,</span>  entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token string">"./src/index-a.js"</span><span class="token punctuation">,</span>    b<span class="token punctuation">:</span> <span class="token string">"./src/index-b.js"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>    filename<span class="token punctuation">:</span> <span class="token string">"[name].js"</span><span class="token punctuation">,</span>    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"./dist"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  devtool<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  target<span class="token punctuation">:</span> <span class="token string">"web"</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>实例配置中有两个入口，对应的文件结构：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/entry_file_arch.png" alt="入口文件结构"></p><p><code>index-a</code> 依赖于c，且动态引入了 e；<code>index-b</code> 依赖于 c/d 。根据上面说的规则：</p><ul><li><strong><code>entry</code> 及entry触达到的模块，组合成一个 chunk</strong></li><li><strong>使用动态引入语句引入的模块，各自组合成一个 chunk</strong></li></ul><p>生成的 <code>chunks</code> 结构为：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_chunks.png" alt="chunks"></p><p>​        也就是根据依赖关系，<code>chunk[a]</code> 包含了 <code>index-a/c</code> 两个模块；<code>chunk[b]</code> 包含了 <code>c/index-b/d</code> 三个模块；<code>chunk[e-hash]</code> 为动态引入 <code>e</code> 对应的 chunk。</p><p>​        不知道大家注意到没有，<code>chunk[a]</code> 与 <code>chunk[b]</code> 同时包含了 c，这个问题放到具体业务场景可能就是，一个多页面应用，所有页面都依赖于相同的基础库，那么这些所有页面对应的 <code>entry</code> 都会包含有基础库代码，这岂不浪费？为了解决这个问题，webpack 提供了一些插件如 <code>CommonsChunkPlugin</code> 、<code>SplitChunksPlugin</code>，在基本规则之外进一步优化 <code>chunks</code>结构。</p><h5 id="SplitChunksPlugin-的作用"><a href="#SplitChunksPlugin-的作用" class="headerlink" title="SplitChunksPlugin 的作用"></a><code>SplitChunksPlugin</code> 的作用</h5><p>​        <code>SplitChunksPlugin</code> 是 webpack 架构高扩展的一个绝好的示例，我们上面说了 webpack 主流程里面是按 <code>entry / 动态引入</code> 两种情况组织 <code>chunks</code> 的，这必然会引发一些不必要的重复打包，webpack 通过插件的形式解决这个问题。</p><blockquote><p> 回顾 <code>compilation.seal</code> 函数的代码，大致上可以梳理成这么4个步骤：</p><ol><li>遍历 <code>compilation.modules</code> ，记录下模块与 <code>chunk</code> 关系</li><li>触发各种模块优化钩子，这一步优化的主要是模块依赖关系</li><li>遍历 <code>module</code> 构建 chunk 集合</li><li>触发各种优化钩子</li></ol></blockquote><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_hook_step.png" alt="优化流程"></p><p>​        上面 1-3 都是预处理 + chunks 默认规则的实现，不在我们讨论范围，这里重点关注第4个步骤触发的 <code>optimizeChunks</code> 钩子，这个时候已经跑完主流程的逻辑，得到 <code>chunks</code> 集合，<code>SplitChunksPlugin</code> 正是使用这个钩子，分析 <code>chunks</code> 集合的内容，按配置规则增加一些通用的 chunk ：</p><pre class=" language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">SplitChunksPlugin</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span>  <span class="token function">_getCacheGroup</span><span class="token punctuation">(</span>cacheGroupSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span>  <span class="token function">apply</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>thisCompilation<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">"SplitChunksPlugin"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>compilation<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// ...</span>      compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>optimizeChunks<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span>        <span class="token punctuation">{</span>          name<span class="token punctuation">:</span> <span class="token string">"SplitChunksPlugin"</span><span class="token punctuation">,</span>          stage<span class="token punctuation">:</span> STAGE_ADVANCED<span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span>chunks<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// ...</span>        <span class="token punctuation">}</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>​        webpack 插件架构的高扩展性，使得整个编译的主流程是可以固化下来的，分支逻辑和细节需求“外包”出去由第三方实现，这套规则架设起了庞大的 webpack 生态。</p><h5 id="写入文件系统"><a href="#写入文件系统" class="headerlink" title="写入文件系统"></a>写入文件系统</h5><p>​        经过构建阶段后，<code>compilation</code> 会获知资源模块的内容与依赖关系，也就知道“输入”是什么；而经过 <code>seal</code> 阶段处理后， <code>compilation</code> 则获知资源输出的图谱，也就是知道怎么“输出”：哪些模块跟那些模块“绑定”在一起输出到哪里。<code>seal</code> 后大致的数据结构：</p><pre class=" language-js"><code class="language-js">compilation <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  modules<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">/* ... */</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  chunks<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      id<span class="token punctuation">:</span> <span class="token string">"entry name"</span><span class="token punctuation">,</span>      files<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"output file name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      hash<span class="token punctuation">:</span> <span class="token string">"xxx"</span><span class="token punctuation">,</span>      runtime<span class="token punctuation">:</span> <span class="token string">"xxx"</span><span class="token punctuation">,</span>      entryPoint<span class="token punctuation">:</span> <span class="token punctuation">{</span>xxx<span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>​        <code>seal</code> 结束之后，紧接着调用 <code>compiler.emitAssets</code> 函数，函数内部调用 <code>compiler.outputFileSystem.writeFile</code> 方法将 <code>assets</code> 集合写入文件系统。</p><h5 id="资源形态流转"><a href="#资源形态流转" class="headerlink" title="资源形态流转"></a>资源形态流转</h5><p>​        这里结合<strong>资源形态流转</strong>的角度重新考察整个过程，深理解：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_access.png" alt="资源形态流转"></p><ul><li><p><code>compiler.make</code> 阶段：</p></li><li><ul><li><code>entry</code> 文件以 <code>dependence</code> 对象形式加入 <code>compilation</code> 的依赖列表，<code>dependence</code> 对象记录有 <code>entry</code> 的类型、路径等信息</li><li>根据 <code>dependence</code> 调用对应的工厂函数创建 <code>module</code> 对象，之后读入 <code>module</code> 对应的文件内容，调用 <code>loader-runner</code> 对内容做转化，转化结果若有其它依赖则继续读入依赖资源，重复此过程直到所有依赖均被转化为 <code>module</code></li></ul></li><li><p><code>compilation.seal</code> 阶段：</p></li><li><ul><li>遍历 <code>module</code> 集合，根据 <code>entry</code> 配置及引入资源的方式，将 <code>module</code> 分配到不同的 <code>chunk</code></li><li>遍历 <code>chunk</code> 集合，调用 <code>compilation.emitAsset</code> 方法标记 <code>chunk</code> 的输出规则，即转化为 <code>assets</code> 集合</li></ul></li><li><p><code>compiler.emitAssets</code> 阶段：</p></li><li><ul><li>将 <code>assets</code> 写入文件系统</li></ul></li><li></li></ul><h5 id="Plugin-解析"><a href="#Plugin-解析" class="headerlink" title="Plugin 解析"></a>Plugin 解析</h5><p>​        网上不少资料将 webpack 的插件架构归类为“事件/订阅”模式，我认为这种归纳有失偏颇。订阅模式是一种松耦合架构，发布器只是在特定时机发布事件消息，订阅者并不或者很少与事件直接发生交互。</p><p>​        举例来说，我们平常在使用 HTML 事件的时候很多时候只是在这个时机触发业务逻辑，很少调用上下文操作。</p><p>​        而 webpack 的钩子体系是一种强耦合架构，它在特定时机触发钩子时会附带上足够的上下文信息，插件定义的钩子回调中，能也只能与这些上下文背后的数据结构、接口交互产生 <strong>side effect</strong>，进而影响到编译状态和后续流程。</p><p>学习插件架构，需要理解三个关键问题：</p><h5 id="What-什么是插件"><a href="#What-什么是插件" class="headerlink" title="What: 什么是插件"></a>What: 什么是插件</h5><p>从形态上看，插件通常是一个带有 <code>apply</code> 函数的类：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">SomePlugin</span> <span class="token punctuation">{</span>    <span class="token function">apply</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>​        <code>apply</code> 函数运行时会得到参数 <code>compiler</code> ，以此为起点可以调用 <code>hook</code> 对象注册各种钩子回调。</p><p>​        例如：<code>compiler.hooks.make.tapAsync</code> ，这里面 <code>make</code> 是钩子名称，<code>tapAsync</code> 定义了钩子的调用方式，webpack 的插件架构基于这种模式构建而成，插件开发者可以使用这种模式在钩子回调中，插入特定代码。</p><p>​        webpack 各种内置对象都带有 <code>hooks</code> 属性，比如 <code>compilation</code> 对象：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">SomePlugin</span> <span class="token punctuation">{</span>    <span class="token function">apply</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>thisCompilation<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'SomePlugin'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>compilation<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>optimizeChunkAssets<span class="token punctuation">.</span><span class="token function">tapAsync</span><span class="token punctuation">(</span><span class="token string">'SomePlugin'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>钩子的核心逻辑定义在 Tapable 仓库，内部定义了如下类型的钩子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span>        SyncHook<span class="token punctuation">,</span>        SyncBailHook<span class="token punctuation">,</span>        SyncWaterfallHook<span class="token punctuation">,</span>        SyncLoopHook<span class="token punctuation">,</span>        AsyncParallelHook<span class="token punctuation">,</span>        AsyncParallelBailHook<span class="token punctuation">,</span>        AsyncSeriesHook<span class="token punctuation">,</span>        AsyncSeriesBailHook<span class="token punctuation">,</span>        AsyncSeriesWaterfallHook <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"tapable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="When-什么时候会触发钩子"><a href="#When-什么时候会触发钩子" class="headerlink" title="When: 什么时候会触发钩子"></a>When: 什么时候会触发钩子</h5><p>​        了解 webpack 插件的基本形态之后，接下来需要弄清楚一个问题：webpack 会在什么时间节点触发什么钩子？这一块我认为是知识量最大的一部分，毕竟源码里面有237个钩子，但官网只介绍了不到100个，且官网对每个钩子的说明都太简短，就我个人而言看完并没有太大收获，所以有必要展开聊一下这个话题。先看几个例子：</p><ul><li><p><code>compiler.hooks.compilation</code> ：</p></li><li><ul><li>时机：启动编译创建出 compilation 对象后触发</li><li>参数：当前编译的 compilation 对象</li><li>示例：很多插件基于此事件获取 compilation 实例</li></ul></li><li><p><code>compiler.hooks.make</code>：</p></li><li><ul><li>时机：正式开始编译时触发</li><li>参数：同样是当前编译的 <code>compilation</code> 对象</li><li>示例：webpack 内置的 <code>EntryPlugin</code> 基于此钩子实现 <code>entry</code> 模块的初始化</li></ul></li><li><p><code>compilation.hooks.optimizeChunks</code> ：</p></li><li><ul><li>时机：<code>seal</code> 函数中，<code>chunk</code> 集合构建完毕后触发</li><li>参数：<code>chunks</code> 集合与 <code>chunkGroups</code> 集合</li><li>示例：<code>SplitChunksPlugin</code> 插件基于此钩子实现 <code>chunk</code> 拆分优化</li></ul></li><li><p><code>compiler.hooks.done</code>：</p></li><li><ul><li>时机：编译完成后触发</li><li>参数：<code>stats</code> 对象，包含编译过程中的各类统计信息</li><li>示例：<code>webpack-bundle-analyzer</code> 插件基于此钩子实现打包分析</li></ul></li></ul><h6 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h6><p>​        触发时机与 webpack 工作过程紧密相关，大体上从启动到结束，<code>compiler</code> 对象逐次触发如下钩子：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_compiler_hooks.png" alt="compiler hook触发流程"></p><p>而 <code>compilation</code> 对象逐次触发：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_compilation_obj.png" alt="compilation 对象触发流程"></p><p>​        所以，理解清楚前面说的 webpack 工作的主流程，基本上就可以捋清楚“什么时候会触发什么钩子”。</p><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>​        传递参数与具体的钩子强相关，官网对这方面没有做出进一步解释，我的做法是直接在源码里面搜索调用语句。</p><p>​        例如对于 <code>compilation.hooks.optimizeTree</code> ，可以在 webpack 源码中搜索 <code>hooks.optimizeTree.call</code> 关键字，就可以找到调用代码：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// lib/compilation.js#2297</span><span class="token keyword">this</span><span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>optimizeTree<span class="token punctuation">.</span><span class="token function">callAsync</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>chunks<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>modules<span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​        结合代码所在的上下文，可以判断出此时传递的是经过优化的 <code>chunks</code> 及 <code>modules</code> 集合。</p><h6 id="找到示例"><a href="#找到示例" class="headerlink" title="找到示例"></a>找到示例</h6><p>​        Webpack 的钩子复杂程度不一，我认为最好的学习方法还是带着目的去查询其他插件中如何使用这些钩子。例如，在 <code>compilation.seal</code> 函数内部有 <code>optimizeModules</code> 和 <code>afterOptimizeModules</code> 这一对看起来很对偶的钩子，<code>optimizeModules</code> 从字面上可以理解为用于优化已经编译出的 <code>modules</code> ，那 <code>afterOptimizeModules</code> 呢？</p><p>​    从 webpack 源码中唯一搜索到的用途是 <code>ProgressPlugin</code> ，大体上逻辑如下：</p><pre class=" language-js"><code class="language-js">compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>afterOptimizeModules<span class="token punctuation">.</span><span class="token function">intercept</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"ProgressPlugin"</span><span class="token punctuation">,</span>  <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">handler</span><span class="token punctuation">(</span>percentage<span class="token punctuation">,</span> <span class="token string">"sealing"</span><span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    progressReporters<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>compiler<span class="token punctuation">,</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">handler</span><span class="token punctuation">(</span>percentage<span class="token punctuation">,</span> <span class="token string">"sealing"</span><span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">handler</span><span class="token punctuation">(</span>percentage<span class="token punctuation">,</span> <span class="token string">"sealing"</span><span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">handler</span><span class="token punctuation">(</span>percentage<span class="token punctuation">,</span> <span class="token string">"sealing"</span><span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">tap</span><span class="token punctuation">(</span>tap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// p is percentage from 0 to 1</span>    <span class="token comment" spellcheck="true">// args is any number of messages in a hierarchical matter</span>    progressReporters<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>compilation<span class="token punctuation">.</span>compiler<span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">handler</span><span class="token punctuation">(</span>percentage<span class="token punctuation">,</span> <span class="token string">"sealing"</span><span class="token punctuation">,</span> title<span class="token punctuation">,</span> tap<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">handler</span><span class="token punctuation">(</span>percentage<span class="token punctuation">,</span> <span class="token string">"sealing"</span><span class="token punctuation">,</span> title<span class="token punctuation">,</span> tap<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​        基本上可以猜测出，<code>afterOptimizeModules</code> 的设计初衷就是用于通知优化行为的结束。</p><p>​        <code>apply</code> 虽然是一个函数，但是从设计上就只有输入，webpack 不 care 输出，所以在插件中只能通过调用类型实体的各种方法来或者更改实体的配置信息，变更编译行为。例如：</p><ul><li>compilation.addModule ：添加模块，可以在原有的 module 构建规则之外，添加自定义模块</li><li>compilation.emitAsset：直译是“提交资产”，功能可以理解将内容写入到特定路径</li></ul><h5 id="How-如何影响编译状态"><a href="#How-如何影响编译状态" class="headerlink" title="How: 如何影响编译状态"></a>How: 如何影响编译状态</h5><p>​        解决上述两个问题之后，我们就能理解“如何将特定逻辑插入 webpack 编译过程”，接下来才是重点 —— 如何影响编译状态？</p><p>​        强调一下，webpack 的插件体系与平常所见的 订阅/发布 模式差别很大，是一种非常强耦合的设计，hooks 回调由 webpack 决定何时，以何种方式执行；</p><p>​        而在 hooks 回调内部可以通过修改状态、调用上下文 api 等方式对 webpack 产生 <strong>side effect</strong>。</p><p>比如，<code>EntryPlugin</code> 插件：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">EntryPlugin</span> <span class="token punctuation">{</span>  <span class="token function">apply</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>compilation<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span>      <span class="token string">"EntryPlugin"</span><span class="token punctuation">,</span>      <span class="token punctuation">(</span>compilation<span class="token punctuation">,</span> <span class="token punctuation">{</span> normalModuleFactory <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        compilation<span class="token punctuation">.</span>dependencyFactories<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>          EntryDependency<span class="token punctuation">,</span>          normalModuleFactory        <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>make<span class="token punctuation">.</span><span class="token function">tapAsync</span><span class="token punctuation">(</span><span class="token string">"EntryPlugin"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>compilation<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> <span class="token punctuation">{</span> entry<span class="token punctuation">,</span> options<span class="token punctuation">,</span> context <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> dep <span class="token operator">=</span> EntryPlugin<span class="token punctuation">.</span><span class="token function">createDependency</span><span class="token punctuation">(</span>entry<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>      compilation<span class="token punctuation">.</span><span class="token function">addEntry</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> dep<span class="token punctuation">,</span> options<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">callback</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码片段调用了两个影响 <code>compilation</code> 对象状态的接口：</p><ul><li><code>compilation.dependencyFactories.set</code></li><li><code>compilation.addEntry</code></li></ul><p>​        操作的具体含义可以先忽略，这里要理解的重点是，webpack 会将上下文信息以参数或 <code>this</code> (compiler 对象) 形式传递给钩子回调，在回调中可以调用上下文对象的方法或者直接修改上下文对象属性的方式，对原定的流程产生 side effect。</p><p>​        所以想纯熟地编写插件，除了要理解调用时机，还需要了解我们可以用哪一些api，例如：</p><ul><li><code>compilation.addModule</code>：添加模块，可以在原有的 <code>module</code> 构建规则之外，添加自定义模块</li><li><code>compilation.emitAsset</code>：直译是“提交资产”，功能可以理解将内容写入到特定路径</li><li><code>compilation.addEntry</code>：添加入口，功能上与直接定义 <code>entry</code> 配置相同</li><li><code>module.addError</code>：添加编译错误信息</li><li>…</li></ul><h6 id="Loader-介绍"><a href="#Loader-介绍" class="headerlink" title="Loader 介绍"></a>Loader 介绍</h6><p>​        Loader 的作用和实现比较简单，容易理解，所以简单介绍一下就行了。回顾 loader 在编译流程中的生效的位置：</p><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_loader.png" alt="Loader"></p><p>​        流程图中， <code>runLoaders</code> 会调用用户所配置的 loader 集合读取、转译资源，此前的内容可以千奇百怪，但转译之后理论上应该输出标准 JavaScript 文本或者 AST 对象，webpack 才能继续处理模块依赖。</p><p>​        理解了这个基本逻辑之后，loader 的职责就比较清晰了，不外乎是将内容 A 转化为内容 B，但是在具体用法层面还挺多讲究的，有 pitch、pre、post、inline 等概念用于应对各种场景。</p><p>​        为了帮助理解，这里补充一个示例：Webpack 案例 – vue-loader 原理分析。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/../images/Webpack%E7%9B%B8%E5%85%B3/webpack_end.png" alt="小结"></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="源码阅读技巧"><a href="#源码阅读技巧" class="headerlink" title="源码阅读技巧"></a>源码阅读技巧</h5><ul><li><p><strong>避重就轻：</strong>挑软柿子捏，比如初始化过程虽然绕，但是相对来说是概念最少、逻辑最清晰的，那从这里入手摸清整个工作过程，可以习得 webpack 的一些通用套路，例如钩子的设计与作用、编码规则、命名习惯、内置插件的加载逻辑等，相当于先入了个门</p></li><li><p><strong>学会调试：</strong>多用 <code>ndb</code> 单点调试功能追踪程序的运行，虽然 node 的调试有很多种方法，但是我个人更推荐 <code>ndb</code> ，灵活、简单，配合 <code>debugger</code> 语句是大杀器</p></li><li><p><strong>理解架构：</strong>某种程度上可以将 webpack 架构简化为 <code>compiler + compilation + plugins</code> ，webpack 运行过程中只会有一个 <code>compiler</code> ；而每次编译 —— 包括调用 <code>compiler.run</code> 函数或者 <code>watch = true</code> 时文件发生变更，都会创建一个 <code>compilation</code> 对象。理解这三个核心对象的设计、职责、协作，差不多就能理解 webpack 的核心逻辑了</p></li><li><p><strong>抓大放小：</strong> plugin 的关键是“钩子”，我建议战略上重视，战术上忽视！钩子毕竟是 webpack 的关键概念，是整个插件机制的根基，学习 webpack 根本不可能绕过钩子，但是相应的逻辑跳转实在太绕太不直观了，看代码的时候一直揪着这个点的话，复杂性会剧增，我的经验是：</p></li><li><ul><li>认真看一下 tapable 仓库的文档，或者粗略看一下 <code>tapable</code> 的源码，理解同步钩子、异步钩子、promise 钩子、串行钩子、并行钩子等概念，对 <code>tapable</code> 提供的事件模型有一个较为精细的认知，这叫战略上重视</li><li>遇到不懂的钩子别慌，我的经验我连这个类都不清楚干啥的，要去理解这些钩子实在太难了，不如先略过钩子本身的含义，去看那些插件用到了它，然后到插件哪里去加 <code>debugger</code> 语句单点调试，等你缕清后续逻辑的时候，大概率你也知道钩子的含义了，这叫战术上忽视</li></ul></li><li><p><strong>保持好奇心：</strong>学习过程保持旺盛的好奇心和韧性，善于 &amp; 敢于提出问题，然后基于源码和社区资料去总结出自己的答案，问题可能会很多，比如：</p></li><li><ul><li>loader 为什么要设计 pre、pitch、post、inline？</li><li><code>compilation.seal</code> 函数内部设计了很多优化型的钩子，为什么需要区分的这么细？webpack 设计者对不同钩子有什么预期？</li><li>为什么需要那么多 <code>module</code> 子类？这些子类分别在什么时候被使用？</li></ul></li></ul><h5 id="Module-与-Module-子类"><a href="#Module-与-Module-子类" class="headerlink" title="Module 与 Module 子类"></a><code>Module</code> 与 <code>Module</code> 子类</h5><p>​        从上文可以看出，webpack 构建阶段的核心流程基本上都围绕着 <code>module</code> 展开，相信接触过、用过 Webpack 的读者对 <code>module</code> 应该已经有一个感性认知，但是实现上 <code>module</code> 的逻辑是非常复杂繁重的。</p><p>​        以 <a href="mailto:&#119;&#x65;&#98;&#112;&#x61;&#x63;&#x6b;&#64;&#x35;&#46;&#x32;&#x36;&#46;&#51;">&#119;&#x65;&#98;&#112;&#x61;&#x63;&#x6b;&#64;&#x35;&#46;&#x32;&#x36;&#46;&#51;</a> 为例，直接或间接继承自 <code>Module</code> (<code>webpack/lib/Module.js</code> 文件) 的子类有54个：</p><p>​        要一个一个捋清楚这些类的作用实在太累了，我们需要抓住本质：<code>module</code> 的作用是什么？</p><p>​        <code>module</code> 是 webpack 资源处理的基本单位，可以认为 webpack 对资源的路径解析、读入、转译、分析、打包输出，所有操作都是围绕着 module 展开的。有很多文章会说 <strong>module = 文件</strong>， 其实这种说法并不准确，比如子类 <code>AsyncModuleRuntimeModule</code> 就只是一段内置的代码，是一种资源而不能简单等价于实际文件。</p><p>​        Webpack 扩展性很强，包括模块的处理逻辑上，比如说入口文件是一个普通的 js，此时首先创建 NormalModule 对象，在解析 AST 时发现这个文件里还包含了异步加载语句。</p><p>​        例如 <code>requere.ensure</code> ，那么相应地会创建 <code>AsyncModuleRuntimeModule</code> 模块，注入异步加载的模板代码。上面类图的 54 个 module 子类都是为适配各种场景设计的。</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><h3 id="webpack的-loader和plugin介绍，css-loader，style-loader的区别"><a href="#webpack的-loader和plugin介绍，css-loader，style-loader的区别" class="headerlink" title="webpack的 loader和plugin介绍，css-loader，style-loader的区别"></a><strong>webpack的 loader和plugin介绍，css-loader，style-loader的区别</strong></h3><blockquote><p><strong>loader</strong> 它就是一个转换器，将A文件进行编译形成B文件，</p><p><strong>plugin</strong> ，它就是一个扩展器，来操作的是文件，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，会监听webpack打包过程中的某些节点（run, build-module, program）</p><p><strong>Babel</strong> 能把ES6/ES7的代码转化成指定浏览器能支持的代码。</p><p>css-loader 的作用是把 css文件进行转码style-loader: 使用 &lt; style &gt; 将css-loader内部样式注入到我们的HTML页面</p><p>先使用 css-loader转码，然后再使用 style-loader插入到文件</p></blockquote><h3 id="有哪些常见的Loader？你用过哪些Loader？"><a href="#有哪些常见的Loader？你用过哪些Loader？" class="headerlink" title="有哪些常见的Loader？你用过哪些Loader？"></a>有哪些常见的Loader？你用过哪些Loader？</h3><p>Webpack 中有许多常见的 Loader，它们用于处理不同类型的文件并将它们转换为 JavaScript 模块，以供 Webpack 打包。以下是一些常见的 Loader 及其用途：</p><blockquote><ol><li>css-loader<ul><li>用途：加载 CSS 文件，并将其转换为 JavaScript 模块。它支持模块化、压缩、文件导入等特性。</li><li>使用经验：通常与 <code>style-loader</code> 配合使用，将 CSS 样式插入到 DOM 中。</li></ul></li><li>style-loader<ul><li>用途：将 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li><li>使用经验：常常与 <code>css-loader</code> 一起使用，形成 <code>style-loader!css-loader</code> 的组合，用于在 JavaScript 中直接处理 CSS。</li></ul></li><li>less-loader和sass-loader<ul><li>用途：分别用于将 Less 和 Sass/Scss 文件转换为 CSS 文件。</li><li>使用经验：当项目中使用了 Less 或 Sass 语法时，需要这些 Loader 将它们转换为标准的 CSS，然后再使用 <code>css-loader</code> 和 <code>style-loader</code> 进行处理。</li></ul></li><li>file-loader<ul><li>用途：把文件输出到一个文件夹中，并在代码中通过相对 URL 去引用输出的文件。</li><li>使用经验：常用于处理图片、字体等文件，确保它们在构建后能够被正确地引用。</li></ul></li><li>url-loader<ul><li>用途：和 <code>file-loader</code> 类似，但能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去。</li><li>使用经验：这有助于减少小文件的 HTTP 请求数量，提高页面加载性能。</li></ul></li><li>babel-loader<ul><li>用途：将 ES6、ES7 等现代 JavaScript 语法转换为向后兼容的 JavaScript 版本（如 ES5），以便在旧版浏览器中运行。</li><li>使用经验：几乎在所有的现代前端项目中都会用到，是处理 JavaScript 代码不可或缺的工具。</li></ul></li><li>eslint-loader<ul><li>用途：通过 ESLint 检查 JavaScript 代码，确保代码符合一定的规范和质量标准。</li><li>使用经验：在开发过程中使用，可以帮助开发者发现并修复潜在的代码问题，提高代码质量。</li></ul></li><li>svg-loader<ul><li>用途：将 SVG 图片文件转换为 JavaScript 模块，以便在项目中更方便地使用。</li><li>使用经验：在处理 SVG 图标等资源时，使用 <code>svg-loader</code> 可以将 SVG 转换为组件，实现更灵活的图标使用方式。</li></ul></li></ol></blockquote><p>我个人在项目中使用过上述的大部分 Loader，特别是 <code>css-loader</code>、<code>style-loader</code>、<code>less-loader</code>、<code>sass-loader</code>、<code>file-loader</code>、<code>url-loader</code> 和 <code>babel-loader</code>。它们在构建前端项目时提供了很大的便利性和灵活性。</p><h3 id="Webpack-怎么匹配到对应的loader的？"><a href="#Webpack-怎么匹配到对应的loader的？" class="headerlink" title="Webpack 怎么匹配到对应的loader的？"></a>Webpack 怎么匹配到对应的loader的？</h3><p>Webpack 通过配置文件（通常是 <code>webpack.config.js</code> 或其他类型的配置文件）中的 <code>module.rules</code> 数组来匹配和决定使用哪个 loader 来处理特定的文件。每个 <code>rule</code> 对象通常包含一个或多个条件（<code>test</code>、<code>include</code>、<code>exclude</code>、<code>resource</code>、<code>issuer</code> 等）和一个 <code>use</code> 数组，其中 <code>use</code> 数组定义了应当应用于匹配文件的 loader。</p><p>下面是一个简单的例子，展示了如何配置 Webpack 以使用 <code>babel-loader</code> 来处理 <code>.js</code> 和 <code>.jsx</code> 文件：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...  </span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>      rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          test<span class="token punctuation">:</span> <span class="token regex">/\.(js|jsx)$/</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 匹配以 .js 或 .jsx 结尾的文件  </span>        exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 排除 node_modules 目录下的文件  </span>        use<span class="token punctuation">:</span> <span class="token punctuation">{</span>            loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 使用 babel-loader  </span>          options<span class="token punctuation">:</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 这里可以配置 babel-loader 的选项  </span>            presets<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'@babel/preset-env'</span><span class="token punctuation">,</span> <span class="token string">'@babel/preset-react'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 可以添加更多规则...  </span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// ...  </span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>在这个例子中，<code>test</code> 属性是一个正则表达式，用于匹配文件的路径。Webpack 会遍历项目中的所有文件，并检查文件的路径是否与 <code>test</code> 属性中的正则表达式匹配。如果匹配，则应用该 <code>rule</code> 中的 <code>use</code> 数组指定的 loader。</p><p><code>exclude</code> 属性是另一个可选的正则表达式，用于排除某些文件。在这个例子中，我们排除了 <code>node_modules</code> 目录下的所有文件，因为通常我们不需要对这些文件进行转换。</p><p><code>use</code> 属性是一个数组，可以包含一个或多个 loader。在这个例子中，我们只使用了一个 loader（<code>babel-loader</code>），但也可以指定多个 loader，它们会按照数组中的顺序从右到左应用（即最后一个 loader 最先执行）。</p><p>如果文件匹配了多个 <code>rule</code>，Webpack 会按照 <code>rules</code> 数组中的顺序应用第一个匹配的 <code>rule</code>。因此，通常会将更具体的规则放在数组的前面，以便它们能够优先匹配。</p><p>除了 <code>test</code>、<code>include</code> 和 <code>exclude</code> 之外，还可以使用其他条件来匹配文件，如 <code>resource</code>（匹配文件的绝对路径）和 <code>issuer</code>（匹配引发加载请求的文件路径）。这些条件提供了更细粒度的控制，以便更精确地指定哪些文件应该应用哪些 loader。</p><h3 id="在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"><a href="#在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？" class="headerlink" title="在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"></a>在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？</h3><p>在实际工程中，当 Webpack 配置文件变得庞大且复杂时，确保各个 loader 按照预想方式工作确实是一个挑战。以下是一些建议，可以帮助你管理和维护配置文件，确保 loader 的正常工作：</p><blockquote><ol><li><strong>模块化配置</strong>：将配置文件拆分成多个小的、可重用的模块。每个模块负责一部分配置，如 loader 配置、插件配置、输出配置等。这样可以使配置文件更加清晰，也更容易维护和扩展。</li><li><strong>注释和文档</strong>：在配置文件中添加足够的注释和文档，解释每个 loader 的用途、配置选项以及为何选择这些选项。这有助于其他开发者理解你的配置，并在需要时进行修改。</li><li><strong>使用默认值和预设</strong>：对于常用的 loader 配置，可以使用默认值或预设来减少冗余代码。例如，对于 <code>babel-loader</code>，你可以使用 <code>@babel/preset-env</code> 预设来自动确定需要哪些转换和插件。</li><li><strong>验证和测试</strong>：使用 Webpack 的验证工具（如 <code>webpack-merge</code> 和 <code>webpack-cli</code> 的 <code>--validate</code> 选项）来检查配置文件的正确性。此外，编写针对 Webpack 构建的测试用例也是一个好主意，以确保构建过程符合预期。</li><li>**持续集成和持续部署 (CI/CD)**：将 Webpack 构建集成到 CI/CD 流程中，以确保每次代码更改时都会进行构建和测试。这有助于及早发现配置问题或构建失败，并防止它们被合并到主分支中。</li><li><strong>代码审查</strong>：在提交代码更改之前，让其他开发者对你的配置文件进行代码审查。这可以帮助你发现潜在的问题或改进点，并确保配置文件的质量。</li><li><strong>学习和保持更新</strong>：Webpack 和相关的 loader、插件都在不断发展和更新。定期查看官方文档、博客文章和社区讨论，了解最新的功能和最佳实践，并将它们应用到你的项目中。</li><li><strong>使用工具进行性能优化</strong>：对于大型项目，Webpack 的构建性能可能会成为瓶颈。使用工具（如 <code>webpack-bundle-analyzer</code>）来分析构建输出，找出性能瓶颈并进行优化。同时，确保你的 loader 和插件都是最新的，并且已经进行了适当的性能优化。</li></ol></blockquote><p>通过遵循这些建议，你可以更好地管理和维护 Webpack 配置文件，确保各个 loader 按照预想方式工作。</p><h3 id="简单描述一下编写loader的思路？"><a href="#简单描述一下编写loader的思路？" class="headerlink" title="简单描述一下编写loader的思路？"></a>简单描述一下编写loader的思路？</h3><p>编写 Webpack loader 的思路主要围绕将某种类型的文件转换为 Webpack 能够理解的模块。以下是一个简单的步骤描述，用于指导你编写 loader：</p><blockquote><ol><li>确定需求<ul><li>首先，明确你想要处理的文件类型（例如，<code>.txt</code> 文件、<code>.csv</code> 数据文件、自定义模板文件等）。</li><li>确定这些文件转换后的预期输出格式（通常是 JavaScript 模块）。</li></ul></li><li>创建 loader 文件<ul><li>创建一个新的 JavaScript 文件，这个文件就是你的 loader。</li><li>确保 loader 文件导出一个函数，这个函数接收源文件的内容作为输入。</li></ul></li><li>处理输入内容<ul><li>在 loader 函数中，读取传入的源文件内容（可能是一个字符串或 Buffer）。</li><li>根据文件类型，执行必要的解析、转换或操作。</li></ul></li><li>生成输出<ul><li>将处理后的内容转换为一个 JavaScript 模块。这通常意味着将内容封装在一个 <code>module.exports</code> 语句中，以便 Webpack 可以将其视为一个模块。</li><li>如果需要，你还可以添加额外的逻辑来导出多个变量或函数。</li></ul></li><li>添加依赖和错误处理<ul><li>如果 loader 需要额外的依赖项（如其他 npm 包），请确保在 loader 文件中正确地引入它们。</li><li>添加适当的错误处理逻辑，以便在输入无效或处理过程中发生错误时能够优雅地处理。</li></ul></li><li>测试 loader<ul><li>编写测试用例来验证 loader 的功能。这可以包括单元测试、集成测试或端到端测试。</li><li>使用模拟输入和期望输出来验证 loader 是否按预期工作。</li></ul></li><li>配置 Webpack<ul><li>在 Webpack 配置文件中，使用 <code>module.rules</code> 数组来指定你的 loader。</li><li>设置 <code>test</code> 属性以匹配你想要 loader 处理的文件类型。</li><li>使用 <code>use</code> 属性来指定你的 loader（可能需要包含 loader 的路径或名称）。</li></ul></li><li>优化和调试<ul><li>如果 loader 的性能不佳或存在其他问题，请考虑进行优化和调试。</li><li>使用 Webpack 的性能分析工具（如 <code>webpack-bundle-analyzer</code>）来检查 loader 的性能。</li><li>使用 <code>console.log</code>、调试器或其他调试工具来跟踪和解决问题。</li></ul></li><li>文档和发布<ul><li>为你的 loader 编写文档，解释其用途、配置选项和使用方法。</li><li>将 loader 发布到 npm 或其他代码托管平台，以便其他开发人员可以使用它。</li></ul></li></ol></blockquote><p>请注意，以上步骤是一个简化的概述，具体实现可能会因你的具体需求和 loader 的复杂性而有所不同。在编写 loader 时，建议参考 Webpack 的官方文档和其他现有的 loader 实现，以获取更详细的信息和最佳实践。</p><h3 id="Webpack中babel-loader都做了哪些事情？"><a href="#Webpack中babel-loader都做了哪些事情？" class="headerlink" title="Webpack中babel-loader都做了哪些事情？"></a>Webpack中babel-loader都做了哪些事情？</h3><p>在Webpack中，babel-loader的主要作用是<strong>在Webpack打包时，将ES6（以及其他更高级别的JavaScript语法，如ES7、JSX等）的代码转换成ES5版本的代码</strong>。这是为了确保浏览器能够正确执行代码，因为尽管现代浏览器大多支持ES6语法，但仍有一些旧版浏览器或特定环境可能不支持。</p><p>babel-loader的工作原理是通过Babel这个JavaScript编译器来实现代码转换的。Babel是一个广泛使用的工具，可以将现代JavaScript代码转换成向后兼容的版本。babel-loader则是Webpack的一个插件，它会在Webpack打包过程中自动使用Babel工具对加载的JavaScript文件进行转换。</p><p>除了将ES6代码转换为ES5外，babel-loader还可以用来转换其他现代JavaScript特性，如箭头函数、模板字符串、解构赋值等。为了完成这些转换，babel-loader通常会与一些Babel插件和预设（preset）一起使用，如<code>@babel/preset-env</code>、<code>@babel/preset-react</code>等。这些插件和预设提供了各种转换规则和选项，可以根据需要进行配置。</p><p>在Webpack配置文件中，babel-loader通常会被配置在<code>module.rules</code>数组中，通过<code>test</code>属性指定需要转换的文件类型（如<code>.js</code>、<code>.jsx</code>等），然后通过<code>use</code>属性指定使用babel-loader进行转换。同时，还可以通过<code>options</code>属性为babel-loader传递配置选项，以指定需要使用的Babel插件和预设等。</p><p>总的来说，babel-loader在Webpack中扮演了一个重要的角色，它使得开发者能够使用现代JavaScript语法编写代码，同时确保这些代码能够在各种浏览器和环境中正常运行。</p><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><h3 id="有哪些常见的Plugin？你用过哪些Plugin？"><a href="#有哪些常见的Plugin？你用过哪些Plugin？" class="headerlink" title="有哪些常见的Plugin？你用过哪些Plugin？"></a>有哪些常见的Plugin？你用过哪些Plugin？</h3><p>Webpack 有许多常见的插件，它们各自用于不同的构建和优化任务。以下是一些常见的 Webpack 插件及其用途：</p><blockquote><ol><li><p>HtmlWebpackPlugin</p><p>：</p><ul><li>用途：简化 HTML 文件的创建，自动引入打包后的 JS、CSS 文件等。</li><li>特性：可以生成一个或多个 HTML 文件，并注入 CSS 和 JS 资源。</li><li>备注：这是我常用的插件之一，因为它能自动处理 HTML 文件的依赖关系。</li></ul></li><li><p>CleanWebpackPlugin</p><p>：</p><ul><li>用途：在每次构建前清理输出目录（如 <code>dist</code> 目录），确保构建结果的纯净性。</li><li>特性：删除指定的文件或文件夹。</li><li>备注：我也经常使用这个插件，因为它可以确保构建过程不受之前构建结果的影响。</li></ul></li><li><p>MiniCssExtractPlugin</p><p>：</p><ul><li>用途：将 CSS 提取到单独的文件中，而不是嵌入到 JS 文件中。</li><li>特性：支持按需加载和代码分割。</li><li>备注：这个插件在 Webpack 4 之后替代了 <code>extract-text-webpack-plugin</code>，是优化 CSS 加载的一个好选择。</li></ul></li><li><p>TerserWebpackPlugin</p><p>：</p><ul><li>用途：压缩和混淆 JavaScript 代码。</li><li>特性：支持 ES6+ 语法，提供更好的压缩效果。</li><li>备注：在 Webpack 4 之后，<code>UglifyJsPlugin</code> 被 <code>TerserWebpackPlugin</code> 替代，因为它对 ES6+ 有更好的支持。</li></ul></li><li><p>DefinePlugin</p><p>：</p><ul><li>用途：在编译时创建配置的全局常量。</li><li>特性：允许你在代码中直接使用这些常量，而不需要通过 <code>require</code> 或 <code>import</code> 引入。</li><li>备注：这个插件在配置环境变量时非常有用。</li></ul></li><li><p>CompressionWebpackPlugin</p><p>：</p><ul><li>用途：对生成的资源文件进行压缩，如使用 gzip 或 Brotli 算法。</li><li>特性：可以显著减小文件大小，提高网页加载速度。</li><li>备注：这个插件在构建生产环境的包时非常有用。</li></ul></li><li><p>CopyWebpackPlugin</p><p>：</p><ul><li>用途：复制文件或目录到构建目录。</li><li>特性：可以复制静态资源文件，如图片、字体等。</li><li>备注：在需要复制非代码文件到构建目录时，这个插件很有用。</li></ul></li><li><p>ProvidePlugin</p><p>：</p><ul><li>用途：自动加载模块，并在所有模块中可用。</li><li>特性：如上面的例子所示，它可以自动为所有模块提供 jQuery 等库。</li><li>备注：这个插件在需要全局引入某个库时很有用。</li></ul></li><li><p>BundleAnalyzerPlugin</p><p>：</p><ul><li>用途：可视化 Webpack 打包后的文件大小和组成。</li><li>特性：生成一个交互式的树状图，展示各个模块的大小和依赖关系。</li><li>备注：这个插件在分析和优化打包结果时非常有用。</li></ul></li></ol></blockquote><p>除了上述插件外，Webpack 还有许多其他插件，用于实现不同的功能和优化任务。我个人使用过上述的大部分插件，特别是 HtmlWebpackPlugin、CleanWebpackPlugin、MiniCssExtractPlugin 和 TerserWebpackPlugin，它们在我的日常开发工作中非常有用。</p><h3 id="如何编写一个-Webpack-Plugin？"><a href="#如何编写一个-Webpack-Plugin？" class="headerlink" title="如何编写一个 Webpack Plugin？"></a><strong><a href="https://segmentfault.com/a/1190000037513682">如何编写一个 Webpack Plugin</a>？</strong></h3><p>webpack 插件的组成：</p><blockquote><ul><li>一个 JS 命名函数或一个类（可以想下我们平时使用插件就是 new XXXPlugin()的方式）</li><li>在插件类/函数的 (prototype) 上定义一个 apply 方法。</li><li>通过 apply 函数中传入 compiler 并插入指定的事件钩子，在钩子回调中取到 compilation 对象</li><li>通过 compilation 处理 webpack 内部特定的实例数据</li><li>如果是插件是异步的，在插件的逻辑编写完后调用 webpack 提供的 callback</li></ul></blockquote><h2 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h2><h3 id="文件指纹是什么？怎么用？"><a href="#文件指纹是什么？怎么用？" class="headerlink" title="文件指纹是什么？怎么用？"></a>文件指纹是什么？怎么用？</h3><p>文件指纹是指<strong>文件打包后输出的文件名的后缀</strong>，主要用于版本管理。具体来说，文件指纹的用途如下：</p><blockquote><ol><li>验证文件完整性：当你从网络上下载了软件后，想确保此软件没有被人修改过（如添加了木马、病毒、非官方插件），或在下载中被破坏，可以使用文件指纹验证（MD5）技术进行确认。通过计算文件的MD5值（一种常见的文件指纹形式），然后与原始文件的MD5值进行比对，可以判断文件是否完整且未被篡改。</li><li>加速页面访问：在Web开发中，文件指纹通常用于缓存管理。当一个项目需要发布时，如果某个文件被修改过，它的文件指纹也会相应改变。对于未修改的文件，用户在访问时仍然可以使用浏览器缓存的版本，无需重新加载，从而加速页面访问。</li></ol></blockquote><p>使用文件指纹时，通常需要在构建过程中生成它，并将其添加到文件名中。这样，当文件发生更改时，文件指纹也会发生变化，从而确保浏览器能够加载到最新的文件版本。在Webpack等构建工具中，可以通过配置相应的插件或选项来生成和使用文件指纹。</p><p>请注意，虽然文件指纹在验证文件完整性和加速页面访问方面非常有用，但它并不能完全防止恶意攻击。因此，在处理敏感数据时，仍需要采取其他安全措施来确保数据的安全性。</p><h3 id="JS的文件指纹设置"><a href="#JS的文件指纹设置" class="headerlink" title="JS的文件指纹设置"></a>JS的文件指纹设置</h3><p>在JavaScript（JS）项目中，文件指纹（通常被称为内容哈希、哈希值或chunkhash）的设置通常与构建工具（如Webpack）相关。文件指纹主要是为了确保当文件内容发生变化时，其文件名也会相应改变，这样可以有效地利用浏览器缓存。以下是如何在Webpack中设置文件指纹的一般步骤：</p><p><strong>1. 使用<code>[chunkhash]</code>或<code>[contenthash]</code></strong></p><p>在Webpack的输出配置（<code>output</code>）中，你可以使用特定的占位符来生成具有文件指纹的文件名。两种常见的占位符是<code>[chunkhash]</code>和<code>[contenthash]</code>：</p><ul><li><code>[chunkhash]</code>：基于chunk的内容生成哈希值。当chunk的内容发生变化时，哈希值也会改变。</li><li><code>[contenthash]</code>：基于模块内容生成哈希值。当模块的内容发生变化时，哈希值会改变。</li></ul><p>例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// webpack.config.js  </span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...  </span>  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>      filename<span class="token punctuation">:</span> <span class="token string">'[name].[contenthash].js'</span><span class="token punctuation">,</span>      chunkFilename<span class="token punctuation">:</span> <span class="token string">'[name].[contenthash].chunk.js'</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">// ...  </span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// ...  </span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><strong>2. 配置loader以启用哈希</strong></p><p>对于某些loader（如<code>css-loader</code>和<code>mini-css-extract-plugin</code>），你可能需要配置它们以在生成的文件名中包含哈希值。这通常是通过在loader的选项中设置<code>filename</code>或<code>outputFilename</code>来实现的。</p><p><strong>3. 使用缓存头</strong></p><p>为了有效地利用浏览器缓存，你还需要确保服务器正确地设置了缓存头。当文件内容没有变化时，浏览器应该使用缓存的版本，而不是重新从服务器下载。</p><p><strong>4. 清理旧的缓存文件</strong></p><p>由于文件指纹的存在，旧的缓存文件可能会占用不必要的空间。因此，你可能需要定期清理旧的缓存文件。这可以通过在构建过程中添加删除旧文件的步骤来实现，或者使用如<code>clean-webpack-plugin</code>之类的插件来自动处理。</p><p><strong>5. 注意事项</strong></p><ul><li>当使用文件指纹时，请确保在开发环境（dev）和生产环境（prod）之间保持一致。不要在生产环境中使用没有文件指纹的文件名，因为这可能会导致缓存问题。</li><li>文件指纹的长度可以根据你的需求进行调整。较长的哈希值可以提供更好的唯一性保证，但也会使文件名更长。较短的哈希值可能会增加哈希冲突的风险，但可以使文件名更简洁。</li></ul><h3 id="CSS的文件指纹设置"><a href="#CSS的文件指纹设置" class="headerlink" title="CSS的文件指纹设置"></a>CSS的文件指纹设置</h3><p>在CSS的文件指纹设置中，通常我们是为了确保当CSS文件的内容发生变化时，其文件名也能随之改变，以便有效地利用浏览器缓存。这通常与构建工具（如Webpack）的loader和插件配置相关。以下是如何在Webpack中设置CSS文件指纹的一般步骤：</p><p><strong>1. 使用<code>mini-css-extract-plugin</code></strong></p><p><code>mini-css-extract-plugin</code> 是一个Webpack插件，用于将CSS提取到单独的文件中。它允许你通过配置来设置CSS文件的名称和文件指纹。</p><p>首先，你需要在项目中安装这个插件：</p><pre class=" language-bash"><code class="language-bash">bash复制代码<span class="token function">npm</span> <span class="token function">install</span> --save-dev mini-css-extract-plugin</code></pre><p>然后，在你的Webpack配置文件中引入并使用它：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// webpack.config.js  </span><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...  </span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>      rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>          use<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>              loader<span class="token punctuation">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>              options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这里可以配置loader的选项，但通常不需要为文件指纹配置  </span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token string">'css-loader'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 或者其他你需要的CSS预处理loader  </span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// ... 其他规则 ...  </span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].[contenthash].css'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 这里设置CSS文件的名称和文件指纹  </span>      chunkFilename<span class="token punctuation">:</span> <span class="token string">'[id].[contenthash].css'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 如果CSS在chunk中，可以这样设置  </span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">// ... 其他插件 ...  </span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// ...  </span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><strong>2. 配置其他相关loader</strong></p><p>如果你使用了CSS预处理器（如Sass、Less等），你可能还需要确保它们生成的CSS也带有文件指纹。这通常可以通过确保它们生成的CSS被<code>mini-css-extract-plugin</code>捕获来实现。</p><p><strong>3. 清理旧的缓存文件</strong></p><p>和JavaScript文件一样，当CSS文件的内容发生变化时，旧的缓存文件可能会占用不必要的空间。因此，你可能需要定期清理旧的缓存文件。你可以通过添加删除旧文件的步骤或使用如<code>clean-webpack-plugin</code>之类的插件来自动处理。</p><p><strong>4. 注意事项</strong></p><ul><li>确保在开发环境和生产环境之间使用相同的文件指纹设置，以避免缓存问题。</li><li>文件指纹的长度可以根据你的需求进行调整。较长的哈希值可以提供更好的唯一性保证，但也会使文件名更长。较短的哈希值可能会增加哈希冲突的风险，但可以使文件名更简洁。</li><li>如果你在开发环境中使用了热模块替换（HMR），请确保它不会干扰CSS文件的文件指纹设置。</li></ul><h3 id="图片的文件指纹设置"><a href="#图片的文件指纹设置" class="headerlink" title="图片的文件指纹设置"></a>图片的文件指纹设置</h3><p>在Webpack中，为图片设置文件指纹通常是为了确保当图片内容发生变化时，其文件名也能随之改变，以便有效地利用浏览器缓存。这通常与Webpack的loader配置相关，特别是<code>file-loader</code>或<code>url-loader</code>。</p><p>以下是如何在Webpack中设置图片文件指纹的一般步骤：</p><ol><li><p><strong>安装必要的loader</strong>：<br>如果你还没有安装<code>file-loader</code>或<code>url-loader</code>，你需要先安装它们。这两个loader都可以用来处理文件，但<code>url-loader</code>在文件大小小于指定限制时，可以将文件转换为Base64编码的URL。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev file-loader  <span class="token comment" spellcheck="true"># 或者  </span><span class="token function">npm</span> <span class="token function">install</span> --save-dev url-loader</code></pre></li><li><p><strong>配置loader</strong>：<br>在你的Webpack配置文件中，为处理图片文件的规则添加相应的loader。在loader选项中，你可以设置文件名模板，其中可以包含<code>[hash]</code>、<code>[chunkhash]</code>或<code>[contenthash]</code>来生成文件指纹。</p><p>使用<code>file-loader</code>的示例：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...  </span>  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>      rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span><span class="token punctuation">,</span>          use<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>              loader<span class="token punctuation">:</span> <span class="token string">'file-loader'</span><span class="token punctuation">,</span>              options<span class="token punctuation">:</span> <span class="token punctuation">{</span>                name<span class="token punctuation">:</span> <span class="token string">'[name].[contenthash:8].[ext]'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 使用contenthash并限制长度为8  </span>              outputPath<span class="token punctuation">:</span> <span class="token string">'images/'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 输出到dist目录下的images文件夹  </span>              publicPath<span class="token punctuation">:</span> <span class="token string">'images/'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 引用图片时的公共路径  </span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// ... 其他规则 ...  </span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// ...  </span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>使用<code>url-loader</code>的示例（与<code>file-loader</code>类似，但增加了文件大小限制）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>    test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span><span class="token punctuation">,</span>    use<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        loader<span class="token punctuation">:</span> <span class="token string">'url-loader'</span><span class="token punctuation">,</span>        options<span class="token punctuation">:</span> <span class="token punctuation">{</span>          limit<span class="token punctuation">:</span> <span class="token number">8192</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 小于8kb的图片转为base64编码  </span>        name<span class="token punctuation">:</span> <span class="token string">'[name].[contenthash:8].[ext]'</span><span class="token punctuation">,</span>          outputPath<span class="token punctuation">:</span> <span class="token string">'images/'</span><span class="token punctuation">,</span>          publicPath<span class="token punctuation">:</span> <span class="token string">'images/'</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span></code></pre></li><li><p><strong>清理旧的缓存文件</strong>：<br>和JS、CSS文件一样，当图片内容发生变化时，旧的缓存文件可能会占用不必要的空间。因此，你可能需要定期清理旧的缓存文件。你可以通过添加删除旧文件的步骤或使用如<code>clean-webpack-plugin</code>之类的插件来自动处理。</p></li><li><p><strong>注意事项</strong>：</p><ul><li>确保在开发环境和生产环境之间使用相同的文件指纹设置，以避免缓存问题。</li><li>文件指纹的长度可以根据你的需求进行调整。较长的哈希值可以提供更好的唯一性保证，但也会使文件名更长。较短的哈希值可能会增加哈希冲突的风险，但可以使文件名更简洁。</li><li>如果你的项目中有大量的小图片，使用<code>url-loader</code>将它们转换为Base64编码的URL可能会更有效率，因为它们不需要额外的HTTP请求。但是，请注意不要将过大的文件转换为Base64，因为这会增加文件大小并降低性能。</li></ul></li></ol><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><h3 id="聊一聊Babel原理吧"><a href="#聊一聊Babel原理吧" class="headerlink" title="聊一聊Babel原理吧~"></a>聊一聊Babel原理吧~</h3><p>Babel是一个非常流行的JavaScript编译器工具，它的主要作用是将新版本的JavaScript代码转换为旧版本的代码，以便能够在旧版本的浏览器或环境中运行。以下是Babel的工作原理：</p><blockquote><ol><li><strong>解析（Parse）</strong>：当Babel接收到源代码时，它会使用一个叫做解析器的工具（如<code>@babel/parser</code>）将源代码转换为抽象语法树（AST）。在这个过程中，解析器会识别代码中的语法结构，并将其转换为对应的节点类型。AST是一种数据结构，用于表示源代码的抽象语法结构，树上的每个节点都表示源代码中的一种结构。</li><li><strong>转换（Transform）</strong>：Babel使用遍历器（如<code>@babel/traverse</code>）对AST进行遍历，找到需要转换的节点。在这个过程中，Babel会使用访问者模式（Visitor Pattern）来应用插件对AST进行转换。插件是Babel进行转换操作的核心，它们可以修改、删除或添加AST节点，从而实现代码的转换。例如，一个插件可能将ES6中添加的类属性转换为向后兼容的版本，或将对象展开操作符转换为ES5代码。</li><li><strong>生成（Generate）</strong>：在转换过程完成后，Babel使用生成器（如<code>@babel/generator</code>）将转换后的AST重新生成为可执行的JavaScript代码。生成器还可以创建Source Map映射，以便在开发过程中进行调试。</li></ol></blockquote><p>整个过程中，Babel的配置（如插件和预设）起着至关重要的作用。在<code>babel.config.js</code>中设置的一些插件和预设，就是在转换过程中使用的。例如，<code>@babel/preset-env</code>是一个常用的预设，它可以根据目标环境自动确定需要转换的ECMAScript特性和polyfill。</p><p>总的来说，Babel通过解析、转换和生成三个阶段实现了JavaScript代码的转换，使得开发者可以使用新版本的JavaScript语法和功能，同时确保代码能在旧版本的浏览器或环境中运行。</p><h3 id="Webpack-中-babel-属于什么，以什么样的方式存在"><a href="#Webpack-中-babel-属于什么，以什么样的方式存在" class="headerlink" title="Webpack 中 babel 属于什么，以什么样的方式存在?"></a>Webpack 中 babel 属于什么，以什么样的方式存在?</h3><p>在Webpack中，Babel主要作为一个JavaScript编译器工具存在，用于将ES6及更新版本的JavaScript代码转换为旧版本的代码（如ES5），以确保这些新特性能在较旧的浏览器或环境中运行。</p><p>在Webpack中，Babel通常以<code>babel-loader</code>的形式存在，这是一个Webpack的loader，用于在Webpack打包过程中处理JavaScript文件。<code>babel-loader</code>会读取源代码，通过Babel进行转换，然后输出转换后的代码。</p><p>具体来说，你需要在Webpack的配置文件（通常是<code>webpack.config.js</code>）中配置<code>babel-loader</code>。这通常包括在<code>module.rules</code>数组中添加一个新的规则，指定要处理的文件类型（通常是<code>.js</code>或<code>.jsx</code>文件），以及使用<code>babel-loader</code>作为处理这些文件的loader。</p><p>同时，你还需要在项目中安装并配置Babel及其相关插件和预设。例如，<code>@babel/preset-env</code>是一个常用的预设，它可以根据目标环境自动确定需要转换的ECMAScript特性和polyfill。</p><p>总之，Babel在Webpack中扮演着将新版本的JavaScript代码转换为旧版本代码的角色，以确保代码的兼容性和可运行性。</p><h3 id="介绍一下core-js"><a href="#介绍一下core-js" class="headerlink" title="介绍一下core.js"></a>介绍一下core.js</h3><p>core.js是JavaScript标准库的polyfill（垫片/补丁），它主要用于做兼容处理，以支持最新的ECMAScript标准中新增的特性。</p><p>具体来说，core.js的主要功能包括：</p><blockquote><ol><li>提供对最新的ECMAScript标准中新增特性的支持，如Promise、Symbol、Proxy、Reflect等。</li><li>提供对新的数据结构和数据类型的支持，如Map、Set、WeakMap、WeakSet、Symbol、TypedArray等。</li><li>提供多种方式让开发者方便地处理HTTP请求，例如使用XMLHttpRequest（XHR）对象发送和接收HTTP请求，或使用Promise在请求完成后处理结果。</li><li>提供多种数据存储方式，例如使用IndexedDB进行键值存储和索引查询，或使用Web SQL支持事务操作和索引查询。</li><li>提供URL构建工具，可以将JavaScript对象转换为HTTP请求的URL，用于构建动态网页、数据存储、图片处理等任务。</li></ol></blockquote><p>core.js广泛应用于需要向下兼容的新特性应用的场景。例如，在老旧浏览器上启用ES6+的类、箭头函数、模块系统，或者利用Symbol进行元编程，以及借助structuredClone实现深拷贝等等。这个库也可以与构建工具一起使用，确保跨平台项目的代码一致性。</p><p>简单来说，core.js就是将新功能的ES API转换为大部分现代浏览器都可以支持运行的API补丁包集合，使得开发者能够更轻松地编写跨浏览器兼容的代码，并提供更好的用户体验。</p><h2 id="Webpack相关"><a href="#Webpack相关" class="headerlink" title="Webpack相关"></a>Webpack相关</h2><h3 id="Webpack中具体要配哪些东西？"><a href="#Webpack中具体要配哪些东西？" class="headerlink" title="Webpack中具体要配哪些东西？"></a>Webpack中具体要配哪些东西？</h3><p>在Webpack中，你需要配置一系列的设置来满足你的项目需求。以下是一些常见的Webpack配置项：</p><blockquote><ol><li><p>Entry（入口）</p><p>：</p><ul><li>指定Webpack打包的入口文件。这通常是你的应用程序的起点，如<code>index.js</code>。</li><li>可以配置单入口或多入口，多入口通常用于构建多个独立的应用程序或页面。</li></ul></li><li><p>Output（出口）</p><p>：</p><ul><li>指定打包后文件的输出位置。</li><li>包括<code>path</code>（打包文件的绝对路径）和<code>filename</code>（打包后的文件名）。</li></ul></li><li><p>Mode（模式）</p><p>：</p><ul><li>指定构建模式，可以是<code>development</code>（开发模式）或<code>production</code>（生产模式）。</li><li>开发模式下不会压缩代码，并启用source map；生产模式下会自动压缩代码并优化输出。</li></ul></li><li><p>Loaders（加载器）</p><p>：</p><ul><li>用于处理非JavaScript文件（如CSS、图片、字体等）。</li><li>通过配置相应的loader（如<code>css-loader</code>、<code>style-loader</code>、<code>file-loader</code>等）来告诉Webpack如何处理这些文件。</li></ul></li><li><p>Plugins（插件）</p><p>：</p><ul><li>用于扩展Webpack的功能。</li><li>常见的插件包括<code>HtmlWebpackPlugin</code>（用于生成HTML文件并自动注入打包后的JS文件）、<code>CleanWebpackPlugin</code>（用于在每次构建前清理输出目录）等。</li></ul></li><li><p>Resolve（解析）</p><p>：</p><ul><li>配置Webpack如何查找模块。</li><li>可以配置模块解析的根目录、别名（alias）等。</li></ul></li><li><p>DevServer（开发服务器）</p><p>：</p><ul><li>用于在开发过程中启动一个本地服务器。</li><li>可以配置端口号、代理、热更新（HMR）等。</li></ul></li><li><p>Optimization（优化）</p><p>：</p><ul><li>用于配置代码优化相关的选项。</li><li>包括分割代码（如使用<code>SplitChunksPlugin</code>）、压缩JS代码（如使用<code>TerserPlugin</code>）等。</li></ul></li><li><p>Performance（性能）</p><p>：</p><ul><li>用于设置文件大小限制和性能提示。</li><li>当文件大小超过限制时，Webpack会给出警告或错误提示。</li></ul></li><li><p>Module.rules（模块规则）</p><p>：</p><ul><li>用于配置如何处理项目中的不同文件类型。</li><li>通过在<code>rules</code>数组中定义一系列的匹配条件和对应的loader来处理不同类型的文件。</li></ul></li></ol></blockquote><p>需要注意的是，以上配置项并非都需要在每个项目中都进行配置，你可以根据项目的实际需求来选择性地配置。同时，Webpack也提供了很多默认的配置选项，你可以通过覆盖这些默认选项来定制你的构建过程。</p><h3 id="webpack的生命周期及钩子"><a href="#webpack的生命周期及钩子" class="headerlink" title="webpack的生命周期及钩子"></a><strong>webpack的生命周期及钩子</strong></h3><p>​        compiler 对象包含了Webpack 环境所有的的配置信息。</p><p>​        这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 <strong>options</strong>，<strong>loader</strong> 和 <strong>plugin</strong>。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p><p>​        compilation对象包含了当前的模块资源、编译生成资源、变化的文件等。</p><p>​        当运行webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p><p>​        compiler代表了整个webpack从启动到关闭的生命周期，而compilation 只是代表了一次新的编译过程。</p><h3 id="webpack-编译过程"><a href="#webpack-编译过程" class="headerlink" title="webpack 编译过程"></a><strong>webpack</strong> <strong>编译过程</strong></h3><p>Webpack 的编译流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li><strong>初始化参数</strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li><strong>开始编译</strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run方法开始执行编译；</li><li><strong>确定入口</strong>：根据配置中的 entry 找出所有的入口文件；</li><li><strong>编译模块</strong>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li><strong>完成模块编译</strong>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li><strong>输出资源</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li><strong>输出完成</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><h3 id="优化项目的webpack打包编译过程"><a href="#优化项目的webpack打包编译过程" class="headerlink" title="优化项目的webpack打包编译过程"></a><strong>优化项目的</strong>webpack打包编译过程</h3><blockquote><p>​    <strong>1. 构建打点</strong>：构建过程中，每一个Loader 和 Plugin 的执行时长，在编译 JS、CSS 的 Loader 以及对这两类代码执行压缩操作的 Plugin上消耗时长 。一款工具：speed-measure-webpack-plugin</p><p>​    <strong>2. 缓存</strong>：大部分 Loader 都提供了cache 配置项。cache-loader ，将 loader 的编译结果写入硬盘缓存</p><p>​    <strong>3. 多核编译</strong>，happypack项目接入多核编译，理解为happypack 将编译工作灌满所有线程</p><p>​    <strong>4. 抽离</strong>，webpack-dll-plugin 将这些静态依赖从每一次的构建逻辑中抽离出去，静态依赖单独打包，Externals将不需要打包的静态资源从构建逻辑中剔除出去，使用CDN 引用</p><p>​    <strong>5.</strong> <strong>tree-shaking</strong>，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块剔除，来达到删除无用代码的目的。</p></blockquote><h3 id="webpack-热更新机制"><a href="#webpack-热更新机制" class="headerlink" title="webpack 热更新机制"></a><strong>webpack</strong> <strong>热更新机制</strong></h3><p>热更新流程总结:</p><blockquote><ul><li>启动本地server，让浏览器可以请求本地的<strong>静态资源</strong></li><li>页面首次打开后，服务端与客户端通过 websocket建立通信渠道，把下一次的 hash 返回前端</li><li>客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash</li><li>修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端</li><li>客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档</li><li>hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。</li></ul></blockquote><p>Webpack 的热更新（Hot Module Replacement，简称 HMR）原理主要包括以下几个步骤：</p><blockquote><ol><li><strong>文件变化监测</strong>：Webpack 使用文件系统通知（如 Node.js 的 <code>fs.watch</code> 或 <code>fs.watchFile</code>）来监视项目文件的更改。当文件发生变化时，Webpack 会捕获到这些变化。</li><li><strong>重新编译模块</strong>：一旦 Webpack 检测到文件发生变化，它会重新编译受影响的模块。这个过程包括模块的重新解析、依赖的重建以及代码的重新编译等步骤。</li><li><strong>构建新模块版本</strong>：重新编译的模块会与先前的版本进行比较，并构建新的模块版本。Webpack 会根据模块的依赖关系，确保只重新编译和构建必要的模块，而不是整个项目。</li><li><strong>通知更新</strong>：Webpack 通过 WebSocket 或轮询机制将新的模块版本通知给运行时环境（通常是 Webpack Dev Server）。这个通知包含了更新模块的详细信息，如模块的标识符和更新内容。</li><li><strong>应用更新</strong>：运行时环境接收到新的模块版本后，会将其应用于当前运行的应用程序。这个过程会根据模块的类型和内容进行不同的处理。对于样式类的模块，客户端会直接替换页面上的样式，实现样式的实时更新；对于 JavaScript 模块，客户端会先卸载旧模块，再加载并执行新模块，以此更新页面内容。这种动态的模块加载和替换过程使得页面内容能够在不刷新整个页面的情况下得以更新，从而提供了更加流畅的开发体验。</li><li><strong>保持应用状态</strong>：在更新页面内容的过程中，Webpack 会努力保持应用程序的当前状态，以确保用户体验的连续性。例如，输入框的输入内容、复选框的选中状态等都会保留下来，不会被重置。</li></ol></blockquote><p>总的来说，Webpack 的热更新原理是通过实时监测文件变化、重新编译模块、构建新模块版本、通知更新以及应用更新等步骤，实现页面内容的实时更新，同时保持应用程序的状态不变。这种技术可以大大提高开发效率，减少不必要的页面刷新和重新加载时间。</p><h3 id="Webpack中的文件监听原理"><a href="#Webpack中的文件监听原理" class="headerlink" title="Webpack中的文件监听原理"></a>Webpack中的文件监听原理</h3><p>Webpack中的文件监听原理主要涉及对源代码文件的持续监控，并在检测到文件变化时自动触发构建过程以生成新的输出文件。具体来说，其原理如下：</p><blockquote><ol><li><strong>轮询机制</strong>：Webpack使用轮询机制来检查文件的变化。这意味着Webpack会定期询问文件系统，查看指定的文件或目录是否有任何更改。</li><li><strong>时间戳对比</strong>：Webpack会记录每个文件的最后修改时间戳。在每次轮询时，Webpack会检查文件的当前时间戳是否与之前记录的时间戳不同。如果时间戳发生了变化，说明文件已经被修改。</li><li><strong>缓存与延迟</strong>：当检测到文件变化时，Webpack并不会立即触发构建过程。相反，它会将文件修改的信息缓存起来，并等待一段时间（这个时间可以通过配置<code>aggregateTimeout</code>选项来调整）。这是因为在短时间内可能会有多个文件被连续修改，Webpack通过等待和缓存可以避免不必要的重复构建，从而提高构建效率。</li><li><strong>批量处理</strong>：在等待期间，如果又有其他文件被修改，Webpack会将这些修改也缓存起来。当等待时间结束后，Webpack会一次性处理所有缓存的修改，并触发构建过程生成新的输出文件。</li><li><strong>排除特定文件或目录</strong>：Webpack允许你指定不需要监听的文件或目录。这可以通过在<code>watchOptions</code>中设置<code>ignored</code>选项来实现，支持使用正则表达式进行匹配。这可以进一步提高文件监听的效率和准确性。</li></ol></blockquote><p>总之，Webpack的文件监听原理是通过轮询机制检查文件的变化，并使用时间戳对比和缓存机制来避免不必要的重复构建。同时，通过排除特定文件或目录来提高文件监听的效率和准确性。</p><h3 id="Wepack中的代码分割的本质是什么？"><a href="#Wepack中的代码分割的本质是什么？" class="headerlink" title="Wepack中的代码分割的本质是什么？"></a>Wepack中的代码分割的本质是什么？</h3><p>Webpack中的代码分割（Code Splitting）的本质是将一个大型的代码库分割成多个小块（chunks），并在需要时按需加载这些小块。这样做有几个主要的好处：</p><blockquote><ol><li><strong>提高性能</strong>：通过按需加载代码，可以减少首次加载时用户需要下载的代码量，从而提高应用的启动速度。当用户与页面进行交互并触发某些功能时，再加载这些功能所需的代码，可以进一步提高应用的响应速度和用户体验。</li><li><strong>更好的缓存管理</strong>：由于代码被分割成了多个小块，每个小块都可以单独缓存。当用户再次访问应用时，只需要加载那些已经改变的小块，而不是整个代码库。这可以显著提高缓存的利用率和应用的加载速度。</li><li><strong>代码组织</strong>：代码分割有助于将代码按照功能或页面进行组织，使得代码结构更加清晰和易于维护。</li></ol></blockquote><p>Webpack支持多种方式进行代码分割，包括：</p><blockquote><ol><li><strong>基于入口点的分割</strong>：通过配置多个入口点（entry points），Webpack可以为每个入口点生成一个独立的输出文件。这种方式适合将不同的页面或功能拆分成不同的入口点，从而实现基本的代码分割。</li><li><strong>动态导入（Dynamic Imports）</strong>：Webpack支持ES6的动态<code>import()</code>语法，允许在运行时按需加载模块。这是实现更细粒度代码分割的关键技术，非常适合实现懒加载或条件加载。</li><li><strong>使用SplitChunksPlugin</strong>：Webpack内置了SplitChunksPlugin插件，用于优化和分割公共的依赖模块。该插件可以自动分析出公共的依赖模块，并将它们提取到已有的入口chunk中，或者生成一个新的chunk。</li></ol></blockquote><p>通过这些方式，Webpack可以根据项目的实际需求进行代码分割，从而提高应用的性能和可维护性。</p><h3 id="dev的时候webpack做了什么事情？"><a href="#dev的时候webpack做了什么事情？" class="headerlink" title="dev的时候webpack做了什么事情？"></a>dev的时候webpack做了什么事情？</h3><p>在开发（dev）时，Webpack 主要做了以下事情：</p><blockquote><ol><li><strong>实时监听</strong>：Webpack 使用其 watch 模式来实时监听源代码文件的变化。当检测到文件被修改时，Webpack 会自动触发构建过程。</li><li><strong>模块打包</strong>：Webpack 会根据项目的配置文件（如 webpack.config.js），将项目中的各个模块（如 JavaScript、CSS、图片等）打包成浏览器可以识别的格式。这个过程中，Webpack 会处理模块的依赖关系，确保它们按照正确的顺序被加载。</li><li><strong>代码转换</strong>：对于非 JavaScript 文件（如 CSS、图片等），Webpack 会使用相应的 loader（加载器）进行转换，以便它们可以被 JavaScript 引用。例如，css-loader 可以将 CSS 文件转换为 JavaScript 模块，file-loader 可以将图片文件转换为 URL 或 base64 编码的字符串。</li><li><strong>插件处理</strong>：Webpack 允许开发者使用插件（plugin）来扩展其功能。在开发过程中，这些插件可以用于执行各种任务，如压缩代码、优化资源加载、生成 HTML 文件等。</li><li><strong>热模块替换（Hot Module Replacement, HMR）</strong>：当与 webpack-dev-server 一起使用时，Webpack 支持热模块替换功能。这意味着在开发过程中，当源代码文件被修改时，Webpack 可以只替换被修改的模块，而不是重新加载整个页面。这可以大大提高开发效率。</li><li><strong>提供开发服务器</strong>：webpack-dev-server 是一个基于 Express 的开发服务器，它集成了 Webpack 的打包功能和自动刷新浏览器等功能。这使得开发者可以在本地快速启动一个服务器，进行开发、调试和测试。webpack-dev-server 会在内存中创建一个静态资源服务器，并在启动后自动打开浏览器。当代码被修改时，webpack-dev-server 会自动重新编译和刷新页面。</li></ol></blockquote><p>总的来说，Webpack 在开发过程中主要负责实时监听文件变化、模块打包、代码转换、插件处理和提供开发服务器等任务，以支持快速、高效的前端开发。</p><h3 id="什么是神奇注释或者魔术注释？"><a href="#什么是神奇注释或者魔术注释？" class="headerlink" title="什么是神奇注释或者魔术注释？"></a>什么是神奇注释或者魔术注释？</h3><p><strong>神奇注释或魔术注释（Magic Comment）是一种特殊的注释，用于在代码中嵌入特定的指令或元数据</strong>。这些注释通常被特定的工具或库识别并处理，以实现一些特殊的功能或效果。</p><p>在Webpack中，魔术注释被用于为动态导入的模块指定特定的名字，以方便Webpack在编译过程中进行优化和分割。例如，通过在import语句中添加特定格式的注释，可以为动态导入的模块指定一个chunk名，以便在打包后生成具有特定名称的bundle文件。</p><p>请注意，魔术注释并不是一种通用的编程概念，而是特定于某些工具或库的特定功能。因此，在不同的上下文或环境中，魔术注释的具体含义和用法可能会有所不同。</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><blockquote><p>webpack Proxy , 即wepack提供的代理服务，将客户端发送的请求转发给其他服务器。目的是为了解决开发模式下的跨域问题。想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server。webpack-dev-server是webpack官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能集成在了一起。【只适用在开发阶段】</p></blockquote><p>在webpack配置对象属性中通过devServer属性提供，配置如下</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// ./webpack.config.js</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>        contentBase<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        compress<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        port<span class="token punctuation">:</span> <span class="token number">8080</span><span class="token punctuation">,</span>        proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>          <span class="token string">'/api'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            target<span class="token punctuation">:</span> <span class="token string">'http://www.baidu.com/'</span><span class="token punctuation">,</span>            pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'^/api'</span> <span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//// 如果接口本身没有/api需要通过pathRewrite来重写了地址,这里把/api转成''</span>            changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">// target是域名的话，需要这个参数，</span>            secure<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// 设置支持https协议的代理</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>​        devServer里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性即一个代理的规则匹配。</p><blockquote><p>target：代理的API地址，就是需要跨域的API地址。<br>pathRewrite：路径重写，也就是说会修改最终请求的API路径。<br>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可设置为false<br>changOrigin：默认是false：请求头中host仍然是浏览器发送过来的host；如果设置成true：发送请求头中host会设置成target</p></blockquote><p>​        proxy工作原理实质上是利用http-proxy-middleware这个http代理中间件，实现请求转发给其他服务器</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'/api'</span><span class="token punctuation">,</span> <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span>target<span class="token punctuation">:</span> <span class="token string">'http://www.example.org'</span><span class="token punctuation">,</span> changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// http://localhost:8080/api/foo/bar -> http://www.example.org/api/foo/bar</span></code></pre><p>总的来说就是：</p><p>​        在开发阶段，webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上；</p><p>​        所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题。</p><p>​        通过设置webpack proxy实现代理请求后，相当于浏览器与服务端添加一个代理者</p><p>​        当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终由代理服务器将数据响应给本地。</p><h3 id="说一说Loader和Plugin的区别？"><a href="#说一说Loader和Plugin的区别？" class="headerlink" title="说一说Loader和Plugin的区别？"></a>说一说Loader和Plugin的区别？</h3><p>Loader和Plugin在Webpack中扮演着不同的角色，它们之间的主要区别体现在以下几个方面：</p><blockquote><ol><li><strong>功能定位</strong>：<ul><li>Loader：专注于处理资源的加载和转换。由于Webpack本身只能处理JavaScript模块，Loader的作用就是将其他类型的文件（如CSS、图片、字体等）转换成Webpack能够处理的JavaScript模块。Loader就像一个翻译官，负责将其他类型的资源“翻译”成Webpack能理解的JavaScript代码。</li><li>Plugin：负责扩展Webpack的功能。Plugin可以监听Webpack运行过程中的各种事件，并在合适的时机通过Webpack提供的API改变输出结果。Plugin不仅可以处理资源文件，还可以优化构建过程、生成额外的文件等。</li></ul></li><li><strong>配置方式</strong>：<ul><li>Loader：在<code>module.rules</code>中配置，作为模块的解析规则。Loader的配置通常是一个数组，数组中的每个元素都是一个对象，指定了需要处理的文件类型、使用的Loader以及传递给Loader的参数等。</li><li>Plugin：在<code>plugins</code>中单独配置，也是以数组的形式存在。数组中的每个元素都是一个Plugin的实例，参数都通过构造函数传入。</li></ul></li><li><strong>执行顺序</strong>：<ul><li>Loader：Loader的执行顺序是从下到上、从右到左的链式调用。在一个规则中，多个Loader会按照配置的顺序依次执行，上一个Loader的输出会作为下一个Loader的输入。</li><li>Plugin：Plugin的执行顺序则取决于Webpack的事件流和Plugin的监听事件。不同的Plugin会监听不同的事件，并在事件触发时执行相应的逻辑。</li></ul></li><li><strong>使用场景</strong>：<ul><li>Loader：通常用于处理资源的加载和转换，如将CSS文件转换成JavaScript模块、将图片转换成Base64编码等。</li><li>Plugin：则更多地用于扩展Webpack的功能，如生成HTML文件、压缩代码、优化资源加载等。</li></ul></li></ol></blockquote><p>总结来说，Loader和Plugin在Webpack中各自扮演着不同的角色，它们共同协作以实现Webpack的强大功能。Loader负责资源的加载和转换，而Plugin则负责扩展Webpack的功能和优化构建过程。</p><h3 id="source-map是什么？生产环境怎么用？"><a href="#source-map是什么？生产环境怎么用？" class="headerlink" title="source map是什么？生产环境怎么用？"></a>source map是什么？生产环境怎么用？</h3><p><strong>Source Map是一个信息文件，里面储存着位置信息，即存储着代码压缩混淆前后的对应关系</strong>。它是一种数据格式，通常使用.map扩展名，本质上是一个JSON文本文档，其MIME类型也一般设为application/json。</p><p>在生产环境下，Source Map的使用需要考虑安全性和性能。一般来说，不建议在生产环境下直接启用Source Map，因为这可能会暴露源代码给潜在的攻击者。但是，如果你确实需要在生产环境下查看报错行数或展示源码，可以采用以下几种方式：</p><blockquote><ol><li><strong>使用<code>nosource-source-map</code>方式</strong>：这种方式只会将代码定位到多少行，但不会直接跳转源码。这样可以提高代码的安全性，避免遭到攻击。你可以在webpack的配置文件（如webpack.config.js）中设置<code>devtool: &#39;nosource-source-map&#39;</code>来实现这一点。</li><li><strong>删除<code>devtool</code>配置</strong>：相当于关闭了Source Map。在生产环境下，如果你不需要查看源码或报错行数，可以直接删除<code>devtool</code>配置。</li><li><strong>仅在需要时启用Source Map</strong>：你可以考虑只在遇到问题时才启用Source Map，例如在错误日志中提供一个链接，让用户或开发者可以手动下载和查看Source Map文件。</li></ol></blockquote><p>请注意，无论你选择哪种方式，都需要权衡安全性和性能之间的关系。在生产环境下，你应该始终优先考虑安全性。</p><p><a href="https://juejin.cn/post/6844904094281236487">Webpack相关试题</a></p><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><h3 id="介绍一下vite"><a href="#介绍一下vite" class="headerlink" title="介绍一下vite"></a>介绍一下vite</h3><p>Vite是一款基于ES模块的前端构建工具，旨在提供快速、高效、简洁的开发体验。以下是关于Vite的详细介绍：</p><ol><li><strong>基本概念和特点</strong>：</li></ol><ul><li>Vite是一个下一代前端开发与构建工具，它使用浏览器原生的ES模块作为入口，减少了构建时间。</li><li>Vite提供了开箱即用的配置，同时其插件API和JavaScript API带来了高度的可扩展性，并有完整的类型支持。</li><li>Vite内置了HMR（模块热更新）到Vue.js单文件组件（SFC）和React Fast Refresh中，使得开发者可以实时更新代码并预览修改效果。</li><li>Vite支持多种前端框架和语言，如Vue、React、Angular等，以及TypeScript、CoffeeScript和Sass等前端语言。</li></ul><ol><li><strong>主要优势</strong>：</li></ol><ul><li><strong>快速构建</strong>：Vite使用了优化过的构建器，可以快速地构建和优化应用程序。其构建速度比传统工具如Webpack快得多，因为它避免了静态打包和编译的过程。</li><li><strong>高效</strong>：Vite的优化过的构建器可以减少构建时间和运行时内存占用。它还支持多种静态资源类型，如JavaScript、CSS、HTML等，可以减少静态资源的加载时间。</li><li><strong>简洁</strong>：Vite的配置非常简洁，可以轻松地配置和定制。它还提供了一个易于使用的CLI（命令行界面），可以轻松地创建和管理Vite项目。</li><li><strong>社区支持</strong>：Vite拥有庞大的社区支持，有许多开源项目和插件可供使用，可以满足用户的不同需求。</li></ul><ol><li><strong>安装和使用</strong>：</li></ol><ul><li>你可以使用npm或yarn来安装Vite。安装完成后，你需要创建一个入口文件（如“index.html”），并在其中引入你的JavaScript代码。</li><li>编写JavaScript代码时，你可以创建Vue、React或其他框架的应用程序，并享受Vite带来的快速构建和实时预览功能。</li></ul><p>总的来说，Vite是一个快速、高效、简洁的构建工具，旨在为用户提供一个更好的开发体验，提高开发效率和应用程序性能。</p><h3 id="解释一下Vite的原理"><a href="#解释一下Vite的原理" class="headerlink" title="解释一下Vite的原理"></a>解释一下Vite的原理</h3><p>Vite的原理主要基于现代浏览器的原生ES模块（ESM）加载特性，以及快速热模块替换（HMR）机制。以下是关于Vite原理的详细解释：</p><blockquote><ol><li>原生ES模块加载：在开发环境中，Vite利用现代浏览器支持的ES模块特性来处理文件。这意味着它不预先打包文件，而是直接将源文件作为模块发送给浏览器。当浏览器请求一个文件时（比如一个JavaScript模块或Vue组件），Vite仅处理该特定文件，并实时地将其转换成浏览器可理解的格式。这种按需加载避免了传统打包工具在开发环境中的全部重构建过程，减少了初始化加载时间并提高了模块更新的速度。</li><li>快速热模块替换（HMR）：Vite实现了高效的热模块替换机制。这意味着在开发过程中，当源代码发生变化时，Vite可以仅重新加载发生变化的模块，而不是整个应用程序。这大大提高了开发效率，使得开发者可以更快地看到代码更改的效果。</li></ol></blockquote><p>此外，Vite的工作原理和架构还可以大致分为以下几个部分：</p><blockquote><ul><li>入口文件处理器：负责处理入口文件，将入口文件转换为ES模块。</li><li>构建器：负责对ES模块进行构建和优化。</li><li>模块缓存：负责将构建好的模块缓存到内存中，以便在应用程序运行时快速加载。</li><li>静态资源处理器：负责对静态资源进行处理，如CSS预处理器、图片处理等。</li></ul></blockquote><p>总的来说，Vite通过利用现代浏览器的原生ES模块加载特性和快速热模块替换机制，为用户提供了一个快速、高效、简洁的构建流程，以提高开发效率和应用程序性能。</p><h3 id="Vite-和-Webpack-的区别"><a href="#Vite-和-Webpack-的区别" class="headerlink" title="Vite 和 Webpack 的区别"></a>Vite 和 Webpack 的区别</h3><p>Vite和Webpack是两款不同的前端构建工具，它们在多个方面存在显著的区别。以下是它们之间的主要差异：</p><ol><li><strong>构建速度和冷启动时间</strong>：</li></ol><ul><li>Vite：由于采用了基于浏览器原生ES模块的开发模式，Vite在开发时可以快速启动应用，减少了冷启动时间。它直接服务源代码，具有极快的冷启动时间（即启动首次打包时）。</li><li>Webpack：需要先进行打包才能启动开发服务器，因此冷启动时间相对较长。它需要先打包代码，转换为浏览器可识别的模块格式，才能实现运行。</li></ul><ol><li><strong>按需编译</strong>：</li></ol><ul><li>Vite：可以根据需要动态地编译模块，每个模块都可以独立地进行编译和缓存。这意味着它只需要重新编译修改过的模块，而不是整个应用程序，从而提高了开发效率。</li><li>Webpack：会将所有模块打包到一个文件中，无法实现按需编译。</li></ul><ol><li><strong>配置文件</strong>：</li></ol><ul><li>Vite：使用更简单的JSON配置文件，只包含必要的启动信息，配置相对更简单。</li><li>Webpack：使用复杂的JavaScript配置文件，需要配置loader、plugin等组件，配置更加复杂。</li></ul><ol><li><strong>热模块替换（HMR）</strong>：</li></ol><ul><li>Vite：可以直接替换JS模块，无需重新加载页面，使得开发过程中的代码更新更加快速和流畅。</li><li>Webpack：在替换模块后需要刷新页面才能使HMR生效，这可能会打断开发流程。</li></ul><ol><li><strong>TypeScript支持</strong>：</li></ol><ul><li>Vite：内置支持TypeScript，可以直接导入TS文件。</li><li>Webpack：需要安装相应的loader才能导入TS文件。</li></ul><ol><li><strong>生态环境</strong>：</li></ol><ul><li>Webpack：拥有更成熟的生态环境，在社区中拥有广泛的支持和丰富的插件库。</li><li>Vite：虽然已经获得了很多关注，但其生态系统仍然不太完善，正在发展阶段。</li></ul><ol><li><strong>功能特性</strong>：</li></ol><ul><li>Webpack：是一个功能更加全面的打包工具，支持各种Loader和插件，可以处理多种类型的文件和资源。</li><li>Vite：设计初衷是专注于开发环境下的快速构建，因此对一些高级特性的支持相对较少。</li></ul><p>综上所述，Vite和Webpack各有优劣，选择哪个工具取决于项目的具体需求和开发者的个人偏好。对于需要快速启动和高效开发的小型项目或组件库，Vite可能是一个更好的选择；而对于大型应用的构建和优化，Webpack可能更加适合。</p><h2 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h2><h3 id="首屏加载优化"><a href="#首屏加载优化" class="headerlink" title="首屏加载优化"></a><strong>首屏加载优化</strong></h3><blockquote><p><strong>路由懒加载</strong>：改为用import引用，以函数的形式动态引入，可以把各自的路由文件分别打包，只有在解析给定的路由时，才会下载路由组件；</p><p><strong>element-ui按需加载</strong>：引用实际上用到的组件 ；</p><p><strong>组件重复打包</strong>：CommonsChunkPlugin配置来拆包，把使用2次及以上的包抽离出来，放进公共依赖文件，首页也有复用的组件，也会下载这个公共依赖文件；</p><p><strong>gzip</strong>: 拆完包之后，再用gzip做一下压缩，关闭sourcemap。</p><p><strong>UglifyJsPlugin:</strong>  生产环境，压缩混淆代码，移除console代码</p><p>CDN部署静态资源：静态请求打在nginx时，将获取静态资源的地址进行重定向CDN内容分发网络</p><p><strong>移动端首屏</strong>加载可以使用<strong>骨架屏</strong>，自定义<strong>loading</strong>，首页单独做<strong>服务端渲染</strong>。</p><p>如何进行前端性能优化(21种优化+7种定位方式)</p></blockquote><h3 id="Webpack常见的优化方案"><a href="#Webpack常见的优化方案" class="headerlink" title="Webpack常见的优化方案"></a>Webpack常见的优化方案</h3><p>Webpack常见的优化方案主要包括以下几个方面：</p><blockquote><ol><li><p>利用Tree Shaking</p><p>：</p><ul><li>Tree Shaking是一个术语，用于描述移除JavaScript上下文中的未引用代码（死代码）。在Webpack中，你可以通过配置<code>production</code>模式（该模式下默认启用Tree Shaking）或利用像<code>terser-webpack-plugin</code>这样的插件来进一步优化结果。</li></ul></li><li><p>优化加载速度</p><p>：</p><ul><li>使用<code>MiniCssExtractPlugin</code>将CSS提取到单独的文件中，以避免阻塞JavaScript的加载。</li><li>使用<code>babel-loader</code>的缓存机制，以减少不必要的转换操作。</li></ul></li><li><p>并行和分布式构建</p><p>：</p><ul><li>利用<code>thread-loader</code>或<code>happypack</code>等插件将任务分配给多个子进程并行处理，从而加速构建过程。</li><li>在多核CPU的机器上，这可以显著提高构建速度。</li></ul></li><li><p>压缩文件体积</p><p>：</p><ul><li>使用<code>terser-webpack-plugin</code>来压缩JavaScript代码。</li><li>使用<code>cssnano</code>等工具来压缩CSS代码。</li><li>对于图片和其他资源，可以使用像<code>image-webpack-loader</code>或<code>url-loader</code>这样的加载器来优化。</li></ul></li><li><p>使用缓存</p><p>：</p><ul><li>配置Webpack的缓存功能，如<code>cache-loader</code>，以便在构建过程中重用未更改的文件，从而加快构建速度。</li><li>利用<code>hard-source-webpack-plugin</code>这样的插件来实现持久化缓存，进一步提高构建性能。</li></ul></li><li><p>代码分割</p><p>：</p><ul><li>利用Webpack的代码分割功能，将代码拆分成多个bundle，以便按需加载。</li><li>这可以通过配置<code>optimization.splitChunks</code>选项来实现。</li></ul></li><li><p>优化输出</p><p>：</p><ul><li>使用<code>optimization.minimize</code>选项来开启代码压缩。</li><li>利用<code>optimization.runtimeChunk</code>选项来将运行时代码拆分为单独的bundle。</li><li>配置<code>output.filename</code>和<code>output.chunkFilename</code>选项来生成具有唯一哈希的文件名，以便实现长期缓存。</li></ul></li><li><p>使用DLL Plugin</p><p>：</p><ul><li>DLL Plugin可以将一些不经常变动的库或框架代码与业务代码分开打包，从而加速构建过程。</li></ul></li><li><p>开发服务器配置</p><p>：</p><ul><li>配置<code>devServer</code>选项来优化开发体验，如启用热更新（HMR）、设置代理等。</li></ul></li><li><p>外部化（Externals）</p><p>：</p><ul><li>通过配置<code>externals</code>选项，可以将一些已经在运行环境中存在的库（如jQuery、React等）排除在构建过程之外，从而减少打包后的文件体积。</li></ul></li><li><p>使用Webpack Bundle Analyzer</p><p>：</p><ul><li>通过这个插件，你可以分析打包后的文件，找出哪些模块占用了较大的体积，从而有针对性地进行优化。</li></ul></li></ol></blockquote><p>请注意，这些优化方案应根据具体项目需求和场景灵活应用。不同的项目可能需要采用不同的优化策略。</p><h3 id="Webpack优化之减少打包时间"><a href="#Webpack优化之减少打包时间" class="headerlink" title="Webpack优化之减少打包时间"></a>Webpack优化之减少打包时间</h3><p>Webpack优化以减少打包时间，通常涉及以下几个方面的策略：</p><blockquote><ol><li><p><strong>使用最新版本的Webpack</strong>：</p><ul><li>确保你正在使用最新版本的Webpack和相关插件，因为新版本通常包含性能改进和错误修复。</li></ul></li><li><p><strong>减少打包作用域</strong>：</p><ul><li>优化loader的配置，减少不必要的文件转换。通过<code>include</code>和<code>exclude</code>属性来指定loader应该处理哪些文件。</li><li>例如，如果你只需要转换src目录下的JS文件，你可以配置babel-loader来只处理这个目录下的文件。</li></ul></li><li><p><strong>启用缓存</strong>：</p><ul><li>使用Webpack的内置缓存机制或配置loader（如babel-loader）的缓存选项，以避免重复转换未更改的文件。</li><li>例如，设置babel-loader的<code>cacheDirectory</code>选项为<code>true</code>可以启用缓存。</li></ul></li><li><p><strong>使用Tree Shaking</strong>：</p><ul><li>在Webpack配置中启用Tree Shaking功能，以消除未使用的代码。这可以通过在<code>production</code>模式下运行Webpack来实现，因为该模式下默认启用Tree Shaking。</li></ul></li><li><p><strong>代码分割</strong>：</p><ul><li>使用Webpack的代码分割功能将代码拆分成多个bundle，以便按需加载。这可以减少初始加载时间，因为用户只需加载他们当前需要的代码。</li></ul></li><li><p><strong>优化Loader和插件</strong>：</p><ul><li>选择性能良好的Loader和插件，并通过配置参数和选项来提高其性能。</li><li>例如，使用<code>hard-source-webpack-plugin</code>或<code>cache-loader</code>来缓存loader的结果。</li></ul></li><li><p><strong>并行构建</strong>：</p><ul><li>使用Webpack的<code>thread-loader</code>或<code>happypack</code>插件将任务分发给多个子进程并行处理，以提高构建速度。</li></ul></li><li><p><strong>优化文件体积</strong>：</p><ul><li>虽然这主要关注减少打包后的文件大小，但压缩代码和资源（如使用<code>terser-webpack-plugin</code>压缩JS代码，使用<code>cssnano</code>压缩CSS代码）也可以间接地减少打包时间，因为它们减少了需要处理的文件大小。</li></ul></li><li><p><strong>使用DLL Plugin</strong>：</p><ul><li>将一些不经常变动的库或框架代码与业务代码分开打包，这样当业务代码发生变化时，不需要重新打包这些库或框架。</li></ul></li><li><p><strong>分析和监控</strong>：</p><ul><li>使用Webpack Bundle Analyzer来分析和可视化打包后的文件，找出哪些模块占用了较大的体积和时间，从而有针对性地进行优化。</li><li>监控构建过程，查找可能的瓶颈和性能问题。</li></ul></li></ol></blockquote><p>请注意，不同的项目可能需要采用不同的优化策略。建议根据你的具体项目需求和场景来选择合适的优化方案。</p><h3 id="Webpack优化之减少打包体积"><a href="#Webpack优化之减少打包体积" class="headerlink" title="Webpack优化之减少打包体积"></a>Webpack优化之减少打包体积</h3><p>Webpack 优化以减少打包体积的策略主要包括以下几个方面：</p><blockquote><ol><li>代码分割 (Code Splitting)<ul><li>通过配置 Webpack 的代码分割功能，将项目代码分割成多个块（chunks），并在需要时按需加载。这可以通过 <code>import()</code> 语法动态导入模块或使用 Webpack 的 <code>SplitChunksPlugin</code> 插件来实现。</li></ul></li><li>Tree Shaking<ul><li>Tree Shaking 可以移除 JavaScript 上下文中的未引用代码（死代码）。在 Webpack 中，可以通过启用 <code>production</code> 模式下的默认 Tree Shaking 功能或使用 <code>sideEffects</code> 属性来进一步指定哪些文件或模块具有副作用，从而避免不必要的代码被打包。</li></ul></li><li>压缩和优化代码<ul><li>使用代码压缩插件，如 <code>TerserWebpackPlugin</code>（用于压缩 JavaScript 代码）和 <code>OptimizeCSSAssetsPlugin</code> 或 <code>cssnano</code>（用于压缩 CSS 代码）。这些插件可以删除注释、缩短变量名、合并重复的代码等，从而减小文件体积。</li></ul></li><li>移除不必要的插件和加载器<ul><li>检查 Webpack 配置，移除不再需要或从未使用的插件和加载器，以减少构建过程中的不必要的处理。</li></ul></li><li>使用作用域内的 CSS<ul><li>使用如 <code>MiniCssExtractPlugin</code> 这样的插件将 CSS 提取到单独的文件中，并通过 <code>&lt;link&gt;</code> 标签引入。这样可以利用浏览器的并行加载能力，并且只对实际使用的 CSS 进行加载。</li></ul></li><li>优化图片和其他资源<ul><li>使用适当的图片加载器（如 <code>file-loader</code> 或 <code>url-loader</code>）和图片优化插件（如 <code>image-webpack-loader</code>）来压缩和优化图片。此外，还可以使用 SVG Sprite 插件来合并 SVG 图标，减少 HTTP 请求。</li></ul></li><li>利用缓存<ul><li>使用 Webpack 的内置缓存机制或第三方插件（如 <code>hard-source-webpack-plugin</code>）来缓存 loader 的结果，避免重复处理未更改的文件。</li></ul></li><li>外部化依赖<ul><li>将一些库或框架通过 CDN 引入，而不是将它们打包到项目中。这可以通过 Webpack 的 <code>externals</code> 配置选项来实现。</li></ul></li><li>使用 Webpack Bundle Analyzer<ul><li>这个插件可以帮助你分析打包后的文件，找出哪些模块或依赖“贡献”出了最多的体积，从而有针对性地进行优化。</li></ul></li><li>优化 Webpack 配置<ul><li>仔细检查和优化 Webpack 的配置文件（如 <code>webpack.config.js</code>），确保所有配置选项都是必要的，并且没有不必要的重复或冗余。</li></ul></li></ol></blockquote><p>请注意，不同的项目可能需要采用不同的优化策略。在实施任何优化之前，最好先分析项目的具体需求和瓶颈，然后有针对性地进行优化。</p><h3 id="如何对bundle体积进行监控和分析？"><a href="#如何对bundle体积进行监控和分析？" class="headerlink" title="如何对bundle体积进行监控和分析？"></a>如何对bundle体积进行监控和分析？</h3><p>对Webpack打包后的bundle体积进行监控和分析，可以通过以下几种方法：</p><blockquote><ol><li><p><strong>使用Webpack Bundle Analyzer</strong></p><p>Webpack Bundle Analyzer是一个可视化的Webpack包分析工具，它可以将应用程序的bundle以树状图的形式展示，并显示每个模块的大小、包含的依赖关系等信息。通过这个工具，你可以快速定位到哪些模块或依赖项占用了较大的体积，从而进行针对性的优化。</p><p>使用方法：</p><ul><li>首先，安装Webpack Bundle Analyzer：<code>npm install --save-dev webpack-bundle-analyzer</code></li><li>在Webpack配置文件中（通常是<code>webpack.config.js</code>）引入并使用<code>BundleAnalyzerPlugin</code>插件。</li><li>运行Webpack构建命令，并在构建完成后，Webpack Bundle Analyzer将自动启动一个服务器，在浏览器中展示bundle分析的结果。</li></ul></li><li><p><strong>使用Bundlephobia</strong></p><p>Bundlephobia是一个在线工具，它可以帮助你分析npm包在不同环境下的真实大小和性能消耗。你可以将需要使用的npm包搜索到Bundlephobia上，并进行大小和依赖关系的分析，以便进行选择和优化。</p><p>使用方法：</p><ul><li>访问Bundlephobia的官方网站（<a href="https://bundlephobia.com/%EF%BC%89">https://bundlephobia.com/）</a></li><li>在搜索框中输入npm包的名称，点击搜索按钮。</li><li>查看npm包的大小、依赖关系等信息，并根据需要进行选择和优化。</li></ul></li><li><p><strong>手动分析Webpack打包后的文件</strong></p><p>你也可以通过手动分析Webpack打包后的文件来监控bundle体积。Webpack会将打包后的文件输出到指定的目录中，你可以通过查看这些文件的大小和内容来了解bundle的体积和组成。</p><p>具体步骤：</p><ul><li>找到Webpack打包后的文件输出目录（通常在<code>dist</code>或<code>build</code>目录下）。</li><li>使用文件大小查看工具（如Windows的资源管理器、Linux的<code>du</code>命令等）来查看打包后的文件大小。</li><li>使用文本编辑器或开发者工具打开打包后的文件，查看其内容和结构，了解哪些模块或依赖项占用了较大的体积。</li></ul></li></ol></blockquote><p>请注意，以上方法都可以帮助你监控和分析Webpack打包后的bundle体积，但具体选择哪种方法取决于你的项目需求和个人偏好。在进行分析时，重点关注那些体积较大的模块或依赖项，并根据实际情况进行优化。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>「 Tecvan: 一文吃透 Webpack 核心原理  」</li><li><a href="https://github.com/Cosen95/blog/issues/48">面试官：webpack原理都不会？</a></li><li><a href="https://developer.aliyun.com/article/61047">细说 webpack 之流程篇 </a></li><li><a href="https://juejin.cn/post/6844904094281236487">「吐血整理」再来一打Webpack面试题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo框架以及GitHub搭载个人博客网站 （小白向）</title>
      <link href="/2022/07/13/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/"/>
      <url>/2022/07/13/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该博文是博主的一个朋友想要了解个人博客网站的搭建而撰写的一篇简易的搭建教程。我贾哥说过学习巩固某一知识点的最好方法便是传授予他人。那么话不多削我们这就开始，因为这是个没有计算机基础的同学所以我会从最基础的地方开始撰写，篇幅可能会有点长请耐心食用。</p></blockquote><h4 id="0-首先最开始的一步就是-科学上网"><a href="#0-首先最开始的一步就是-科学上网" class="headerlink" title="0. 首先最开始的一步就是 科学上网"></a>0. 首先最开始的一步就是 科学上网</h4><blockquote><p>科学上网俗称 ‘翻墙上外网’，首先你要有能够翻墙上外网的能力才可以方便我们上GitHub去注册账户。当然也不局限与这一点，有了科学上网的能力你便可以使用谷歌搜索引擎以及浏览类似YouTube的国外网站或者某些奇奇怪怪的东西。（手动狗头.jpg）</p></blockquote><p>那么怎么进行科学上网（翻墙）呢 ？</p><p>咱也不展开来讲有兴趣的可以自行谷歌一下翻墙原理。</p><p>这里或许有人会和我吐槽我都翻不了墙怎么上谷歌？ 最简单的一个方法就是找一个一站式的翻墙软件。博主这里用的是 <a href="https://666yun.men/#/register?code=E9pw8QiO">蜂巢vpn</a> 这上面都有相应的一个使用教程的。</p><h4 id="1-注册GitHub账号以及下载对应的代码编辑器以及编程环境"><a href="#1-注册GitHub账号以及下载对应的代码编辑器以及编程环境" class="headerlink" title="1. 注册GitHub账号以及下载对应的代码编辑器以及编程环境"></a>1. 注册GitHub账号以及下载对应的代码编辑器以及编程环境</h4><p>既然能科学上网了就先去<a href="https://github.com/">GitHub</a>注册个账号吧 </p><p>然后下载所需的一个代码编辑器 这里推荐 <a href="https://www.runoob.com/w3cnote/vscode-tutorial.html">VSCode</a></p><p>下载完之后呢我们可以在桌面上新建一个文本文档，然后将其改名为.html后缀的文件，再通过右键或者拖拽至VSCode进行打开。</p><blockquote><p>tips: 如果不会的话可以先把下述代码贴在文本文档内再去更改为.html后缀 双击打开 </p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">  <span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">300</span>px <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>你好呀！ 隔壁黄阿姨 (*´▽｀)ノノ❤ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/helloAntHuang.png" alt="helloAntHuang"></p><p>这就是我们简单设计的静态页面啦，但是只能跑在自己的电脑上或者是把生成的.html发给别人，别人在自己的电脑上打开。</p><p>这时候距离我们建立一个个人博客网站的目标好像差了不是一星半点，若是我要教你自己通过这种方式一点点自己敲出来的话，你应该可以过来和我共事了__(:з」∠)_，怕你们抢我饭碗所以我们这里要借助第三方的框架来进行页面基础架构的搭建！（ 还要啥自行车╭(╯^╰)╮）。</p><p>但是我们要使用第三方插件的话 我们就得有一个nodejs的环境来执行下载的脚本</p><p>这里有个博主早期写的一个<a href="https://blog.csdn.net/Jayhodon/article/details/108308405?spm=1001.2014.3001.5501">nodeJs安装教程</a>可以参考一下。</p><h4 id="2-使用hexo框架进行个人博客搭建"><a href="#2-使用hexo框架进行个人博客搭建" class="headerlink" title="2. 使用hexo框架进行个人博客搭建"></a>2. 使用hexo框架进行个人博客搭建</h4><p>  我们可以在<a href="../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_install.png">hexo官网</a></p><p>  之前我们安装的nodejs就是为了能够执行第一条命令全局安装hexo的插件。</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/vscode_hexo.png" alt="安装Hexo插件"></p><p>按照上述步骤来的话，不出意外就是这样的。</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_init.png" alt="初始化Hexo框架"></p><p>根据提示按住Ctrl点击那个:4000的链接就可以跳转到对应页面<img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_init_page.png" alt="Hexo初始化页面"></p><p>这上面有一个简单介绍，具体的使用说明可以看<a href="https://hexo.io/zh-cn/docs/">官方文档</a></p><p>到这里你就成功的迈出了一大步了，接下来我们就可以去官网的主题Tab栏下面寻找你喜欢的博客主题。可以先在官方文档了解一下hexo的主题。这里博主采用的是 blinkfox 前辈的主题 <a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">教程开源主题介绍</a>。（前辈的使用教程写的很清楚简洁了我这里就不做多余的赘述了 【其实是现在已经快3点了 扛不住了 明晚再肝吧 晚安社会黄 <em><em>(:з」∠)</em></em> 】 ）</p><h4 id="3-挂载hexo主题框架"><a href="#3-挂载hexo主题框架" class="headerlink" title="3. 挂载hexo主题框架"></a>3. 挂载hexo主题框架</h4><p>接上文 我们通过 blinkfox 前辈的开源主题介绍 将下载并解压的hexo_theme主题文件放到blog文件夹下对应的theme文件夹下后，对_config.yml文件进行配置。</p><blockquote><p>这里博主一开始采用的这种方法，但是有些配置项比较麻烦，所以建议使用第二种方法，但是_congfig,yml的配置是一样的流程</p></blockquote><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_theme.png" alt="hexo_theme"></p><blockquote><p>但是用这种直接解压的方式可能会跑步起来 要进行一些其他的配置项 我不嫌麻烦 你们也会嫌麻烦把 （ 好吧我也嫌麻烦 x_x ）</p></blockquote><p>第二种方法就是在blog下的themes文件夹下打开终端，通过拉远程代码库的形式来部署主题文件。<img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_theme_clone.png" alt="拉取hexo主题代码"></p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo-theme-matery.png" alt="hexo-theme-matery"></p><p>成功启动后的页面就是这个样子哒~~~ ，是不是有一种刚刚还是在拧螺丝现在突然发现火箭突然起飞的感觉。</p><h4 id="4-发布个人博文"><a href="#4-发布个人博文" class="headerlink" title="4. 发布个人博文"></a>4. 发布个人博文</h4><p>既然博客的框架已经搭建好了，那么我们得用起来我们得发布文章呀。</p><blockquote><p>hexo新建文章的方式便是通过 hexo new ‘新建博文.md标题’</p></blockquote><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/new_post.png" alt="new_post"></p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_new_post.png" alt="新建的文章"></p><p>但是这样子通过VSCode自带的.md编辑器写博文是一件非常蛋疼的事情，对的没错我们又要借助第三方的工具了，博主这里使用的是 <a href="https://typoraio.cn/">Typora</a> 。我们可以使用类似的第三方Markdown编辑器来撰写我们的博文，然后将编辑排好版的.md文件直接贴到 source\posts 文件夹下再来发布博文 这样的体验会好一点。</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/typora.png" alt="typora"></p><blockquote><p> -–</p><p>title: 新建的博客标题</p><p> date: 2022-07-17 01:29:48</p><p>tags: 博客的类型标题</p><p> -– </p><p>记得将上面这一段加在博文.md文件的最前面哦 这是hexo识别文章的参数</p></blockquote><h4 id="4-博客个人配置化"><a href="#4-博客个人配置化" class="headerlink" title="4. 博客个人配置化"></a>4. 博客个人配置化</h4><p>首先是整个框架的的配置，这些在 blinkfox 前辈的 <a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">教程开源主题介绍 </a>中有一些个性化的配置没有打开 有兴趣的的可以查阅一下 写的已经很详细了 我就不一一赘述了。这里我着重讲一下如何去更改的一个 思路 / 方法 。</p><blockquote><p>我这里采用的是最笨的办法，也是最简单的办法，有更加简单的办法可以交流传阅一下 Thanks♪(･ω･)ﾉ </p></blockquote><ol><li>首先是_config.yml内的一个配置，这里可以更改hexo的一个默认配置。</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_author.png" alt="hexo_author"></p><ol start="2"><li>但是页面上的一些文案之类的要怎么处理呢，这里最简单的一个 方法/ 思路 就是将文案进行复制然后进行全局搜索进行替换。</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_style.png" alt="hexo_style"></p><p>这里我们以 【我的梦想】为例子</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_theme_config.png" alt="hexo_theme_config"></p><ol start="3"><li>如果博文内含有图片的话要记得将图片文件放到编译生成的public里的img文件夹内部 并在博文.md内修改引用的图片地址。（ 不小心又肝到了4点，这一块后面在写！）</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/change_img.png" alt="修改图片路径"></p><p>这里按照上图 将图片文件放在img文件下 并 更改文件路劲即可。 文件路径不清楚的可自行百度一下（一般按照上面这个路径也不会出错）</p><h4 id="6-部署在GitHub上"><a href="#6-部署在GitHub上" class="headerlink" title="6. 部署在GitHub上"></a>6. 部署在GitHub上</h4><p>在hexo的<a href="https://hexo.io/zh-cn/docs/github-pages">官方文档</a>上有如何部署到GitHub的讲解，有兴趣的可以前往查阅。</p><ol><li>安装Git</li></ol><p>  为了能把本地的项目上传到GitHub上去，我们就会需要使用到 Git — 【分布式版本控制工具】 <a href="https://git-scm.com/download/win">安装链接</a></p><p>  安装的时候选择好对应的位数无脑然后全部无脑默认下一步即可。</p><blockquote><p>   最后一步添加路径的时候选择 Use Git from the Windows Command 以便于我们可以直接在命令行里直接打开git</p></blockquote><p>  安装完后可以在命令行中输入<code>git --version</code> 来验证是否安装成功。</p><ol start="2"><li>登录GitHub并新建一个代码仓库</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/new_repository.png" alt="new_repository"></p><ol start="3"><li>设置github pages</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/init_github_pages.png" alt="初始化github pages"></p><p>选择好后拉到下面 点击 commit change 然后在回去刚刚那个页面就会看到有个提示</p><blockquote><p>  Your site is ready to be published at  【你的个人博客网站地址】</p></blockquote><p>打开这个地址就可以访问到你的个人博客网站啦，接下来就是把我们用hexo框架搭载的博客挂载上去了</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/github_pages.png" alt="github_pages"></p><ol start="4"><li>连接Github与本地</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/git_bush.png" alt="git_bush"></p><p>首先右键打开git bash，然后输入下面命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"用户名"</span><span class="token function">git</span> config --global user.email <span class="token string">"邮箱"</span></code></pre><p>然后生成密钥SSH key：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"邮箱"</span></code></pre><p>打开<a href="https://link.zhihu.com/?target=http://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>然后在git bash中输入</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub</code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><blockquote><p> Hi Jayhodon! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><ol start="5"><li>将远程代码库的代码下拉至本地</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/git_clone.png" alt="获取仓库里的远程代码链接"></p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/git_bash_clone.png" alt="拉取仓库里的远程代码"></p><blockquote><p>输入 git clone [你复制的SSH链接] </p><p>然后桌面上会出现一个拉下来的文件夹 这时候我们就把blog直接拷贝进去 并用 VSCode 打开这个文件夹</p></blockquote><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/blog_to_io.png" alt="文件传输"></p><ol start="6"><li>配置_config.yml 下的deploy参数</li></ol><blockquote><p>deploy:</p><p> type: ‘git’</p><p> repository: ‘github 上的 ssh链接’</p><p> branch: main</p></blockquote><ol start="7"><li>将代码部署到github上</li></ol><p>在终端输入以下指令 安装 hexo-deployer-git 插件</p><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><p><strong>此处附加上 hexo 框架常用的指令：</strong></p><table><thead><tr><th align="left">指令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>hexo clean &amp;&amp; hexo g</code></td><td align="left">清除本地项目并重新生成 （重新部署时使用）</td></tr><tr><td align="left"><code>hexo g</code></td><td align="left">重新生成</td></tr><tr><td align="left"><code>Hexo s</code></td><td align="left">开启本地预览</td></tr><tr><td align="left"><code>Hexo d</code></td><td align="left">推送到github</td></tr></tbody></table><p>安装成功后就可以输入命令： hexo g -d  来上传到对应的github地址。到了这里基本上就大功告成了。</p><blockquote><p>hexo clean 最好不要用 x_x </p><p>先用 hexo s 来本地查看 然后使用 hexo g -d 推代码 就够了</p></blockquote><p>安装成功后就可以输入命令： hexo g -d  来上传到对应的github地址。到了这里基本上就大功告成了。</p><h4 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h4><blockquote><p>​    这篇文章的是写给不懂相关计算机知识的小白的个人简易博客网站搭建的教程，通篇博主都以读者的角度出发。个人认为如果这一片文能够让一个小白能够搭建其属于自己的博客网站，那么这篇文就是有意义的。</p><p>​    现在是简单的教授了如何搭建以及发布博文，后续如果博主有时间的话会去更新一下个性化配置（诸如音乐播放器，视频播放器之类的博客小组件）以及使用上的优化（发布博文过于繁琐需要不断提交代码）之类的东西。</p><p>​    这里如果有小伙伴们是哪里卡住了 或者是不懂得都可以给我留言 工作之余我会改进一下 争取让这篇文成为有手就行的个人博客网站搭建教程搭建</p></blockquote><p>【这里着重感谢一下 blinkfox 前辈提供的hexo开源主题框架】</p><p>​    </p><h4 id="参考出处"><a href="#参考出处" class="headerlink" title="参考出处"></a>参考出处</h4><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">Hexo博客主题之hexo-theme-matery的介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用性前端代码片段【Note】</title>
      <link href="/2022/05/29/JavaScript-Codes/"/>
      <url>/2022/05/29/JavaScript-Codes/</url>
      
        <content type="html"><![CDATA[<p>。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 数组去重 * @param {*} arr */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">uniqueArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The first parameter must be an array'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><p>平常我们需要用到一个嵌套多层的对象中某些属性，会将其解构出来使用</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  part1<span class="token punctuation">:</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'零一'</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">23</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token punctuation">{</span> part1<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> age <span class="token punctuation">}</span><span class="token punctuation">,</span> part1 <span class="token punctuation">}</span> <span class="token operator">=</span> objconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>part1<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// {name: "零一", age: 23}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 零一  23</span></code></pre><h4 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> myMoney <span class="token operator">=</span> 1_000_000_000_000    <span class="token comment" spellcheck="true">// 这样写是没问题的，而且数字分割开后也更直观！！</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMoney<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 1000000000000</span></code></pre><h4 id="英文字符串首字母大写"><a href="#英文字符串首字母大写" class="headerlink" title="英文字符串首字母大写"></a>英文字符串首字母大写</h4><p>Javascript没有内置的首字母大写函数，因此我们可以使用以下代码。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> capitalize <span class="token operator">=</span> str <span class="token operator">=</span><span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">capitalize</span><span class="token punctuation">(</span><span class="token string">"follow for more"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Result: Follow for more</span></code></pre><h4 id="校验数字是奇数还是偶数"><a href="#校验数字是奇数还是偶数" class="headerlink" title="校验数字是奇数还是偶数"></a>校验数字是奇数还是偶数</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> isEven <span class="token operator">=</span> num <span class="token operator">=</span><span class="token operator">></span> num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isEven</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Result: True</span></code></pre><h4 id="求数字的平均值"><a href="#求数字的平均值" class="headerlink" title="求数字的平均值"></a>求数字的平均值</h4><p>使用<code>reduce</code>方法找到多个数字之间的平均值。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> average <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> args<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">/</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token function">average</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: 2.5</span></code></pre><h4 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h4><p>可以使用 <code>split</code>、<code>reverse</code> 和 <code>join</code> 方法轻松反转字符串。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> reverse <span class="token operator">=</span> str <span class="token operator">=</span><span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Result: 'dlrow olleh'</span></code></pre><h4 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h4><p>可以使用<code>sort</code> 和 <code>random</code> 方法打乱数组</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> shuffleArray <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0.5</span> <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">shuffleArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: [ 1, 4, 3, 2 ]</span></code></pre><h4 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h4><p>使用场景：用于前端生成随机的ID,毕竟现在的Vue和React都需要绑定key</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> str <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 'w5jetivt7e'</span></code></pre><h4 id="保留到小数点以后n位"><a href="#保留到小数点以后n位" class="headerlink" title="保留到小数点以后n位"></a>保留到小数点以后n位</h4><p>使用场景：JS的浮点数超长，有时候页面显示时需要保留2位小数</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 保留小数点以后几位，默认2位</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">cutNumber</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> no <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> number <span class="token operator">!=</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        number <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">Number</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="cleanObject-去除对象中value为空的属性"><a href="#cleanObject-去除对象中value为空的属性" class="headerlink" title="cleanObject - 去除对象中value为空的属性"></a>cleanObject - 去除对象中value为空的属性</h4><p>去除对象中value为空(null,undefined,’’)的属性,举个栗子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">const</span> isFalsy <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> <span class="token operator">!</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> isVoid <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>  value <span class="token operator">===</span> undefined <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> cleanObject <span class="token operator">=</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Object.assign({}, object)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">;</span>  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> value <span class="token operator">=</span> result<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isVoid</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">delete</span> result<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> res<span class="token operator">=</span><span class="token function">cleanObject</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    name<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span>    pageSize<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">,</span>    page<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"res"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//输入{page:1,pageSize:10}</span></code></pre><h3 id="颜色相关"><a href="#颜色相关" class="headerlink" title="颜色相关"></a>颜色相关</h3><h4 id="颜色RGB转十六进制"><a href="#颜色RGB转十六进制" class="headerlink" title="颜色RGB转十六进制"></a>颜色RGB转十六进制</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> rgbToHex <span class="token operator">=</span> <span class="token punctuation">(</span>r<span class="token punctuation">,</span> g<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"#"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>g <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">rgbToHex</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Result: #0033ff</span></code></pre><h4 id="生成随机十六进制颜色"><a href="#生成随机十六进制颜色" class="headerlink" title="生成随机十六进制颜色"></a>生成随机十六进制颜色</h4><p>可以使用 <code>Math.random</code> 和 <code>padEnd</code> 属性生成随机的十六进制颜色。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> randomHex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token template-string"><span class="token string">`#</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0xffffff</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">randomHex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: #92b008</span></code></pre><h3 id="日期相关"><a href="#日期相关" class="headerlink" title="日期相关"></a>日期相关</h3><h4 id="检查日期是否合法"><a href="#检查日期是否合法" class="headerlink" title="检查日期是否合法"></a>检查日期是否合法</h4><p>使用以下代码段检查给定日期是否有效。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> isDateValid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">!</span>Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token operator">...</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">isDateValid</span><span class="token punctuation">(</span><span class="token string">"December 17, 1995 03:24:00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: true</span></code></pre><h4 id="查找日期位于一年中的第几天"><a href="#查找日期位于一年中的第几天" class="headerlink" title="查找日期位于一年中的第几天"></a>查找日期位于一年中的第几天</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> dayOfYear <span class="token operator">=</span> <span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>      Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>date <span class="token operator">-</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dayOfYear</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: 272</span></code></pre><h4 id="计算2个日期之间相差多少天"><a href="#计算2个日期之间相差多少天" class="headerlink" title="计算2个日期之间相差多少天"></a>计算2个日期之间相差多少天</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> dayDif <span class="token operator">=</span> <span class="token punctuation">(</span>date1<span class="token punctuation">,</span> date2<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>date1<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> date2<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">86400000</span><span class="token punctuation">)</span>    <span class="token function">dayDif</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">"2020-10-21"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">"2021-10-22"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Result: 366</span></code></pre><h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h4 id="从-URL-获取查询参数"><a href="#从-URL-获取查询参数" class="headerlink" title="从 URL 获取查询参数"></a>从 URL 获取查询参数</h4><p>可以通过传递 <code>window.location</code> 或原始 URL <code>goole.com?search=easy&amp;page=3</code>轻松地从 url 检索查询参数</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> getParameters <span class="token operator">=</span> <span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  URL <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>    <span class="token string">'{"'</span> <span class="token operator">+</span>      <span class="token function">decodeURI</span><span class="token punctuation">(</span>URL<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"?"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token string">"/g, '\\"</span>'<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&amp;/g</span><span class="token punctuation">,</span> <span class="token string">'","'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/=/g</span><span class="token punctuation">,</span> <span class="token string">'":"'</span><span class="token punctuation">)</span> <span class="token operator">+</span>      <span class="token string">'"}'</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">getParameters</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: { search : "easy", page : 3 }</span></code></pre><p>或者更为简单的：</p><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>search<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Result: { search : "easy", page : 3 }</span></code></pre><h4 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h4><p>可以使用 <code>window.scrollTo(0, 0)</code> 方法自动滚动到顶部。将 <code>x</code> 和 <code>y</code> 都设置为 0。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> goToTop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> window<span class="token punctuation">.</span><span class="token function">scrollTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">goToTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="休眠指定毫秒数"><a href="#休眠指定毫秒数" class="headerlink" title="休眠指定毫秒数"></a>休眠指定毫秒数</h4><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 休眠xxxms * @param {Number} milliseconds */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用方式</span><span class="token keyword">const</span> fetchData<span class="token operator">=</span><span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="复制内容到剪贴板"><a href="#复制内容到剪贴板" class="headerlink" title="复制内容到剪贴板"></a>复制内容到剪贴板</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">copyToBoard</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'textarea'</span><span class="token punctuation">)</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>    element<span class="token punctuation">.</span>value <span class="token operator">=</span> value    element<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">execCommand</span><span class="token punctuation">(</span><span class="token string">'copy'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        document<span class="token punctuation">.</span><span class="token function">execCommand</span><span class="token punctuation">(</span><span class="token string">'copy'</span><span class="token punctuation">)</span>        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><blockquote><p> 原理：</p><ol><li>创建一个textare元素并调用select()方法选中</li><li>document.execCommand(‘copy’)方法，拷贝当前选中内容到剪贴板。</li></ol></blockquote><p>借助<code>navigator.clipboard.writeText</code>可以很容易的讲文本复制到剪贴板</p><blockquote><p>规范要求在写入剪贴板之前使用 Permissions API 获取“剪贴板写入”权限。但是，不同浏览器的具体要求不同，因为这是一个新的API。有关详细信息，请查看compatibility table and Clipboard availability in Clipboard。</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> copyToClipboard <span class="token operator">=</span> <span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> navigator<span class="token punctuation">.</span>clipboard<span class="token punctuation">.</span><span class="token function">writeText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">copyToClipboard</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="获取用户选择的文本"><a href="#获取用户选择的文本" class="headerlink" title="获取用户选择的文本"></a>获取用户选择的文本</h4><p>使用内置的<code>getSelection</code> 属性获取用户选择的文本。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> getSelectedText <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> window<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getSelectedText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="获取浏览器Cookie的值"><a href="#获取浏览器Cookie的值" class="headerlink" title="获取浏览器Cookie的值"></a>获取浏览器Cookie的值</h4><p>通过<code>document.cookie</code> 来查找<code>cookie</code>值</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> cookie <span class="token operator">=</span> name <span class="token operator">=</span><span class="token operator">></span> <span class="token template-string"><span class="token string">`; </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>document<span class="token punctuation">.</span>cookie<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`; </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cookie</span><span class="token punctuation">(</span><span class="token string">'_ga'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Result: "GA1.2.1929736587.1601974046"</span></code></pre><h4 id="清除全部Cookie"><a href="#清除全部Cookie" class="headerlink" title="清除全部Cookie"></a>清除全部Cookie</h4><p>通过使用<code>document.cookie</code>访问cookie并将其清除，可以轻松清除网页中存储的所有cookie。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> clearCookies <span class="token operator">=</span> document<span class="token punctuation">.</span>cookie<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cookie <span class="token operator">=</span><span class="token operator">></span> document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> cookie<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^ +/</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/=.*/</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`=;expires=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUTCString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;path=/`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><h4 id="获取文件后缀名"><a href="#获取文件后缀名" class="headerlink" title="获取文件后缀名"></a>获取文件后缀名</h4><p>使用场景：上传文件判断后缀名</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 获取文件后缀名 * @param {String} filename */</span> <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getExt</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> filename <span class="token operator">==</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> filename            <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'filename must be a string type'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="对象转化为FormData对象"><a href="#对象转化为FormData对象" class="headerlink" title="对象转化为FormData对象"></a>对象转化为FormData对象</h4><p>使用场景：上传文件时我们要新建一个FormData对象，然后有多少个参数就append多少次，使用该函数可以简化逻辑</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 对象转化为formdata * @param {Object} object */</span> <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getFormData</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> value <span class="token operator">=</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>subValue<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>                formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token template-string"><span class="token string">`[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">]`</span></span><span class="token punctuation">,</span> subValue<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> formData<span class="token punctuation">}</span></code></pre><p>使用方式：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> req<span class="token operator">=</span><span class="token punctuation">{</span>    file<span class="token punctuation">:</span>xxx<span class="token punctuation">,</span>    userId<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>    phone<span class="token punctuation">:</span><span class="token string">'15198763636'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token function">getFormData</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="下载一个excel文档"><a href="#下载一个excel文档" class="headerlink" title="下载一个excel文档"></a>下载一个excel文档</h4><p>同时适用于word,ppt等浏览器不会默认执行预览的文档,也可以用于下载后端接口返回的流数据。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//下载一个链接 </span><span class="token keyword">function</span> <span class="token function">download</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>        name<span class="token operator">=</span>link<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> eleLink <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>    eleLink<span class="token punctuation">.</span>download <span class="token operator">=</span> name    eleLink<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>    eleLink<span class="token punctuation">.</span>href <span class="token operator">=</span> link    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">)</span>    eleLink<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下载excel</span><span class="token function">download</span><span class="token punctuation">(</span><span class="token string">'http://111.229.14.189/file/1.xlsx'</span><span class="token punctuation">)</span></code></pre><h5 id="在浏览器中自定义下载一些内容"><a href="#在浏览器中自定义下载一些内容" class="headerlink" title="在浏览器中自定义下载一些内容"></a>在浏览器中自定义下载一些内容</h5><p>场景：我想下载一些DOM内容，我想下载一个JSON文件</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 浏览器下载静态文件 * @param {String} name 文件名 * @param {String} content 文件内容 */</span><span class="token keyword">function</span> <span class="token function">downloadFile</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> name <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The first parameter name is a must'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> content <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The second parameter content is a must'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>content <span class="token keyword">instanceof</span> <span class="token class-name">Blob</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        content <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>content<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> link <span class="token operator">=</span> URL<span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>    <span class="token function">download</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>使用方式：</p><pre class=" language-js"><code class="language-js"><span class="token function">downloadFile</span><span class="token punctuation">(</span><span class="token string">'1.txt'</span><span class="token punctuation">,</span><span class="token string">'lalalallalalla'</span><span class="token punctuation">)</span><span class="token function">downloadFile</span><span class="token punctuation">(</span><span class="token string">'1.json'</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'hahahha'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h5 id="下载后端返回的流"><a href="#下载后端返回的流" class="headerlink" title="下载后端返回的流"></a>下载后端返回的流</h5><pre class=" language-js"><code class="language-js"> <span class="token function">download</span><span class="token punctuation">(</span><span class="token string">'http://111.229.14.189/gk-api/util/download?file=1.jpg'</span><span class="token punctuation">)</span> <span class="token function">download</span><span class="token punctuation">(</span><span class="token string">'http://111.229.14.189/gk-api/util/download?file=1.mp4'</span><span class="token punctuation">)</span></code></pre><h5 id="提供一个图片链接，点击下载"><a href="#提供一个图片链接，点击下载" class="headerlink" title="提供一个图片链接，点击下载"></a>提供一个图片链接，点击下载</h5><p>图片、pdf等文件，浏览器会默认执行预览，不能调用download方法进行下载，需要先把图片、pdf等文件转成blob，再调用download方法进行下载，转换的方式是使用axios请求对应的链接</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//可以用来下载浏览器会默认预览的文件类型，例如mp4,jpg等</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token comment" spellcheck="true">//提供一个link，完成文件下载，link可以是  http://xxx.com/xxx.xls</span><span class="token keyword">function</span> <span class="token function">downloadByLink</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span>fileName<span class="token punctuation">)</span><span class="token punctuation">{</span>    axios<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        url<span class="token punctuation">:</span> link<span class="token punctuation">,</span>        responseType<span class="token punctuation">:</span> <span class="token string">'blob'</span> <span class="token comment" spellcheck="true">//关键代码，让axios把响应改成blob</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">const</span> link<span class="token operator">=</span>URL<span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>        <span class="token function">download</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> fileName<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：会有同源策略的限制，需要配置转发</p></blockquote><h3 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h3><h4 id="解决ios-audio无法自动播放、循环播放的问题"><a href="#解决ios-audio无法自动播放、循环播放的问题" class="headerlink" title="解决ios audio无法自动播放、循环播放的问题"></a>解决ios audio无法自动播放、循环播放的问题</h4><p><code>ios</code>手机在使用<code>audio</code>或者<code>video</code>播放的时候，个别机型无法实现自动播放，可使用下面的代码<code>hack</code>。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 解决ios audio无法自动播放、循环播放的问题</span><span class="token keyword">var</span> music <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'video'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'touchstart'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>state<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        music<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        state<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"WeixinJSBridgeReady"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    music<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//循环播放</span>music<span class="token punctuation">.</span>onended <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    music<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    music<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="检查用户的设备是否处于暗模式"><a href="#检查用户的设备是否处于暗模式" class="headerlink" title="检查用户的设备是否处于暗模式"></a>检查用户的设备是否处于暗模式</h4><p>使用以下代码检查用户的设备是否处于暗模式。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> isDarkMode <span class="token operator">=</span> window<span class="token punctuation">.</span>matchMedia <span class="token operator">&amp;&amp;</span> window<span class="token punctuation">.</span><span class="token function">matchMedia</span><span class="token punctuation">(</span><span class="token string">'(prefers-color-scheme: dark)'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>matches    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isDarkMode<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Result: True or False</span></code></pre><h2 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h2><h3 id="Css相关"><a href="#Css相关" class="headerlink" title="Css相关"></a>Css相关</h3><h4 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h4><p>这是一个<code>css</code>属性，我一般称之为<code>css</code>表达式。可以计算<code>css</code>的值。最有趣的是他可以计算不同单位的差值。很好用的一个功能，缺点是不容易阅读。接盘侠没办法一眼看出<code>20px</code>是啥。</p><pre class=" language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">25%</span> - <span class="token number">20</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="使用css写出一个三角形角标"><a href="#使用css写出一个三角形角标" class="headerlink" title="使用css写出一个三角形角标"></a>使用css写出一个三角形角标</h4><p>元素宽高设置为<code>0</code>，通过<code>border</code>属性来设置，让其它三个方向的<code>border</code>颜色为透明或者和背景色保持一致，剩余一条<code>border</code>的颜色设置为需要的颜色。</p><pre class=" language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">5</span>px solid #transparent<span class="token punctuation">;</span>    <span class="token property">border-top-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><p>我一般只使用两种方式<code>定位</code>或者<code>flex</code>，我觉得够用了。</p><pre class=" language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>父级控制子集居中</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>    <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="css一行文本超出…"><a href="#css一行文本超出…" class="headerlink" title="css一行文本超出…"></a>css一行文本超出…</h4><pre class=" language-css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span><span class="token property">text-overflow</span><span class="token punctuation">:</span>ellipsis<span class="token punctuation">;</span><span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span></code></pre><h4 id="多行文本超出显示…"><a href="#多行文本超出显示…" class="headerlink" title="多行文本超出显示…"></a>多行文本超出显示…</h4><pre class=" language-css"><code class="language-css"><span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span><span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span><span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span></code></pre><h4 id="IOS手机容器滚动条滑动不流畅"><a href="#IOS手机容器滚动条滑动不流畅" class="headerlink" title="IOS手机容器滚动条滑动不流畅"></a>IOS手机容器滚动条滑动不流畅</h4><pre class=" language-css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token property">-webkit-overflow-scrolling</span><span class="token punctuation">:</span> touch<span class="token punctuation">;</span></code></pre><h4 id="修改滚动条样式"><a href="#修改滚动条样式" class="headerlink" title="修改滚动条样式"></a>修改滚动条样式</h4><p>隐藏<code>div</code>元素的滚动条</p><pre class=" language-css"><code class="language-css"><span class="token selector">div<span class="token pseudo-element">::-webkit-scrollbar</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p> div::-webkit-scrollbar 滚动条整体部分div::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）</p><p>div::-webkit-scrollbar-track 滚动条的轨道</p><p>div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。</p><p>div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分</p><p>div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</p><p>div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件</p><p><strong>注意此方案有兼容性问题</strong>，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用overflow-hidden截掉滚动条部分。暴力且直接。</p></blockquote><h4 id="隐藏页面元素"><a href="#隐藏页面元素" class="headerlink" title="隐藏页面元素"></a>隐藏页面元素</h4><blockquote><p> display-none: 元素不会占用空间，在页面中不显示，子元素也不会显示。</p><p>opacity-0: 元素透明度将为<code>0</code>，但元素仍然存在，绑定的事件仍旧有效仍可触发执行。</p><p>visibility-hidden：元素隐藏，但元素仍旧存在，占用空间，页面中无法触发该元素的事件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 个人知识库 </tag>
            
            <tag> JavaScript-Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jayhodon&#39;s Demo</title>
      <link href="/2022/03/03/Jayhodon-s-Demo/"/>
      <url>/2022/03/03/Jayhodon-s-Demo/</url>
      
        <content type="html"><![CDATA[<h3 id="将canvas所绘制的图像转成图片格式保存到本地"><a href="#将canvas所绘制的图像转成图片格式保存到本地" class="headerlink" title="将canvas所绘制的图像转成图片格式保存到本地"></a>将canvas所绘制的图像转成图片格式保存到本地</h3><ol><li><p><strong>首先base64图片格式一般都是以下形式：</strong></p><!-- ‘data:image/jpeg;base64, […base64编码]’ --></li><li><p><strong>当我们在使用canvas绘图完成后可使用 .toDataURL( )来得到所绘制图像的base64编码数据形式</strong><img src="/../images/Jayhodon-s-Demo/baseToImg_1.jpg" alt="toDataURL"></p></li><li><p><strong>当然也可以将图片格式转成base64格式</strong><img src="/../images/Jayhodon-s-Demo/baseToImg_2.jpg" alt="imgToBase"></p></li><li><p>输出指定文件夹处理<br>首先我们需要使用引入第三方工具类，即是</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span>‘fs’<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre></li></ol><p><img src="/../images/Jayhodon-s-Demo/baseToImg_3.jpg" alt="Save"></p><h3 id="Css-content-visibility属性-虚拟滚动"><a href="#Css-content-visibility属性-虚拟滚动" class="headerlink" title="Css: content-visibility属性 [虚拟滚动]"></a>Css: content-visibility属性 [虚拟滚动]</h3><blockquote><p>content-visibility是一个css属性，它控制一个元素是否呈现其内容，能让用户潜在地控制元素的呈现。用户可以使用它跳过元素的呈现(包括布局和绘制)，直到用户需要为止，让页面的初始渲染得到极大的提升。</p></blockquote><p><strong>content-visibility</strong> 属性有三个可选值:</p><blockquote><ul><li><p>visible: 默认值。对布局和呈现不会产生什么影响。</p></li><li><p>hidden: 元素跳过其内容的呈现。用户代理功能（例如，在页面中查找，按Tab键顺序导航等）不可访问已跳过的内容，也不能选择或聚焦。类似于对其内容设置了display: none属性。</p></li><li><p>auto: 对于用户可见区域的元素，浏览器会正常渲染其内容；对于不可见区域的元素，浏览器会暂时跳过其内容的呈现，等到其处于用户可见区域时，浏览器在渲染其内容。</p></li></ul></blockquote><ul><li><strong>ps</strong>: content-visibility是chrome85今年新增的特性，所以目前兼容性还不高，但是相信兼容性的问题在不久的将来会得到解决。</li></ul><p>​    当元素的部分内容如<code>&lt;img /&gt;</code>标签这种，元素的高度是有图片内容决定的，因此在这种情况下，如果使用<code>content-visibility</code>，则可见视图外的img初始未渲染，高度为0，随着滚动条向下滑动，页面高度增加，会导致滚动条的滚动有问题。</p><p>​    为了解决此问题，如果在已知元素高度的情况下，可以使用<code>contains-intrinsic-size</code>属性，为上面的card添加：<code>contains-intrinsic-size：312px;</code>，这会给内容附一个初始高度值。（如果高度不固定也可以附一个大致的初始高度值，会使滚动条问题相对减少）。</p><pre class=" language-css"><code class="language-css">    <span class="token selector">&lt;style type="text/css">      <span class="token class">.card</span> </span><span class="token punctuation">{</span>        <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>        <span class="token property">content-visibility</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>        <span class="token property">contain-intrinsic-size</span><span class="token punctuation">:</span> <span class="token number">312</span>px<span class="token punctuation">;</span> // 添加此行      <span class="token punctuation">}</span>    &lt;/style></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法相关</title>
      <link href="/2021/09/18/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/09/18/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-反抖节流："><a href="#1-反抖节流：" class="headerlink" title="1. 反抖节流："></a>1. 反抖节流：</h2><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>点击了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>次<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>debounce<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> debounce <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>throttle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> throttle <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">function</span> <span class="token function">calCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"count"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            count<span class="token operator">++</span>            ele<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count        <span class="token punctuation">}</span>        <span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token keyword">await</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>                timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">await</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token keyword">await</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> preTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-</span>preTime<span class="token operator">>=</span><span class="token keyword">await</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span>                    preTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> btn_1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"debounce"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_1<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token function">debounce</span><span class="token punctuation">(</span>calCount<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> btn_2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"throttle"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_2<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span>calCount<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h2 id="2-深浅拷贝"><a href="#2-深浅拷贝" class="headerlink" title="2. 深浅拷贝"></a>2. 深浅拷贝</h2><blockquote><ol><li>深拷贝和浅拷贝值针对 Object 和 Array 这样的复杂类型 </li><li> a 和 b 指向了同一块内存，所以修改其中任意一个值，另外一个值也会随 之变化，这是浅拷贝 </li><li>a 和 b 指向同一块内存，但是修改其中任意一个值，另外一个调用的变量， 不会受到影响，这是深拷贝 </li><li> 浅拷贝:“Object.assign()”方法用于将所有可枚举的属性的值从一个或 多个源对象复制到目标对象，它将返回目标对象 </li><li> 深拷贝：JSON.parse( )和 JSON.stringify( )给了我们一个基本的解决办 法。但是函数不能被正确处理</li></ol></blockquote><pre class=" language-js"><code class="language-js">        <span class="token comment" spellcheck="true">//浅拷贝</span>        <span class="token keyword">function</span> <span class="token function">shallowCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">var</span> target <span class="token operator">=</span> obj<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array<span class="token operator">?</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> target        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*浅拷贝实现方式：            Object.assign()            ...(扩展运算符)            concat（数组方法）            lodash clone        */</span>        <span class="token comment" spellcheck="true">/*深拷贝实现方式：            $.extend        */</span>        <span class="token comment" spellcheck="true">//深拷贝</span>        <span class="token comment" spellcheck="true">//乞丐版</span>        <span class="token keyword">var</span> newObj <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>someObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//面试版</span>        <span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//判断是否是简单数据类型，</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">==</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//复杂数据类型</span>                <span class="token keyword">var</span> result <span class="token operator">=</span> obj<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"object"</span> <span class="token operator">?</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//简单数据类型 直接 == 赋值</span>                <span class="token keyword">var</span> result <span class="token operator">=</span> obj<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><h2 id="3-ajax"><a href="#3-ajax" class="headerlink" title="3. ajax"></a>3. ajax</h2><p>ajax 是通过 XMLHttpRequest 对象实现的，这个对象有很多的属性和事件:</p><blockquote><p>xhr 具有一个 open 方法，这个方法的作用类似于初始化，并不会发起真正的请求<br>open 方法具有 5 个参数，但是常用的是前 3 个<br>method： 请求方式 —— get / post<br>url：请求的地址<br>async：是否异步请求，默认为 true（异步）<br>xhr.open(method, url, async)</p></blockquote><blockquote><p>send 方法发送请求，并接受一个可选参数<br>当请求方式为 post 时，可以将请求体的参数传入<br>当请求方式为 get 时，可以不传或传入 null<br>不管是 get 还是 post，参数都需要通过 encodeURIComponent 编码后拼接<br>xhr.send(data)</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>手写ajax<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'/api'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// xhr.readyState 的各个状态</span>        <span class="token comment" spellcheck="true">// 0：未初始化，还没有调用send()方法</span>        <span class="token comment" spellcheck="true">// 1：载入，已调用send()方法，正在发送请求</span>        <span class="token comment" spellcheck="true">// 2：载入完成，send()方法执行完成，已经接收到全部响应内容</span>        <span class="token comment" spellcheck="true">// 3：交互，正在解析响应内容</span>        <span class="token comment" spellcheck="true">// 4：完成，响应内容解析完成，可以再客户端调用</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span><span class="token string">'/api'</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> postData<span class="token operator">=</span><span class="token punctuation">{</span>        userName<span class="token punctuation">:</span><span class="token string">'Jayhodon'</span><span class="token punctuation">,</span>        password<span class="token punctuation">:</span><span class="token string">'Jayhodon'</span>    <span class="token punctuation">}</span>    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>postData<span class="token punctuation">)</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>通过 Promise 方式实现回调:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> ajax <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> url <span class="token operator">=</span> options<span class="token punctuation">.</span>url        <span class="token keyword">const</span> method <span class="token operator">=</span> options<span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">toLocaleLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">'get'</span>        <span class="token keyword">const</span> <span class="token keyword">async</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token operator">!=</span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">// default is true</span>        <span class="token keyword">const</span> data <span class="token operator">=</span> options<span class="token punctuation">.</span>data        <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>timeout <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>timeout <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> options<span class="token punctuation">.</span>timeout        <span class="token punctuation">}</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            xhr<span class="token punctuation">.</span>ontimeout <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> reject <span class="token operator">&amp;&amp;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'请求超时'</span><span class="token punctuation">)</span>            xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        resolve <span class="token operator">&amp;&amp;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        reject <span class="token operator">&amp;&amp;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            xhr<span class="token punctuation">.</span>onerror <span class="token operator">=</span> err <span class="token operator">=</span><span class="token operator">></span> reject <span class="token operator">&amp;&amp;</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>             <span class="token keyword">let</span> paramArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">let</span> encodeData            <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 参数拼接需要通过 encodeURIComponent 进行编码</span>                    paramArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'='</span> <span class="token operator">+</span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>                <span class="token punctuation">}</span>                encodeData <span class="token operator">=</span> paramArr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">===</span> <span class="token string">'get'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// 检测 url 中是否已存在 ? 及其位置</span>                <span class="token keyword">const</span> index <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> url <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'?'</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> url<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> url <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'&amp;'</span>                  <span class="token comment" spellcheck="true">// 拼接 url</span>                url <span class="token operator">+</span><span class="token operator">=</span> encodeData            <span class="token punctuation">}</span>             xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token keyword">async</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">===</span> <span class="token string">'get'</span><span class="token punctuation">)</span> xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// post 方式需要设置请求头</span>                xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span><span class="token string">'application/x-www-form-urlencoded;charset=UTF-8'</span><span class="token punctuation">)</span>                xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>encodeData<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><p>使用方式:</p><pre class=" language-js"><code class="language-js"><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    url<span class="token punctuation">:</span> <span class="token string">'your request url'</span><span class="token punctuation">,</span>    method<span class="token punctuation">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>    <span class="token keyword">async</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    timeout<span class="token punctuation">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        aaa<span class="token punctuation">:</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    res <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'请求成功: '</span> <span class="token operator">+</span> res<span class="token punctuation">)</span><span class="token punctuation">,</span>    err <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'请求失败: '</span> <span class="token operator">+</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>axios拦截器</p><h2 id="4-十种经典排序算法"><a href="#4-十种经典排序算法" class="headerlink" title="4. 十种经典排序算法"></a>4. 十种经典排序算法</h2><p><a href="https://juejin.cn/post/6921496910080114702">转自：你能手撕10种经典排序算法吗？</a></p><h2 id="5-图片懒加载"><a href="#5-图片懒加载" class="headerlink" title="5. 图片懒加载"></a>5. 图片懒加载</h2><p>图片懒加载理解：</p><p>​        由于商城图片过多时，就会给图片加一个懒加载的缓冲效 果。当图片进入可视化区域的时候才会加载，否则图片只是一个空标签。这样可 以优化页面渲染速度，提升用户体验。 </p><p>思路：</p><p>​        将页面中的所有 img 属性 src 用 data-src 代替，当页面滚动至此图 片出现在可视区域时，用 js 取到该图片的 data-src 值赋给 src。 </p><p>所用知识点： </p><blockquote><p>​        浏览器可视区域的宽高：</p><p>​        js :  document.body.clientWidth/clientHeight </p><p>​        jquery: var windHeight = $(window).width()/$(window).height(); </p><p>​        获取滚动条相对于顶部的高度:</p><p>​         js : document.body.scrollTop;</p><p>​         jquery : var scrollTop=$(window).scrollTop; </p><p>​        获得元素对于浏览器顶部的高度:</p><p>​         js : DOM 元素.offsetTop; </p><p>​         jquery: var imgTop=$(‘img’).offset().top </p><p>​        判断元素是否出现在浏览器的可视化区域内: </p><p>​        元素相对于顶部的高度 - 浏览器可视化区域的高度 &lt; 小于滚动条 到顶部的高度 </p><p>​        成立就代表出现 : 不成立就没出现 </p><p>​        怎样排除首屏的图片 </p><p>​        元素到顶部距离 - 浏览器的可视化高度 &gt; 0 排除已加载的图片 $(this).attr(‘src’) != $(this).attr(‘data-src’) //排除已加载 的图片</p></blockquote><p><strong>offsetWidth/offsetHeight、clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</strong></p><blockquote><p>offfsetWidth、offsetHeight 返回值包含 content+padding+border，效 果与 e.getBoundingClientRect（）相同 </p><p>clientWidth、clientHieight 返回值值包含 content+padding，如果有滚 动条，也不包含滚动条 </p><p>scrollWidth、scrollHeight 返回值包含 content+padding+溢出内容的尺 寸</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 算法相关 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识体系</title>
      <link href="/2021/07/10/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
      <url>/2021/07/10/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前端知识体系"><a href="#前端知识体系" class="headerlink" title="前端知识体系"></a>前端知识体系</h1><blockquote><p>​    这篇文章的目标主要是梳理出一个较为完整的个人前端向知识体系。文章主要是以<strong>从输入URL到页面加载</strong>这个问题所梳理的文章，由于这个问题所涵盖的面十分的广阔，可以说是非常适合个人前端知识体系的搭建了。</p></blockquote><h2 id="搭建基础架构"><a href="#搭建基础架构" class="headerlink" title="搭建基础架构"></a>搭建基础架构</h2><p>对于个人知识体系的搭建，最为重要的一点便是对基础架构的搭建，有了一个大体的架构后才方便填充细节。以下便是<strong>从输入URL到页面加载</strong>的一个基础架构：</p><blockquote><ol><li><p>从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</p></li><li><p>开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</p></li><li><p>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</p></li><li><p>后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</p></li><li><p>单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</p></li><li><p>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</p></li><li><p>CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</p></li><li><p>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p></li><li><p>其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</p></li></ol></blockquote><h3 id="从浏览器接收url到开启网络请求线程"><a href="#从浏览器接收url到开启网络请求线程" class="headerlink" title="从浏览器接收url到开启网络请求线程"></a>从浏览器接收url到开启网络请求线程</h3><h4 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h4><p>由于浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）</p><blockquote><p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li></ul></blockquote><h4 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h4><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p><p><img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/kernel-thread.jpg" alt="内核线程"></p><p>可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的</p><h4 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h4><p>输入URL后，会进行解析（URL的本质就是统一资源定位符）</p><p>URL一般包括几大部分：</p><blockquote><p><code>protocol</code>，协议头，譬如有http，ftp等</p><p><code>host</code>，主机域名或IP地址</p><p><code>port</code>，端口号</p><p><code>path</code>，目录路径</p><p><code>query</code>，即查询参数</p><p><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</p></blockquote><h4 id="网络请求都是单独的线程"><a href="#网络请求都是单独的线程" class="headerlink" title="网络请求都是单独的线程"></a>网络请求都是单独的线程</h4><p>每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p><h3 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" class="headerlink" title="开启网络线程到发出一个完整的http请求"></a>开启网络线程到发出一个完整的http请求</h3><h4 id="DNS查询得到IP"><a href="#DNS查询得到IP" class="headerlink" title="DNS查询得到IP"></a>DNS查询得到IP</h4><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p><blockquote><ul><li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host</li><li>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP</li></ul></blockquote><p>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</p><p>而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化</p><h4 id="tcp-ip请求"><a href="#tcp-ip请求" class="headerlink" title="tcp/ip请求"></a>tcp/ip请求</h4><p>http的本质就是 tcp/ip 请求,且tcp/ip协议是传输层面向连接的一个安全可靠的连接协议。tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输，这里需要了解3次握手规则建立连接以及断开连接时的四次挥手。</p><h4 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h4><p><img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-message-format.jpg" alt="tcp报文格式"></p><blockquote><p>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p><p>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p><p>​    URG：紧急指针（urgent pointer）有效。</p><p>​    ACK：确认序号有效。</p><p>​    PSH：接收方应该尽快将这个报文交给应用层。</p><p>​    RST：重置连接。</p><p>​    SYN：发起一个新连接。</p><p>​    FIN：释放一个连接。</p></blockquote><p>需要注意的是：</p><p>（A）不要将确认序号Ack与标志位中的ACK搞混了。</p><p>（B）确认方Ack=发起方Req+1，两端配对。</p><h4 id="三次握手的步骤："><a href="#三次握手的步骤：" class="headerlink" title="三次握手的步骤："></a><strong>三次握手的步骤：</strong></h4><p>采用三次握手建立一个安全可靠的连接.</p><blockquote><p>客户端：hello，你是server么？<br>服务端：hello，我是server，你是client么<br>客户端：yes，我是client</p></blockquote><p>具体过程如下:</p><p>建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p><p><img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-handshake.jpg" alt="3次握手"></p><blockquote><p>第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； </p><p>SYN：同步序列编号(Synchronize Sequence Numbers)</p><p>第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； </p><p>第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.</p></blockquote><p><strong>为什么需要三次握手，是为了解决下列的一个问题:</strong></p><blockquote><p>​       client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了， 以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。</p><p>​    假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生</p></blockquote><p>建立连接成功后，接下来就正式传输数据</p><p>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）</p><h4 id="四次挥手的步骤："><a href="#四次挥手的步骤：" class="headerlink" title="四次挥手的步骤："></a><strong>四次挥手的步骤：</strong></h4><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</p><blockquote><p>主动方：我已经关闭了向你那边的主动通道了，只能被动接收了<br>被动方：收到通道关闭的信息，但是我的工作可能还没完成<br>被动方：ok 我的工作完成了，我这边向你的主动通道也关闭了<br>主动方：最后收到数据，之后双方无法通信</p></blockquote><p>具体过程如下:</p><p><img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-wave.jpg" alt="4次挥手"></p><p>​    由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p><blockquote><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p></blockquote><p>​    上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：<img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-wave-meanwhile.jpg" alt="tcp4次挥手-同时"></p><p>​    如果有大量的连接，每次在连接、关闭时都要三次握手，四次挥手，会很明显会造成性能低下，因此，HTTP有一种叫做keep connection的机制，它可以在传输数据后仍然保持连接，当客户端再次获取数据时，直接使用刚刚空闲下的连接而无需再次握手</p><p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p><blockquote><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p></blockquote><p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p><blockquote><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></blockquote><p><strong>tcp/ip的并发限制</strong></p><p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）</p><p>而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求</p><p>所以针对这个瓶颈，又出现了很多的资源优化方案</p><h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。</p><p>get会产生一个tcp数据包，post两个</p><p>具体就是：</p><ul><li>get请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li><li>post请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>，</li></ul><p>浏览器再发送<code>data</code>，服务器响应200（返回数据）。</p><p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）</p><h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><p>其实就是一个概念：</p><p><strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong></p><p>简括就是：</p><p><strong>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong></p><p>当然，服务端的接收就是反过来的步骤</p><p>五层因特网协议栈其实就是：</p><blockquote><p>1.应用层(dns,http) DNS解析成IP并发送http请求</p><p>2.传输层(tcp,udp) 建立tcp连接（三次握手）</p><p>3.网络层(IP,ARP) IP寻址</p><p>4.数据链路层(PPP) 封装成帧</p><p>5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</p></blockquote><p>当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。</p><p>OSI七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p><blockquote><p>表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</p><p>会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</p></blockquote><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h3><h4 id="前端性能优化常用的方法有哪些"><a href="#前端性能优化常用的方法有哪些" class="headerlink" title="前端性能优化常用的方法有哪些?"></a>前端性能优化常用的方法有哪些?</h4><p>前端性能优化是提升网页加载速度和用户体验的重要手段。以下是一些常用的前端性能优化方法：</p><ol><li><strong>减少HTTP请求</strong>：HTTP请求是网页加载速度的主要瓶颈之一。减少HTTP请求的方法包括：<ul><li>合并CSS和JavaScript文件，减少文件数量。</li><li>使用CSS Sprites技术，将多个小图标合并成一张大图，减少图片请求。</li><li>利用浏览器缓存，对于不经常变动的资源，设置合适的缓存策略。</li></ul></li><li><strong>优化图片</strong>：图片是网页中占用带宽较多的资源之一。优化图片的方法包括：<ul><li>压缩图片大小，使用合适的图片格式（如JPEG、PNG、SVG等）。</li><li>使用图片懒加载（Lazy Loading）技术，延迟加载用户当前视口外的图片。</li><li>使用WebP格式的图片，它具有更好的压缩性能和显示效果。</li></ul></li><li><strong>使用CDN</strong>：CDN（内容分发网络）可以将资源缓存到离用户更近的节点上，提高资源加载速度。</li><li><strong>优化JavaScript</strong>：JavaScript的执行会影响网页的渲染速度。优化JavaScript的方法包括：<ul><li>将JavaScript脚本放在页面底部，避免阻塞页面的渲染。</li><li>使用异步加载JavaScript，如使用<code>&lt;script async&gt;</code>标签。</li><li>避免使用全局变量和不必要的计算，减少内存占用和CPU消耗。</li><li>利用浏览器的缓存机制，将JavaScript文件缓存到本地。</li></ul></li><li><strong>优化CSS</strong>：CSS的加载和解析也会影响网页的渲染速度。优化CSS的方法包括：<ul><li>将CSS代码放在HTML页面的头部，确保页面在加载过程中尽早应用样式。</li><li>避免使用CSS表达式和复杂的CSS选择器，减少浏览器的计算量。</li><li>利用CSS的继承性和层叠性，减少重复的代码。</li><li>使用CSS预处理器（如Sass、Less等）编写更简洁、可维护的CSS代码。</li></ul></li><li><strong>DOM优化</strong>：DOM（文档对象模型）是网页的基础结构。优化DOM的方法包括：<ul><li>减少DOM元素的数量，避免不必要的嵌套和冗余元素。</li><li>使用DocumentFragment或innerHTML批量操作DOM，减少DOM操作次数。</li><li>避免频繁地读取DOM样式和属性，可以使用变量缓存DOM样式。</li><li>使用虚拟DOM技术，提高DOM操作的性能。</li></ul></li><li><strong>使用Web Workers</strong>：Web Workers是运行在后台的JavaScript线程，不会阻塞页面的渲染。可以使用Web Workers处理一些耗时的计算任务，提高页面的响应速度。</li><li><strong>压缩和编码</strong>：使用Gzip等压缩技术对网页资源进行压缩，减少传输的数据量。同时，使用正确的字符编码（如UTF-8）可以提高网页的解析速度。</li><li><strong>利用缓存</strong>：利用浏览器缓存、CDN缓存等机制，减少重复请求和资源加载时间。</li><li><strong>减少重绘和重排</strong>：重绘和重排是浏览器渲染页面的两个重要过程，但它们的性能开销较大。可以通过减少元素的样式变化和布局变化来减少重绘和重排的次数。</li></ol><p>以上是一些常用的前端性能优化方法，可以根据具体的项目需求和场景选择合适的优化手段。</p><h4 id="浏览器中LightHouse-v8-v9性能优化指标有哪些？"><a href="#浏览器中LightHouse-v8-v9性能优化指标有哪些？" class="headerlink" title="浏览器中LightHouse v8/v9性能优化指标有哪些？"></a>浏览器中LightHouse v8/v9性能优化指标有哪些？</h4><p>在浏览器的Lighthouse中，无论是v8还是v9版本，性能优化指标主要包括以下几个方面：</p><ol><li>首次内容渲染（First Contentful Paint, FCP）<ul><li>这是页面首次渲染出文本或图片的时间。FCP衡量的是用户看到页面上的第一个元素（例如文本、图片等）的时间。</li></ul></li><li>最大内容绘制（Largest Contentful Paint, LCP）<ul><li>LCP标识网页渲染出最大文本或图片的时间。这是用户看到页面上主要内容的时间点。</li></ul></li><li>可交互时间（Time to Interactive, TTI）<ul><li>这是页面达到可交互状态所需的时间。在这个时间点之后，用户可以开始与页面进行交互，如点击按钮或链接。</li></ul></li><li>累计布局偏移（Cumulative Layout Shift, CLS）<ul><li>CLS衡量页面上内容意外偏移的程度。当页面元素在用户交互或加载过程中发生移动时，会导致CLS分数增加，这会给用户带来不良的体验。</li></ul></li><li>累计阻塞时间（Total Blocking Time, TBT）<ul><li>TBT标识网页首次内容渲染和可交互时间之间的所有超时任务的超时累计时间。这主要反映了页面在加载过程中主线程被阻塞的总时间。</li></ul></li></ol><p>除了上述主要性能指标外，Lighthouse还可能会提供其他与性能相关的指标，例如：</p><ul><li><strong>速度指数（Speed Index）</strong>：衡量页面内容的可见填充速度。</li><li><strong>首次有效绘制（First Meaningful Paint, FMP）</strong>：虽然FMP不是Lighthouse的核心指标，但在某些版本中可能会提供，它衡量的是主要内容对用户可见的时间。</li></ul><p>请注意，随着Lighthouse版本的更新，可能会有新的性能指标被引入或旧的指标被优化。因此，最好直接查看Lighthouse的官方文档或工具本身以获取最准确和最新的信息。</p><h4 id="SPA首屏加载速度慢的怎么解决？"><a href="#SPA首屏加载速度慢的怎么解决？" class="headerlink" title="SPA首屏加载速度慢的怎么解决？"></a>SPA首屏加载速度慢的怎么解决？</h4><p>SPA（单页应用）首屏加载速度慢的问题，通常可以通过以下几种方法来解决：</p><ol><li>减小入口文件体积<ul><li>通过代码分割（Code Splitting）和懒加载（Lazy Loading）技术，将代码拆分成多个小块，按需加载，从而减小首屏加载时需要的文件大小。</li><li>路由懒加载：将不同路由对应的组件分割成不同的代码块，只有在需要加载对应路由时，才加载对应的组件代码。</li><li>抽离公共组件避免重复打包：将公共的库或组件单独打包，避免在多个页面中重复加载。</li></ul></li><li>优化图片资源<ul><li>图片压缩：使用工具对图片进行压缩，减小图片的体积。</li><li>图片懒加载：对于非首屏的图片，使用懒加载技术，当用户滚动到图片位置时才加载图片。</li></ul></li><li>静态资源本地缓存<ul><li>利用浏览器的缓存机制，对静态资源进行缓存，避免重复加载。</li><li>使用CDN（内容分发网络）加速静态资源的加载。</li></ul></li><li>优化网络请求<ul><li>减少HTTP请求的数量，合并多个请求到一个请求中。</li><li>使用HTTP/2协议，它支持多路复用，可以并行发送多个请求，提高加载速度。</li></ul></li><li>按需加载第三方库和插件<ul><li>不要一次性加载所有的第三方库和插件，而是根据需要使用它们时才加载。</li><li>使用CDN引用第三方库和插件，减轻服务器的负载。</li></ul></li><li>使用SSR（服务器端渲染）<ul><li>对于首屏渲染需要的数据，可以在服务器端进行渲染，然后将渲染好的页面发送到客户端，这样可以减少客户端的渲染时间。</li></ul></li><li>开启GZip压缩<ul><li>对传输的数据进行GZip压缩，减小传输的数据量，提高加载速度。</li></ul></li><li>优化DOM操作<ul><li>减少不必要的DOM操作，避免频繁的DOM读写和重排重绘。</li><li>使用虚拟DOM技术，提高DOM操作的性能。</li></ul></li><li>优化CSS和JavaScript<ul><li>合并和压缩CSS和JavaScript文件，减少文件数量和大小。</li><li>使用CSS Sprites技术合并小图片，减少图片请求的数量。</li><li>避免在JavaScript中执行复杂的计算和循环操作，优化算法和数据结构。</li></ul></li><li>优化服务器性能<ul><li>确保服务器具有足够的处理能力，可以快速响应客户端的请求。</li><li>使用负载均衡技术，将请求分发到多个服务器上进行处理，提高整体的处理能力。</li></ul></li></ol><p>通过综合应用以上方法，可以有效地解决SPA首屏加载速度慢的问题，提升用户体验。</p><h4 id="如何优化LCP？"><a href="#如何优化LCP？" class="headerlink" title="如何优化LCP？"></a>如何优化LCP？</h4><p>优化LCP（Largest Contentful Paint）是提升网页性能的重要方面，它表示从用户开始加载网页到最大的图片或文本块在视口中呈现之间的时间。以下是一些优化LCP的策略：</p><ol><li>减少服务器响应时间<ul><li>优化服务器性能，确保服务器可以快速响应请求。</li><li>使用CDN（内容分发网络）来缓存资源，并将资源分发到离用户更近的地理位置，从而减少加载时间。</li><li>提前建立第三方连接，以减少等待时间。</li></ul></li><li>优化资源加载<ul><li>压缩和优化图片、脚本和样式表等资源的大小，以减少传输时间。</li><li>使用HTTP/2或HTTP/3协议，它们支持流复用，可以同时加载多个资源，提高加载效率。</li><li>对资源进行异步加载和延迟加载，避免阻塞渲染过程。</li></ul></li><li>代码分割和懒加载<ul><li>使用代码分割技术将代码拆分成多个小块，按需加载，从而减小首次加载时需要的文件大小。</li><li>对于非首屏的内容或组件，使用懒加载技术，当用户需要时才加载。</li></ul></li><li>优化渲染过程<ul><li>避免在渲染过程中执行复杂的计算和循环操作，优化算法和数据结构。</li><li>使用Web Workers在后台线程中执行耗时的计算任务，避免阻塞主线程。</li><li>提取关键CSS并将其内联到HTML的<code>&lt;head&gt;</code>部分中，以确保在渲染首屏内容时关键样式已经可用。</li></ul></li><li>优化DOM操作<ul><li>减少不必要的DOM操作，避免频繁的DOM读写和重排重绘。</li><li>使用虚拟DOM技术来减少真实DOM操作，提高性能。</li></ul></li><li>使用缓存<ul><li>利用浏览器缓存机制，缓存已经加载过的资源，避免重复加载。</li><li>对于静态资源，使用长缓存策略，减少请求次数。</li></ul></li><li>监控和测试<ul><li>使用Lighthouse等性能测试工具来监控和测试LCP等性能指标，找出性能瓶颈并进行优化。</li><li>在不同设备和网络环境下进行测试，确保网页在各种条件下都能有良好的性能表现。</li></ul></li></ol><p>请注意，优化LCP是一个综合性的过程，需要综合考虑多个方面。通过持续的性能监控和测试，你可以发现潜在的性能问题并进行优化，从而提升网页的加载速度和用户体验。</p><h4 id="前端性能优化指标RAIL是什么？"><a href="#前端性能优化指标RAIL是什么？" class="headerlink" title="前端性能优化指标RAIL是什么？"></a>前端性能优化指标RAIL是什么？</h4><p>RAIL是Google提出的一个以用户为中心的前端性能模型，它包含了四个关键性能指标，旨在帮助开发者提高网页的性能和用户体验。RAIL分别代表以下四个方面：</p><ol><li><strong>Response（响应）</strong>：指的是Web应用给用户的响应体验，包括用户输入到系统响应的时间。RAIL建议用户输入到响应时间不要超过100ms，给用户的感觉是瞬间完成的。如果响应时间在50ms到100ms之间，最好提供反馈，如加载进度或倒计时，以改善用户的心理预期。</li><li><strong>Animation（动画）</strong>：动画是提高用户体验的重要元素，但添加的动画必须流畅。RAIL建议每帧动画在10ms内产生，因为一般浏览器的刷新率是60帧每秒，即每16.6ms刷新一次。为了保证视觉上的平滑，每帧动画最好不要超过10ms。</li><li><strong>Idle（空闲）</strong>：指的是让浏览器（主线程）有足够的空闲时间处理用户的交互，而不是一直在繁忙状态。RAIL建议最大化空闲时间，以增大50ms内响应用户输入的几率。开发者可以利用空闲时间来完成一些延后的工作，如先加载页面可见的部分，然后利用空闲时间加载剩余部分。</li><li><strong>Load（加载）</strong>：指的是网络加载时间。RAIL建议在5秒内完成内容的加载并且可以交互。加载时间过长会导致用户失去耐心，甚至离开网页。</li></ol><p>通过关注这四个方面的性能指标，开发者可以更加全面地评估和优化前端性能，提高用户体验。同时，RAIL也提供了一些具体的优化策略和建议，帮助开发者更好地实施性能优化。</p><h4 id="ssr的优缺点，实现的具体过程"><a href="#ssr的优缺点，实现的具体过程" class="headerlink" title="ssr的优缺点，实现的具体过程"></a>ssr的优缺点，实现的具体过程</h4><p>SSR，即服务端渲染（Server-Side Rendering），是一种Web开发中的渲染技术，与传统的客户端渲染（Client-Side Rendering）相对应。下面我将详细解释SSR的优缺点以及实现的具体过程。</p><p>一、SSR的优点：</p><ol><li>更好的性能：SSR可以在服务器端预先渲染页面，减少客户端的渲染时间，提高页面加载速度。由于服务器通常具有更强大的计算能力，因此可以更快地生成HTML页面。</li><li>更好的SEO：由于页面在服务器端已经被渲染成HTML，搜索引擎爬虫可以直接抓取到页面的内容，有利于SEO优化。与客户端渲染相比，SSR更容易被搜索引擎识别和索引。</li><li>更适合复杂页面：对于包含大量数据、需要复杂计算的页面，SSR可以更好地处理并减少客户端的负载。服务器可以处理更复杂的逻辑和数据，然后将渲染好的页面发送给客户端。</li></ol><p>二、SSR的缺点：</p><ol><li>开发限制：SSR要求开发者在编写Vue组件时，需要考虑到服务器端和客户端环境的差异，不能过度依赖客户端环境。这可能会增加开发的复杂性和难度。</li><li>服务器压力：由于页面在服务器端进行渲染，会增加服务器的负载压力。特别是在高并发场景下，服务器可能会成为性能瓶颈。</li><li>调试困难：SSR的调试过程相对复杂，需要同时考虑到服务器端和客户端的日志和错误信息。这可能会增加开发和维护的难度。</li></ol><p>三、SSR实现的具体过程：</p><ol><li>接收请求：当客户端向服务器发送请求时，服务器会接收这个请求。</li><li>渲染页面：服务器在接收到请求后，会根据请求的URL或其他参数，使用Vue或其他前端框架来渲染页面。这个过程包括加载组件、执行数据请求、渲染HTML等步骤。</li><li>发送响应：当页面渲染完成后，服务器会将生成的HTML页面作为响应发送给客户端。这个HTML页面已经包含了页面的结构和数据，客户端只需要展示这个页面即可。</li><li>客户端激活：客户端在接收到HTML页面后，会解析并展示这个页面。同时，客户端还会加载并执行页面中的JavaScript代码，以便实现交互和动态功能。</li></ol><p>需要注意的是，SSR并不是所有情况下都是最优的选择。在一些简单的页面或需要快速响应的场景下，客户端渲染可能更加适合。因此，在选择使用SSR时，需要根据具体的业务需求和技术栈来综合考虑。</p><h4 id="怎么分析性能？"><a href="#怎么分析性能？" class="headerlink" title="怎么分析性能？"></a>怎么分析性能？</h4><p>性能分析是一个复杂但重要的过程，用于确保软件或系统满足其设计的性能期望。以下是一些常用的性能分析方法：</p><ol><li>性能分析工具<ul><li>使用专门的性能分析工具，如GDB、Xcode Instruments（针对macOS）、Intel VTune Profiler（多平台支持）和Perf（Linux）等，可以收集关于函数调用、变量值、CPU使用率、内存分配和I/O操作等关键信息。</li><li>这些工具通常具有不同的特点和优势，选择适合您项目需求的工具是关键。</li></ul></li><li>性能分析原则<ul><li>首先，从原始测试数据查看系统响应时间，判断它是否满足用户性能的期望。</li><li>如果存在问题，判断系统的瓶颈是出现在网络环节还是服务器环节。</li></ul></li><li>性能分析步骤<ul><li>从分析summary的事务执行情况入手，了解整体性能情况。</li><li>查看负载发生器和服务器的系统资源情况，包括负载是否均衡、CPU利用率、内存使用情况以及是否有内存泄露等。</li><li>深入查看虚拟用户与事务的详细执行情况，如虚拟用户运行情况、事务响应时间是否增长等。</li><li>检查错误发生情况，找出导致性能问题的根本原因。</li><li>对于web性能测试，还需要分析web资源和细分网页，重点分析服务器的稳定性，找出哪些环节比较耗时，以及页面中哪些组成部分对用户响应时间影响最大。</li></ul></li><li>诊断方法<ul><li><strong>随机变动法</strong>：随机调整指标，看是否改善。</li><li><strong>Ad Hoc核对清单法</strong>：针对清单，一项项核对。</li><li><strong>问题陈述法</strong>：详细询问客户，明确问题性质、范围。</li><li><strong>USE法</strong>：综合考虑资源和效率，根据资源（CPU、内存、网络、磁盘等）的使用率（Usage）、饱和度（Saturation）、报错（Error）来排查问题。</li><li><strong>延时分析法</strong>：将业务分解，通过分析每一步骤的延时，定位问题所在。</li></ul></li><li>代码优化<ul><li>通过对代码进行审查和优化，可以减少不必要的计算和内存使用，提高程序的执行效率。</li><li>例如，使用代码分割和懒加载技术，可以减少首次加载时需要的文件大小，提高页面加载速度。</li></ul></li><li>监控和日志分析<ul><li>实时监控系统的运行状态和性能指标，及时发现并解决问题。</li><li>通过分析日志文件，可以了解系统的运行情况、错误信息和性能瓶颈等关键信息。</li></ul></li></ol><p>请注意，性能分析是一个持续的过程，需要不断地收集和分析数据，以便及时发现问题并进行优化。同时，不同的项目和需求可能需要使用不同的性能分析方法和工具，因此需要根据具体情况进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 个人知识库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人随笔（持续更新）</title>
      <link href="/2021/05/28/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2021/05/28/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该博文是博主本人自己归纳整合的一些面经以及一些零零散散的基础知识点，一方面方便自己以后复习查看，另一方面也是做一个简单的分享。</p></blockquote><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript:"></a>JavaScript:</h2><h3 id="Jsonp原理："><a href="#Jsonp原理：" class="headerlink" title="Jsonp原理："></a>Jsonp原理：</h3><p> Jsonp的全称为：json with padding ，意为填充式的json。</p><blockquote><p>1、Ajax直接请求普通文件存在跨域无权限访问的问题，不管是静态页面、动态页面、web服务，只要是跨域请求，一律不准。</p><p>2、不过我们发现，web页面调用js文件则不受跨域的影响（不仅如此，我们还发现凡是拥有“src”这个属性的标签都拥有跨域的能力，比如&lt;\script&gt;、&lt;\img&gt;、&lt;\iframe&gt;）。</p><p>3、于是可以判断，当前阶段如果想通过纯web端跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理。</p><p>4、恰巧我们知道有一种叫做JSON的<strong>纯字符数据格式</strong>可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据。</p><p>5、这样，解决方案就呼之欲出了，web服务端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件，显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装进去。</p><p>6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来很像ajax，但其实并不一样。</p><p>7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，简称<strong>JSONP</strong>。<u>该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名包裹在JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</u></p></blockquote><p>可以说Jsonp就是为了跨域而生的了。</p><h3 id="Jsonp的实现："><a href="#Jsonp的实现：" class="headerlink" title="Jsonp的实现："></a>Jsonp的实现：</h3><h4 id="1、远程调用其它服务器上的js文件（跨域成功）"><a href="#1、远程调用其它服务器上的js文件（跨域成功）" class="headerlink" title="1、远程调用其它服务器上的js文件（跨域成功）"></a>1、远程调用其它服务器上的js文件（跨域成功）</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://remoteserver.com/remote.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h4 id="2、远程调用js"><a href="#2、远程调用js" class="headerlink" title="2、远程调用js"></a>2、远程调用js</h4><p>在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">var</span> localHandler <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://remoteserver.com/remote.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>remote.js文件代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token function">localHandler</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"result"</span><span class="token operator">:</span><span class="token string">"我是远程js带来的数据"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行之后，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。</p><p>这样一来跨域远程获取数据的目的基本实现了，但是又一个问题出现了，怎么让远程js知道它应该调用的本地函数呢？</p><h4 id="3、动态生成js脚本"><a href="#3、动态生成js脚本" class="headerlink" title="3、动态生成js脚本"></a>3、动态生成js脚本</h4><p>只要服务端提供的js脚本是动态生成的，这样调用者就可以传一个参数过去告诉服务端，“我想要一段调用xxx函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。</p><p>看jsonp.html页面的代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 得到航班信息查询结果后的回调函数</span>    <span class="token keyword">var</span> flightHandler <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'你查询的航班结果是：票价 '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>price <span class="token operator">+</span> <span class="token string">' 元，'</span> <span class="token operator">+</span> <span class="token string">'余票 '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>tickets <span class="token operator">+</span> <span class="token string">' 张。'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）</span>    <span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建script标签，设置其属性</span>    <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把script标签加入head，此时调用开始</span>    document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'head'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>利用编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。</p><p>我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。<br>OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">flightHandler</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token string">"code"</span><span class="token punctuation">:</span> <span class="token string">"CA1998"</span><span class="token punctuation">,</span>    <span class="token string">"price"</span><span class="token punctuation">:</span> <span class="token number">1780</span><span class="token punctuation">,</span>    <span class="token string">"tickets"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="4、封装代码"><a href="#4、封装代码" class="headerlink" title="4、封装代码"></a>4、封装代码</h4><p>jQuery如何实现jsonp调用？</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span>jquery<span class="token punctuation">.</span>min<span class="token punctuation">.</span>js"<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>   <span class="token function">jQuery</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">"get"</span><span class="token punctuation">,</span>        <span class="token keyword">async</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        url<span class="token punctuation">:</span> <span class="token string">"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998"</span><span class="token punctuation">,</span>                       dataType<span class="token punctuation">:</span> <span class="token string">"jsonp"</span><span class="token punctuation">,</span>        jsonp<span class="token punctuation">:</span> <span class="token string">"callback"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)             </span>        jsonpCallback<span class="token punctuation">:</span><span class="token string">"flightHandler"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据</span>        success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'您查询到航班信息：票价： '</span> <span class="token operator">+</span> json<span class="token punctuation">.</span>price <span class="token operator">+</span> <span class="token string">' 元，余票： '</span> <span class="token operator">+</span> json<span class="token punctuation">.</span>tickets <span class="token operator">+</span> <span class="token string">' 张。'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span><span class="token punctuation">,</span>                     error<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                     <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'fail'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>jquery在处理jsonp类型的ajax时，自动帮你生成回调函数并把数据取出来供success属性方法来调用。</p><h4 id="ajax和jsonp的区别："><a href="#ajax和jsonp的区别：" class="headerlink" title="ajax和jsonp的区别："></a>ajax和jsonp的区别：</h4><p>1、ajax和jsonp这两种技术在调用方式上看起来很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jQuery把jsonp作为ajax的一种形式进行了封装。</p><p>2、但ajax和jsonp其实本质上是不同的东西，ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加。</p><h3 id="原型与原型链："><a href="#原型与原型链：" class="headerlink" title="原型与原型链："></a>原型与原型链：</h3><p>ES6之前中并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实</p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/prototype.png" alt="原型与原型链"></p><h4 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（<code>prototype</code>）</h4><ul><li><p>JS所有的函数都有prototype属性，只有函数才有</p></li><li><p>其属性和方法都能被构造函数实例化的对象所共同访问</p></li><li><p><code>constructor</code>存在于每个函数的<code>prototype</code>属性中，其指向了函数本身</p></li></ul><h4 id="原型链-proto-）"><a href="#原型链-proto-）" class="headerlink" title="原型链 (_proto_）"></a>原型链 (<code>_proto_</code>）</h4><ul><li><p>JS中的对象会有个<code>_proto_</code>属性，指向了创建他的构造函数的<code>prototype</code>,而函数比较特殊也有这个属性</p></li><li><p>当JS搜索引擎查找对象中的属性或者方法时，如果在该对象上没有该属性和方法的话，会通过原型链一层一层往上查找</p></li><li><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向下搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>run <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'running'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ➀ 每个对象都有一个__proto__属性，并且指向他的prototype原型对象。</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>__proto__<span class="token operator">===</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">// ➁ 每个构造函数都有一个prototype原型对象,prototype原型对象的constructor等于构造函数本身</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token operator">==</span>Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">//原型相关的知识考点一般就是围绕以下：</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token operator">===</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>当每创建一个Person构造函数时，在Person构造函数中，为每一个对象都添加了一个run方法，也就是说构造函数每执行一次就会创建一个新的run方法。</p><p>一个还好，如果创建了一百个实例，一千个甚至上万个呢，这时候就体现出原型的好处了，我们可以把run方法放到构造函数的prototype上，这时候只需要创建一个，而且每一个实例都可以访问到。</p><p>prototype相当于所有实例对象可以访问的一个公共容器，实例对象的<code>__prorunto__</code>指向构造函数的<code>prototype</code>，从而实现<strong>继承</strong>。</p><p><strong>经典图：</strong></p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/classic-prototype.jpg" alt="原型经典图"></p><h4 id="如何准确判断一个变量是数组类型"><a href="#如何准确判断一个变量是数组类型" class="headerlink" title="如何准确判断一个变量是数组类型?"></a>如何准确判断一个变量是数组类型?</h4><p>instanceof 用于判断引用类型属于哪个构造函数的方法 </p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true </span><span class="token keyword">typeof</span> arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//object typeof 是无法判断是否为数组的</span></code></pre><p>instanceof 是用来判断实例的_proto_和构造函数的 prototype 是否指 向一个原型对象，</p><p>但是有一个弊端，只要出现在一条原型链上的，都会返回 true（每个函数都有 prototype，每个对象都有一个内部属性__proto__，其指向它的原型对象。原 型对象也是一个对象，所以也有__proto__） </p><p>这个时候要用实例__proto__.constructor 更加严谨 </p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr instanseof Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true console.log(arr.__proto__.constructor === Array) //true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr<span class="token punctuation">.</span>construct <span class="token operator">==</span> Array<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span> arr <span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="new-操作符在创建实例的时候经历了哪几个阶段"><a href="#new-操作符在创建实例的时候经历了哪几个阶段" class="headerlink" title="new 操作符在创建实例的时候经历了哪几个阶段"></a>new 操作符在创建实例的时候经历了哪几个阶段</h4><p>new 创建了一个对象，共经历了 4 个阶段： </p><ol><li>创建一个空对象 </li><li>设置原型链 </li><li>让实例化对象中的 this 指向对象，并执行函数体 </li><li>判断实例化对象的返回值类型</li></ol><h4 id="类型的判断方法"><a href="#类型的判断方法" class="headerlink" title="类型的判断方法"></a>类型的判断方法</h4><p><strong>1、typeof</strong></p><blockquote><p>未定义、未初始化：返回 <code>&quot;undefined&quot;</code></p><p>布尔值：返回 <code>&quot;boolean&quot;</code></p><p>字符串：返回 <code>&quot;string&quot;</code></p><p>数值(包括NAN)：返回 <code>&quot;number&quot;</code></p><p>对象、null：返回 <code>&quot;object&quot;</code>， null 表示空对象指针</p><p>函数：返回 <code>&quot;function&quot;</code></p><p><strong>注意</strong>：<code>typeof</code>可以判断基本类型，无法判断对象的类型或者null</p></blockquote><p><strong>2、instanceof</strong></p><blockquote><p>如果变量是引用类型，可以使用instanceof判断，检测基本类型时，会返回false。</p><p>原理：判断变量的原型链上是否有构造函数的prototype属性</p><p><strong>注意：空对象{}的判断问题</strong>        //true</p></blockquote><p><strong>3、Object.prototype.toString</strong></p><blockquote><p>所有的数据类型都可以使用此方法进行检测，且非常精准。如：</p><p>Object.prototype.toString.call(obj) === ‘[object Object]’</p></blockquote><h4 id="了解更多相关："><a href="#了解更多相关：" class="headerlink" title="了解更多相关："></a>了解更多相关：</h4><p>ES5继承实现、ES6类实现、typeof&amp;&amp;instanceof原理：<a href="https://juejin.cn/post/6844903984335945736">https://juejin.cn/post/6844903984335945736</a></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h3 id="This"><a href="#This" class="headerlink" title="This:"></a>This:</h3><p><strong>1. 默认绑定与隐式绑定</strong></p><p>让我们看看下面这个例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token string">"bar1"</span><span class="token punctuation">;</span> <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span>bar<span class="token punctuation">:</span> <span class="token string">"bar2"</span><span class="token punctuation">,</span> foo<span class="token punctuation">:</span> foo<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">var</span> o3 <span class="token operator">=</span> <span class="token punctuation">{</span>bar<span class="token punctuation">:</span> <span class="token string">"bar3"</span><span class="token punctuation">,</span> foo<span class="token punctuation">:</span> foo<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// "bar1" – 默认绑定</span>o2<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// "bar2" – 隐式绑定</span>o3<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// "bar3" – 隐式绑定</span></code></pre><p>foo()这种调用方法，就是默认绑定。如果在非严格模式下，this就是全局对象，浏览器当中就是window。而如果在严格模式（use strict）下，this就会是undefined。</p><p>之所以这是默认绑定，因为foo的调用不属于任何人，前面没有任何限定条件。这是最简单的绑定。</p><p>o2.foo()和o3.foo()这两种调用方法，都是隐式绑定。Foo是作为o2和o3的方法而调用的，那么谁调用foo，this就指向谁。在上面的例子中，o2.foo()中的this指向o2，因此this.bar就是o2当中的bar: “bar2”；同理，o3.foo()打印出来的就是o3中的”bar3”。</p><p><strong>2. 显式绑定</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token string">"bar1"</span><span class="token punctuation">;</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>bar<span class="token punctuation">:</span> <span class="token string">"bar2"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// "bar1"   默认绑定</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// "bar2"  显式绑定，使用obj作为"this" </span></code></pre><p>如果foo是通过call、apply或者bind调用的，那么这种调用就是显式绑定。这种绑定中,this的指向就是这三个函数中传递的第一个参数。</p><p><strong>3. 关键字new绑定</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token string">"baz"</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> baz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token string">"bar"</span><span class="token punctuation">;</span> <span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>如果把new这个关键字放在一个函数调用的前面，JS编译器会做这四件事情：</p><blockquote><ol><li>创建一个新的空的对象</li><li>把这个对象链接到原型对象上</li><li>这个对象被绑定为this</li><li>如果这个函数不返回任何东西，那么就会默认return this</li></ol></blockquote><p>上面的例子，最终会输出undefined undefined。这是因为baz这个变量并没有bar这个属性，而baz此时只被定义，没有被赋值，因此baz也是undefined。</p><p><strong>4. 箭头函数</strong></p><p>箭头函数会无视以上所有的规则，this的值就是函数创建时候所在的lexical scope中的this，而和调用方式无关。可以对比下面两个例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 输出undefined</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 输出10</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面没有使用箭头函数的例子当中，setTimeout内部的函数是被global调用的，而global没有age这个属性，因此输出undefined。</p><p>第二个例子使用了箭头函数，this就会使用lexical scope中的this，就是Person，因此输出10。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'Nicolas'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Smiley'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sayName<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sayName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">*</span><span class="token comment" spellcheck="true">// 第二次输出*</span><span class="token punctuation">}</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">*</span><span class="token comment" spellcheck="true">// 第一次输出*</span></code></pre><p>第一次输出的是Person, Smiley。第二次输出的结果是window，Nicolas。尽管setTimeout是在构造函数中定义的，但是调用的时候，是在window中调用。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Smiley"</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> sayNameCopy <span class="token operator">=</span> person<span class="token punctuation">.</span>sayName<span class="token punctuation">;</span><span class="token function">sayNameCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>答案是window和undefined。因为，这个时候符合默认绑定的规则。</p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/this.jpg" alt="this指向"></p><p><strong>5. 绑定优先级</strong></p><p>如果多重绑定规格都适用，那么绑定规则的优先级顺序是这样的：</p><blockquote><ol><li>箭头函数</li><li>关键字new调</li><li>显式绑定</li><li>隐式绑定</li><li>默认绑定</li></ol></blockquote><p>箭头函数优先级最高，会无视2-5绑定规则。而默认绑定优先级最低，只有其他绑定都不使用的时候，才会使用默认绑定。</p><h3 id="Promise："><a href="#Promise：" class="headerlink" title="Promise："></a>Promise：</h3><blockquote><p>Promise是异步编程的一种解决方案，它比传统的解决方案–回调函数和事件–更合理且更加强大，它最早是由社区提出并实现，后面ES6将其写进了语言标准，统一了用法，也提供了Promise。</p></blockquote><h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><h5 id="1-创建Promise实例："><a href="#1-创建Promise实例：" class="headerlink" title="1.创建Promise实例："></a>1.创建Promise实例：</h5><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">/*异步操作成功*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li>Promise构造函数接受一个函数作为参数，该函数接受两个参数，分别是resolve和reject，它们是两个函数，是由javascript引擎提供，不用自己部署。</li><li>resolve作用是将Promise对象状态由‘未完成’变为‘成功’，也就是Pending -&gt; Fulfilled，在异步操作成功时调用，并将异步操作的结果作为参数传递出去，而rejected函数则是将Promise对象状态由‘未完成’变为‘失败’，也就是Pending -&gt; Rejected，在异步操作失败时调用，并将异步操作的结果作为参数传递出去。</li><li>Promise 可以分为四个状态：<ul><li> Pending：初始状态，异步操作仍在进行中。</li><li> Fulfilled：操作成功，它调用<code>.then</code>回调，例如<code>.then(onSuccess)</code>。</li><li> Rejected: 操作失败，它调用<code>.catch</code>或<code>.then</code>的第二个参数（如果有）。 例如<code>.catch(onError)</code>或<code>.then(..., onError)</code>。</li><li> <strong>Settled</strong>：这是 promise 的最终状态。promise 已经死亡了，没有别的办法可以解决或拒绝了。 <code>.finally</code>方法被调用。</li></ul></li><li><strong>一旦状态改变就不会再发生变化</strong>（两种状态改变：成功或失败）</li></ul><h5 id="2-Promise的方法："><a href="#2-Promise的方法：" class="headerlink" title="2.Promise的方法："></a>2.Promise的方法：</h5><blockquote><p>then方法: 这个方法是定义在原型对象Promise.prototype上的，它的作用是为Promise实例添加状态改变时的回调函数。它返回的是一个新的Promise实例，注意，不是原来的那个Promise实例，因此可以采用链式写法，即then方法后面再调用一个then方法。<br>Promise实例生成后，可用then方法分别指定两种状态回调函数，then方法可用接受两个回调函数作为参数：<br>（1）  Promise对象状态改为Resolved时调用（必须）<br>（2） Promise对象状态改为Rejected时调用（可选）<br>（3） 基本用法：</p></blockquote><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"finished"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这段代码定义了一个函数sleep，调用后，等待了指定参数（500）毫秒后执行then中的函数。值得注意的是，Promise新建后就会立即执行。</p><blockquote><p>catch方法: 这个方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p><p>我们可以使用<code>then</code>函数的第二个参数来处理错误。 但是，请注意，<code>catch</code>将不再执行。</p></blockquote><pre class=" language-jsx"><code class="language-jsx"><span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">'/posts.json'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>posts<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发生错误！'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数，如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误，另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p><p>如果Promise状态已经变成resolved，再抛出错误是无效的。Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数）就使用catch方法</p><blockquote><p>finally方法: <code>finally</code>方法只在 Promise 状态是 <code>settled</code> 时才会调用。</p><p>如果你希望一段代码即使出现错误始终都需要执行，那么可以在<code>.catch</code>之后使用<code>.then</code>。</p><p>或者可以使用<code>.finally</code>关键字:</p></blockquote><pre class=" language-js"><code class="language-js">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'always called'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="3-Promise-类方法："><a href="#3-Promise-类方法：" class="headerlink" title="3 Promise 类方法："></a>3 Promise 类方法：</h5><p>我们也可以直接使用 <code>Promise</code> 对象中四种静态方法。</p><ul><li>Promise.all</li><li>Promise.reject</li><li>Promise.resolve</li><li>Promise.race</li></ul><blockquote><p>Promise.resolve 和 Promise.reject这两个是帮助函数，可以让 Promise 立即解决或拒绝。可以传递一个参数，作为下次 <code>.then</code> 的接收：</p></blockquote><blockquote><p>使用 <code>Promise.all</code> 并行执行多个 Promise ,通常Promise 是一个接一个地依次执行的，但是你也可以并行使用它们。假设是从两个不同的api中轮询数据。如果它们不相关，我们可以使用<code>Promise.all()</code>同时触发这两个请求。</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'promise.all'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>results <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Done! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>results<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'promise.all'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>解决这些 Promise 要花多长时间？ 5秒？ 1秒？ 还是2秒？</p><blockquote><p>Promise.race(iterable) 方法: 返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'promise.race'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>results <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Done! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>results<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'promise.race'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出 <code>b</code>。使用 <code>Promise.race</code>，最先执行完成就会是最后的返回结果。</p><p>在某些情况下，它可以派上用场，比如计时请求或批量处理请求数组。</p><pre class=" language-js"><code class="language-js">Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://slowwly.robertomurray.co.uk/delay/3000/url/https://api.jsonbin.io/b/5d1fb4dd138da811182c69af'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'request timeout'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="关于Promise-的问题："><a href="#关于Promise-的问题：" class="headerlink" title="关于Promise 的问题："></a>关于Promise 的问题：</h4><p><strong>1.async await：</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a<span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> b<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> a  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p1 -> undefined -> end -> p2 -> p3 -> p4 -> p{pending} -> after1</span></code></pre><blockquote><p>第一个输出 p1，是因为 Promise 里的方法立即执行。接着调用 resolve，只不过 then 里的方法等下一个周期</p><p>第二个输出 undefined，是因为立即执行执行 a 内部的方法，先 console.log(a)，但此时的 a 还没赋值给左边的变量，所以只能是 undefined。然后 await b 就得等下一个周期执行了。</p><p>第三个输出 end，自然不意外。</p><p>接着输出 p2，p3，p4，是因为 await b 等待他执行完了，才轮到 a 内部继续执行。</p><p>输出 Promise { pending }，事件都进入了循环，a 肯定已经被赋值成了 Promise 对象。所以第二遍 console.log(a)，自然就输出这个了。</p><p>输出 after1 不奇怪。</p><p>await a 时，a 是必须等待 Promise 的状态从 pending 到 fullfilled 才会继续往下执行，可 a 的状态是一直得不到更改的，所以无法执行下面的逻辑。只要在 await a 上面加一行 resolve() 就能让后面的 after 2 得到输出</p></blockquote><p><strong>2..如何限制并行 Promise？</strong></p><p>要做到这一点，我们需要以某种方式限制<code>Promise.all</code>。假设你有许多并发请求要执行。 如果使用 <code>Promise.all</code> 是不好的（特别是在API受到速率限制时）。 因此，我们需要一个方法来限制 Promise 个数， 我们称其为<code>promiseAllThrottled</code>。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// simulate 10 async tasks that takes 5 seconds to complete.</span><span class="token keyword">const</span> requests <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`exec'ing task #</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`task #</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">promiseAllThrottled</span><span class="token punctuation">(</span>requests<span class="token punctuation">,</span> <span class="token punctuation">{</span> concurrency<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Oops something went wrong'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上代码将并发限制为并行执行的<code>3</code>个任务。</p><p>实现<code>promiseAllThrottled </code>一种方法是使用<code>Promise.race</code>来限制给定时间的活动任务数量。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * Similar to Promise.all but a concurrency limit * * @param {Array} iterable Array of functions that returns a promise * @param {Object} concurrency max number of parallel promises running */</span><span class="token keyword">function</span> <span class="token function">promiseAllThrottled</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> <span class="token punctuation">{</span> concurrency <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> promises <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>current <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// return if done</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> iterable<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// take one promise from collection</span>    <span class="token keyword">const</span> promise <span class="token operator">=</span> iterable<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> activatedPromise <span class="token operator">=</span> <span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// add promise to the final result array</span>    promises<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>activatedPromise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// add current activated promise to queue and remove it when done</span>    <span class="token keyword">const</span> autoRemovePromise <span class="token operator">=</span> activatedPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// remove promise from the queue when done</span>      <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>autoRemovePromise<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// add promise to the queue</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>autoRemovePromise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// if queue length >= concurrency, wait for one promise to finish before adding more.</span>    <span class="token keyword">const</span> readyForMore <span class="token operator">=</span> queue<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> concurrency <span class="token operator">?</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> readyForMore<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">enqueue</span><span class="token punctuation">(</span>current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>promiseAllThrottled</code>一对一地处理 Promises 。 它执行<code>Promises</code>并将其添加到队列中。 如果队列小于并发限制，它将继续添加到队列中。 达到限制后，我们使用<code>Promise.race</code>等待一个承诺完成，因此可以将其替换为新的承诺。 这里的技巧是，promise 自动完成后会自动从队列中删除。 另外，<strong>我们使用 <code>race</code> 来检测promise 何时完成，并添加新的 promise 。</strong></p><p>3.Promise 解决的痛点是什么？</p><p>1）回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象，是为解决异步操作函数里的嵌套回调（callback hell）问题，代码臃肿，可读性差，只能在回调里处理异常</p><p>2）<u>promise可以支持多个并发的请求，获取并发请求中的数据</u></p><p>3）<u>promise可以解决可读性的问题，异步的嵌套带来的可读性的问题，它是由异步的运行机制引起的，这样的代码读起来会非常吃力</u></p><p>4）promise可以解决信任问题，对于回调过早、回调过晚或没有调用和回调次数太少或太多，由于promise只能决议一次，决议值只能有一个，决议之后无法改变，任何then中的回调也只会被调用一次，所以这就保证了Promise可以解决信任问题</p><p>4.Promise 在事件循环中的执行过程是怎样的？</p><p>1）事件循环</p><blockquote><p>从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。由于主线程不断的重复获得消息、执行消息、再取消息、再执行</p></blockquote><p>2）promise的事件循环</p><blockquote><p>Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环</p></blockquote><h3 id="事件模型："><a href="#事件模型：" class="headerlink" title="事件模型："></a>事件模型：</h3><p>事件模型可以分为三种：</p><p><strong>原始事件模型（DOM0级）</strong></p><p>事件绑定监听函数比较简单, 有两种方式：</p><ol><li>HTML代码中直接绑定</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fun()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ol start="2"><li>通过JS代码绑定</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'.btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> fun<span class="token punctuation">;</span></code></pre><p>DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行。<strong>只支持冒泡，不支持捕获</strong>。同一个类型的事件只能绑定一次，当希望为同一个元素绑定多个同类型事件的时候是不被允许的，后绑定的事件会覆盖之前的事件。</p><p>删除 DOM0 级事件处理程序只要将对应事件属性置为null即可</p><p><strong>标准事件模型（DOM2级）</strong></p><p>在该事件模型中，一次事件共有三个过程:</p><blockquote><p>事件捕获阶段：事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</p><p>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</p><p>事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</p></blockquote><ol><li>事件绑定监听函数的方式如下:</li></ol><pre class=" language-js"><code class="language-js"><span class="token function">addEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> useCapture<span class="token punctuation">)</span></code></pre><ol start="2"><li>事件移除监听函数的方式如下:</li></ol><pre class=" language-js"><code class="language-js"><span class="token function">removeEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> useCapture<span class="token punctuation">)</span></code></pre><p>可以在一个<code>DOM</code>元素上绑定多个事件处理器，各自并不会冲突</p><p><strong>IE事件模型（基本不用）</strong></p><p>IE事件模型共有两个过程:</p><blockquote><p>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</p><p>事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</p></blockquote><p>事件绑定监听函数的方式如下:</p><pre class=" language-js"><code class="language-js"><span class="token function">attachEvent</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> handler<span class="token punctuation">)</span></code></pre><p>事件移除监听函数的方式如下:</p><pre class=" language-js"><code class="language-js"><span class="token function">detachEvent</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> handler<span class="token punctuation">)</span></code></pre><h3 id="事件循环："><a href="#事件循环：" class="headerlink" title="事件循环："></a>事件循环：</h3><h4 id="浏览器中的事件循环："><a href="#浏览器中的事件循环：" class="headerlink" title="浏览器中的事件循环："></a>浏览器中的事件循环：</h4><blockquote><p>JavaScript 是单线程的语言，所谓单线程无非就是同步队列和异步队列，js代码是自上向下执行的，在主线程中立即执行的就是同步任务，比如简单的逻辑操作及函数，而异步任务不会立马立马执行，会挪步放到到异步队列中，而不同的异步操作添加到任务队列的时机也不同，比如onclick（事件）, setTimeout（计时器）, ajax ，promise处理的方式都不同，总的说就是<strong>等待主线程中任务全部完成后，再回来把异步队列中任务放到主程序中运行，这样反复的循环，就是事件循环。</strong></p><p>这些异步操作是由浏览器内核来执行的,浏览器内核上包含 3 种 webAPI,分别是 DOM Binding(DOM绑定)、network(网络请求)、timer(定时器)模块</p></blockquote><p>按照这种分类方式:JS 的执行机制是</p><blockquote><p>首先判断 js 代码是同步还是异步,不停的检查调用栈中是否有任务需要执行,如果没有,就检查任务队列,从中弹出一个任务,放入栈中,如此往复循环,要是同步就进入主进程,异步就进入事件表</p><p>异步任务在事件表中注册函数,当满足触发条件后,被推入事件队列</p><p>同步任务进入主线程后一直执行,直到主线程空闲时,才会去事件队列中查看是否有可执行的异步任务,如果有就推入主进程中</p><p>以上三步循环执行,这就是事件循环(event loop),它是连接任务队列和控制调用栈的</p></blockquote><p>在一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务）。</p><p><strong>macro-task大概包括：</strong></p><blockquote><p>script(整体代码)、setTimeout、setInterval、setImmediate、I/O、UI render</p></blockquote><p><strong>micro-task大概包括:</strong></p><blockquote><p>process.nextTick、Promise、Async/Await(实际就是promise)、MutationObserver(html5新特性)</p></blockquote><p><img src="https://pic4.zhimg.com/v2-0d7af3f483aa991d41dd1f3ba7bac36f_b.webp" alt="img"></p><p>总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动</span><span class="token comment" spellcheck="true">// script start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout</span></code></pre><p>代码分析：</p><blockquote><p>执行代码，输出script start。</p><p>执行async1(),会调用async2(),然后输出async2 end,<u>此时将会保留async1函数的上下文，然后跳出async1函数。</u></p><p>遇到setTimeout，产生一个宏任务</p><p>执行Promise，输出Promise。遇到then，产生第一个微任务</p><p>继续执行代码，输出script end</p><p>代码逻辑执行完毕(当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出promise1，该微任务遇到then，产生一个新的微任务</p><p>执行产生的微任务，输出promise2,当前微任务队列执行完毕。执行权回到async1</p><p>执行await,实际上会产生一个promise返回，即</p><p>let promise_ = new Promise((resolve,reject){ resolve(undefined)})<br>执行完成，执行await后面的语句，输出async1 end</p><p>最后，执行下一个宏任务，即执行setTimeout，输出setTimeout</p><p>注意<br><strong>新版的chrome浏览器中不是如上打印的，因为chrome优化了,await变得更快了,输出为:</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout</span></code></pre></blockquote><p>如果await后面跟的是一个异步函数的调用，比如上面的代码，将代码改成这样：</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end1'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>输出为：<span class="token comment" spellcheck="true">// script start => async2 end => Promise => script end => async2 end1 => promise1 => promise2 => async1 end => setTimeout</span></code></pre><p>此时执行完awit并不先把await后面的代码注册到微任务队列中去，而是执行完await之后，直接跳出async1函数，执行其他代码。然后遇到promise的时候，把promise.then注册为微任务。其他代码执行完毕后，需要回到async1函数去执行剩下的代码，然后把await后面的代码注册到微任务队列当中，<strong>注意此时微任务队列中是有之前注册的微任务的</strong>。所以这种情况会先执行async1函数之外的微任务(promise1,promise2)，然后才执行async1内注册的微任务(async1 end). 可以理解为，这种情况下，await 后面的代码会在本轮循环的最后被执行。</p><h4 id="node-中的事件循环："><a href="#node-中的事件循环：" class="headerlink" title="node 中的事件循环："></a>node 中的事件循环：</h4><pre class=" language-js"><code class="language-js">┌───────────────────────┐┌─<span class="token operator">></span>│        timers         ││  └──────────┬────────────┘│  ┌──────────┴────────────┐│  │     I<span class="token operator">/</span>O callbacks     ││  └──────────┬────────────┘│  ┌──────────┴────────────┐│  │     idle<span class="token punctuation">,</span> prepare     ││  └──────────┬────────────┘      ┌───────────────┐│  ┌──────────┴────────────┐      │   incoming<span class="token punctuation">:</span>   ││  │         poll          │<span class="token operator">&lt;</span>──connections───     ││  └──────────┬────────────┘      │   data<span class="token punctuation">,</span> etc<span class="token punctuation">.</span>  ││  ┌──────────┴────────────┐      └───────────────┘│  │        check          ││  └──────────┬────────────┘│  ┌──────────┴────────────┐└──┤    close callbacks    │   └───────────────────────┘</code></pre><ol><li><p>node 的事件循环的阶段顺序为：</p><blockquote><p>输入数据阶段(incoming data)-&gt;轮询阶段(poll)-&gt;检查阶段(check)-&gt;关闭事件回调阶段(close callback)-&gt;定时器检测阶段(timers)-&gt;I/O事件回调阶段(I/O callbacks)-&gt;闲置阶段(idle, prepare)-&gt;轮询阶段…<br>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。</p></blockquote></li><li><p>阶段概述：</p></li></ol><blockquote><p>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。</p><p>I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。</p><p>闲置阶段(idle, prepare)：仅系统内部使用。</p><p>轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</p><p>检查阶段(check)：setImmediate() 回调函数在这里执行</p><p>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)。</p></blockquote><p>日常开发中的绝大部分异步任务都是在 poll、check、timers 这3个阶段处理的。</p><p><strong>timers:</strong></p><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</p><p><strong>poll:</strong></p><p>poll 是一个至关重要的阶段，poll 阶段的执行逻辑流程图如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X2pwZy8yd1Y3TGljTDc2Mll4VmlhR3NFbmhSOUtpYmJHNnlRcXBjRWo0VlBGcE9PdnpOYW51S1NnMURvNWVKQlV2SVNvQnNpYVNPN3hTM2liZWpkSGJ6NDhseGRXN3hnLzY0MA?x-oss-process=image/format,png" alt="img"></p><blockquote><p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。</p><p>如果没有定时器, 会去看回调函数队列。</p><p>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</p><p>如果 poll 队列为空时，会有两件事发生</p><p>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</p><p>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。</p></blockquote><p><strong>check:</strong></p><p>check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</p><p><strong>process.nextTick:</strong></p><p>process.nextTick 是一个独立于 eventLoop 的任务队列。</p><p>在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。</p><h4 id="node-版本差异说明"><a href="#node-版本差异说明" class="headerlink" title="node 版本差异说明:"></a>node 版本差异说明:</h4><p><u><em>总的变化一句话来说就是，如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就会立刻执行对应的微任务队列。</em></u></p><p><strong>timers 阶段的执行时机变化:</strong></p><pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span>    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span>    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre><p>如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为timer1=&gt;promise1=&gt;timer2=&gt;promise2</p><p>如果是 node10 及其之前版本要看第一个定时器执行完，第二个定时器是否在完成队列中.</p><p>如果是第二个定时器还未在完成队列中，最后的结果为timer1=&gt;promise1=&gt;timer2=&gt;promise2</p><p>如果是第二个定时器已经在完成队列中，则最后的结果为timer1=&gt;timer2=&gt;promise1=&gt;promise2</p><p><strong>check 阶段的执行时机变化：</strong></p><pre class=" language-js"><code class="language-js"><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate2'</span><span class="token punctuation">)</span>    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise resolve'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>js<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果是 node11 后的版本，会输出immediate1=&gt;immediate2=&gt;promise resolve=&gt;immediate3=&gt;immediate4</p><p>如果是 node11 前的版本，会输出immediate1=&gt;immediate2=&gt;immediate3=&gt;immediate4=&gt;promise resolve</p><p><strong>nextTick 队列的执行时机变化：</strong></p><pre class=" language-js"><code class="language-js"><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout2'</span><span class="token punctuation">)</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next tick'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果是 node11 后的版本，会输出timeout1=&gt;timeout2=&gt;next tick=&gt;timeout3=&gt;timeout4</p><p>如果是 node11 前的版本，会输出timeout1=&gt;timeout2=&gt;timeout3=&gt;timeout4=&gt;next tick</p><h4 id="node-和-浏览器-eventLoop的主要区别："><a href="#node-和-浏览器-eventLoop的主要区别：" class="headerlink" title="node 和 浏览器 eventLoop的主要区别："></a>node 和 浏览器 eventLoop的主要区别：</h4><p>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。</p><h4 id="了解更多："><a href="#了解更多：" class="headerlink" title="了解更多："></a>了解更多：</h4><p><a href="https://juejin.cn/post/6844903955286196237">彻底吃透 JavaScript 执行机制</a></p><h3 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h3><p>官方的各种定义引用:</p><blockquote><p>MDN: 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p></blockquote><blockquote><p>红宝书: 闭包是指有权访问另外一个函数作用域中的变量的函数。</p></blockquote><blockquote><p>现代JavaScript教程: 闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。</p></blockquote><p><strong>简单来说就是我在写代码时候我们决定了这些变量的访问权限也就是<a href="https://juejin.im/post/6889538437783748621">词法作用域</a>。然而我们可以用些手段(闭包)如<code>return</code> 一个函数。这样即使这个function在当前词法作用域外执行，也能访问原来定义时词法作用域内的变量，（间接地访问了这些变量）。</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> bar<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2       这就是闭包的效果。</span></code></pre><p>按照词法作用域来说：<code>baz</code>的词法作用域是全局的，外部不能访问foo内部作用域的变量 <code>a</code>，但是 <code>a</code>确实被正常打印了。而函数 <code>bar()</code> 的词法作用域能够访问 <code>foo()</code> 的内部作用域。将 <code>bar</code> 所引用的函数对象本身当作返回值。 在 <code>foo()</code> 执行后， 其返回值(也就是内部的 <code>bar()</code>函数) 赋值给变量 <code>baz</code> 并调用 <code>baz()</code>， 实际上只是通过不同的标识符引用调用了内部的函数 <code>bar()</code>。bar() 显然可以被正常执行。</p><p>但是在这个例子中，它在自己<strong>定义的词法作用域以外</strong> 的地方执行了。</p><p>在 <code>foo()</code> 执行后，通常会期待 <code>foo()</code> 的整个内部作用域都被销毁，因为我们知道引擎有<strong>垃圾回收机制</strong>用来释放不再使用的内存空间。由于看上去 <code>foo()</code> 的内容不会再被使用，所以很自然地会考虑对其进行回收。</p><p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域?原来是 <code>bar()</code> 本身在使用。拜 <code>bar()</code> 所声明的位置所赐，它拥有涵盖 <code>foo()</code> 内部作用域的闭包，使得该作用域能够一直存活，以供 <code>bar()</code> 在之后任何时间进行引用。bar() 依然持有对该作用域的引用。</p><p>这样做的话一是<strong>可以读取函数内部的变量</strong>，二是<strong>可以让这些变量的值始终保存在内存中</strong>。</p><p><strong>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>正常情况下， 这段代码预期是分别输出数字 1~5， 每秒一次， 每次一个。</p><p>但实际上， 这段代码在运行时会以每秒一次的频率输出五次 6。</p><p>我们可以利用闭包来解决这个问题。 首先这种IIFE(立即执行函数表达式) 是一個定义完馬上就執行的 JavaScript function，可以创建闭包。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>不熟IIFE用<code>let</code>也成，本质上这是将一个块转换成一个可以被关闭的作用域。也就是块级作用域。</p><p>总的来说闭包就是：</p><blockquote><p>当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量,其特点便是：</p><p>1、让外部访问函数内部变量成为可能</p><p>2、局部变量会常驻在内存中</p><p>3、可以避免使用全局变量，防止全局变量污染</p><p>4、会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p></blockquote><h3 id="JS模块化开发规范："><a href="#JS模块化开发规范：" class="headerlink" title="JS模块化开发规范："></a><a href="https://blog.csdn.net/qq_27575925/article/details/113758050">JS模块化</a>开发规范：</h3><p><strong>CommonJS</strong></p><ul><li>一个文件一个模块；</li><li>使用 exports.xx = … 或者 module.exports ={} 暴露模块；</li><li>使用 require() 方法引入一个模块；</li><li>require()是同步执行的；</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span><span class="token keyword">let</span> fn<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exports<span class="token punctuation">.</span>outMsg<span class="token operator">=</span>fn<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//b.js</span><span class="token keyword">const</span> a<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">outMsg</span><span class="token punctuation">(</span><span class="token string">'hello Commonjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hello Commonjs</span></code></pre><blockquote><p>CommonJS 在NodeJS 环境用，不适用于浏览器；<br>一个文件一个模块；如果有多个导出，则去最后一个导出；</p></blockquote><p><strong>AMD</strong></p><p>全称 Asynchronous module definition（异步模块定义）</p><ul><li>使用 define(…) 定义一个模块；</li><li>使用require(…) 加载一个模块；</li><li>依赖前置，提前执行；</li></ul><p>RequireJS 是AMD 的一种实现</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 模块的定义</span><span class="token comment" spellcheck="true">/***@param id 模块名称，如果为空，模块的名字默认为模块加载器请求的制定脚本名*@param dependencies 模块依赖*@param factory 工厂函数，模块初始化执行函数或对象*/</span><span class="token function">define</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>dependencies<span class="token punctuation">,</span>factory<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 模块的使用，使用 require 加载模块</span>require（<span class="token punctuation">[</span>module<span class="token punctuation">]</span><span class="token punctuation">,</span>callback）<span class="token punctuation">;</span></code></pre><p><strong>CMD</strong></p><p>全称 Common Module Definition（通用模块定义）</p><ul><li>一个文件为一个模块</li><li>使用 define(…) 定义一个模块 （和AMD相似）</li><li>使用require(…) 加载一个模块（和AMD 相似）</li></ul><p>SeaJS 是CMD 的一种实现</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// CMD </span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>require<span class="token punctuation">,</span>exports<span class="token punctuation">,</span>module<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> a<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> b<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 依赖就近书写；</span>  b<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>CMD和AMD 的最显著的区别 AMD 是提前执行，CMD 是延迟执行，依赖就近；<br>AMD： 执行过程中会将所有的依赖模块前置执行，也就是自己的代码逻辑开始前全部执行；<br>CMD ：如果require 但整个逻辑未使用这个依赖 或者为执行到逻辑使用它的地方前，不会执行。</p></blockquote><p><strong>UMD</strong></p><p>全称 Universal Module Definition（万能模块定义），从名字就可以看出 UMD 做的是大一统的工作。Webpack 打包代码就有 UMD 这个选项。</p><p>这个万能模块，可以在服务端使用，也可以在浏览器端使用；</p><p>它主要做了三件事：</p><ul><li>判断是否支持AMD</li><li>判断是否支持CommonJS</li><li>如果都不支持，使用全局变量</li></ul><pre class=" language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>root<span class="token punctuation">,</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对应上述的三个步骤</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>amd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.判断是否支持 AMD</span>        <span class="token comment" spellcheck="true">// 如果 define 这个方法是被定义 并且 define 这个方法是 AMD 的规范，那就把 factory 这个模块实体用 define 方法以 AMD 的规范 定义</span>        <span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [] 是依赖，factory 是模块实体</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> exports <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2. 判断是否支持 CommonJS</span>        <span class="token comment" spellcheck="true">// 如果 exports 是等于一个对象，则表明是在 Node 环境中运行，则支持 CommonJS，那就用 module.exports 暴露整个模块实体</span>        module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 3. 如果都不支持，使用全局变量</span>        <span class="token comment" spellcheck="true">// Browser globals (root 即是 window)</span>        root<span class="token punctuation">.</span>returnExports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Module Defination</span>    <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token punctuation">{</span>        findSum<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        findSub<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">sub</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> math<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>ES Module (ES6 模块)</strong></p><p>全称 ECMAScript Module</p><ul><li>使用 import 导入模块；</li><li>使用 export 导出模块；</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 导出模块</span><span class="token keyword">export</span> <span class="token keyword">var</span> a<span class="token operator">=</span><span class="token string">'123'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//导出变量</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 导出函数</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'p'</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 导出对象； export 不能直接导出对象必须加上default；</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Myclass</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 导出类；</span></code></pre><h4 id="ES6-模块和Common-js-模块的差异："><a href="#ES6-模块和Common-js-模块的差异：" class="headerlink" title="ES6 模块和Common js 模块的差异："></a>ES6 模块和Common js 模块的差异：</h4><p>1、CommonJS 输出的是一个值的拷贝；ES6 模块输出的是值的引用；</p><p>2、CommonJS 模块是运行时加载；ES6模块是编译时输出接口；</p><p>由于ES6 模块是编译时输出接口，所以可以做到 tree shaking；</p><h4 id="import-和-require-导入的区别"><a href="#import-和-require-导入的区别" class="headerlink" title="import 和 require 导入的区别"></a><strong>import 和 require 导入的区别</strong></h4><p>import 的ES6 标准模块：是编译时调用，所以必须放在文件开头，是解构过程。</p><p>require 是 AMD规范引入方式：是运行时调用，所以require理论上可以运用在代码的任何地方，是赋值过程。</p><p>其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量。</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h4 id="CSS-优先规则"><a href="#CSS-优先规则" class="headerlink" title="CSS 优先规则"></a>CSS 优先规则</h4><p><strong>选择器:</strong></p><p>ID 选择器 (#ID)  Class 选择器 (.class 名)  标签选择器 (标签)  通配符 (*)</p><p>相邻选择器 (div+p)   子选择器 (div&gt;p)  后代选择器 (div p)   多个选择器 (div,p,a,ul)</p><p>伪类选择器 (a:hover) </p><p><strong>伪类选择器和伪元素的区别:</strong> </p><p>伪类用于向某些选择器添加特殊效果 (单冒号)</p><p>伪元素用于将某个特殊的东西添加到某些元素的前后 (双冒号)</p><blockquote><p>优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器</p></blockquote><p><strong>::after/:after 与::before/:before 的区别</strong> </p><p>:before 在元素之前添加效果/:after 是在元素之后添加效果;</p><p>:after/:before 是 CSS2 提出的,兼容 IE8;</p><p>::after/::before 是 CSS3 为了区分伪类和伪元素的做出的差 别,为了避免兼容性问题,习惯性的还是写:after/:before; </p><p>可继承样式: font-size/fon-family/color </p><p>不可继承样式:width/height/margin/padding/border</p><h4 id="CSS定义的权重"><a href="#CSS定义的权重" class="headerlink" title="CSS定义的权重"></a>CSS定义的权重</h4><blockquote><p>1就近原则,后加样式优于前面的样式 </p><p>2内嵌样式&gt;内联样式&gt;外联样式 </p><p>3 !Important 大于一切样式</p></blockquote><pre class=" language-css"><code class="language-css">// 以下是权重的规则：继承的样式没有权值,标签类型选择器和伪元素 <span class="token punctuation">:</span>div/p的权重为<span class="token number">1</span>，class/伪类/属性选择器的权重为<span class="token number">10</span>，id的权重为<span class="token number">100</span>，内联样式<span class="token punctuation">:</span>style=””为<span class="token number">1000</span>,以下/// 例子是演示各种定义的权重值：<span class="token comment" spellcheck="true">/*权重为1*/</span><span class="token selector">div</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为10*/</span><span class="token selector"><span class="token class">.class1</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为100*/</span><span class="token selector"><span class="token id">#id1</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为100+1=101*/</span><span class="token selector"><span class="token id">#id1</span> div</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为10+1=11*/</span><span class="token selector"><span class="token class">.class1</span> div</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为10+10+1=21*/</span><span class="token selector"><span class="token class">.class1</span> <span class="token class">.class2</span> div</span><span class="token punctuation">{</span><span class="token punctuation">}</span>// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</code></pre><h4 id="CSS-单位-px、em、rem、rpx、vh、vw-的解释比较"><a href="#CSS-单位-px、em、rem、rpx、vh、vw-的解释比较" class="headerlink" title="CSS 单位 px、em、rem、rpx、vh、vw 的解释比较"></a>CSS 单位 px、em、rem、rpx、vh、vw 的解释比较</h4><blockquote><ol><li>px也就是像素，第一印象它是绝对长度，是定死的，所以想要响应式布局和自适应布局不要用它。但其实”绝对“，”定死“这些并不准确，它的大小也是会随着屏幕变化的。</li><li>rem使用更方便且用途更普遍，所以我们先来看rem。非常简单，设定根元素<html>的font-size属性，默认为16px，那么1rem = 16px。设置为20px，那么1rem = 20px。为了简化计算，我们想令1rem = 10px，就设定根元素font-size为10px或者62.5%（16*62.5%=10）。用 rem 有什么好处？可以实现响应式布局了！响应式布局指的是元素大小能根据屏幕大小随时变化，因为 rem 布局里所有大小跟着根元素变化，所以只要在屏幕大小变化的时候改变根元素font-size就行了。</li><li>rpx是微信小程序为了解决自适应屏幕尺寸设计的单位，它规定任何屏幕的宽都是750rpx。vw是css3新出的单位，规定任何屏幕宽都是100vw，高100vh，就是是将窗口大小平分为 100 份;这里的屏幕指的是视口，即浏览器窗口，不受分辨率和dpr影响，还是很方便的。</li></ol></blockquote><h4 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex布局</a></h4><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/flex-container.jpg" alt="flex-容器属性"></p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/flex-project.jpg" alt="flex-项目属性"></p><h4 id="盒子水平垂直居中的五种方法："><a href="#盒子水平垂直居中的五种方法：" class="headerlink" title="盒子水平垂直居中的五种方法："></a>盒子水平垂直居中的五种方法：</h4><p>相对定位： 先让子盒子的左上角居中然后在向左和向上移动子盒子的宽和高的一半。缺点是需要知道子盒子具体的宽和高</p><pre class=" language-css"><code class="language-css"><span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">25</span>px<span class="token punctuation">;</span><span class="token property">margin-top</span><span class="token punctuation">:</span> - <span class="token number">25</span>px<span class="token punctuation">;</span></code></pre><p>绝对定位：设置子盒子的上、下、左、右都为0，然后再用margin: auto;来设置居中。不需要知道盒子具体的宽和高，但必须要有固定的宽和高。</p><pre class=" language-css"><code class="language-css"><span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span></code></pre><p>相对定位+CSS3的translate：同一，先让盒子的左上角居中（left，top 50%），然后再借助translate让子盒子分别向左和向上移动盒子的一半。不需要知道盒子具体的宽和高，但不是所有浏览器都兼容。</p><pre class=" language-css"><code class="language-css"><span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-<span class="token number">50%</span> -<span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>display: flex：利用flex布局让子盒子居中，同样也存在兼容性问题</p><pre class=" language-css"><code class="language-css"> <span class="token selector"><span class="token id">#box</span></span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span><span class="token hexcode">#eee</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span>flex<span class="token punctuation">;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>利用JavaScript，获取分别获取大盒子和子盒子的宽和高，然后再通过计算让子盒子居中</p><h4 id="两边固定-中间自适应-（圣杯布局和双飞翼布局）"><a href="#两边固定-中间自适应-（圣杯布局和双飞翼布局）" class="headerlink" title="两边固定 中间自适应 （圣杯布局和双飞翼布局）"></a>两边固定 中间自适应 （圣杯布局和双飞翼布局）</h4><p><strong>圣杯布局结构</strong>： </p><blockquote><p>main是中间部分 必须放在文档流的最起前边 优先渲染</p><p>好处：重要的内容放在文档流前面可以优先渲染</p><p>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</p></blockquote><ul><li></li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>contaer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>.contaer {    /*3， 给父盒子添加padding  把main挤过来 */    padding: 0 200px;}        .left,.right {    width: 200px;    height: 200px;    background-color: red;    /*1， 给左右盒子添加左浮动 */    float: left;    /* 4，给左右盒子添加相对于自己的定位 */    position: relative;}        .left {    /*2， 让盒子上去 */    margin-left: -100%;    /* 让盒子定位在左边 */    left: -200px;}.right {    /* 2，让盒子上去 */    margin-left: -200px;    /*4. 让盒子定位在右边 */    right: -200px;}        .main {    width: 100%;    height: 200px;    background-color: blueviolet;    float: left;    text-align: center;}</code></pre><blockquote><p>1，给左中右设置左浮动 但是 mian部分的宽度为100% 所以左右元素不会上去</p><p>2，给left 一个margin-left = -100% right 的margin-left : -200px (这里是right盒子的宽度)</p><p>3，这时由于main的左右部分被挡住 只好给contaer padding值把main挤出来</p><p>4，这样做之后左右盒子也被挤过来了 所以需要给两个盒子添加定位 相对于自己 把盒子定在左右两边</p></blockquote><p>也可以通过flex布局：</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.contaer</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 给父盒子设置flex */</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.main</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 中间部分  丰乐乡：1  让盒子占据剩下的所有剩余空间 */</span>    <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span>,<span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 让左侧盒子放在前边  但不是最先渲染 */</span>css    <span class="token property">order</span><span class="token punctuation">:</span> -<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>双飞翼布局</strong>：</p><blockquote><p>去掉了圣杯布局中的定位和padding 但是需要在main加入一个p标签 后给p标签margin。对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局</p><p>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</p></blockquote><p>结构：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>contaer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>样式：</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.left</span>,<span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 给左右盒子添加左浮动 */</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 让盒子上去 */</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 让盒子上去 */</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token selector"><span class="token class">.main</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 给p添加margin*/</span><span class="token selector">p </span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">200</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>双飞翼布局和圣杯布局的区别</strong>：</p><blockquote><p>除了结构上的差别 圣杯布局中 当页面很小的时候 main 会被挤下来 但是双飞翼布局不会 flex布局也不会</p></blockquote><h4 id="创建一个三角形的原理"><a href="#创建一个三角形的原理" class="headerlink" title="创建一个三角形的原理"></a>创建一个三角形的原理</h4><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token id">#demo</span> </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">border-width</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent red transparent<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h4><p>1.在子元素并级后面添加一个新元素，添加 clear：both 属性 </p><p>优点：通俗易懂，容易掌握   缺点：添加无意义空标签，不方便后期维护 </p><p>2.给父元素添加 overflow:hidden </p><p>优点：代码较少，简单方便   缺点：不能配合定位使用 </p><p>3.：after 方法（作用于浮动元素的父元素）</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.clearfix</span><span class="token pseudo-element">:after</span></span><span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">""</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span>  <span class="token property">visibility</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 为兼容 IE6,IE7，因为 ie6,ie7 不能用 after 伪类 */</span><span class="token selector"><span class="token class">.clearfix</span></span><span class="token punctuation">{</span>  <span class="token property">zoom</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>优点：结构和语义化完全正确   缺点：复用方式不当，会造成代码量增加</p><p><strong>CSS 实现单行文本溢出显示</strong> </p><pre class=" language-css"><code class="language-css"><span class="token property">overflow</span> <span class="token punctuation">:</span> hidden <span class="token punctuation">;</span> <span class="token property">text-overflow</span> <span class="token punctuation">:</span> ellipsis <span class="token punctuation">;</span> <span class="token property">white-space</span> <span class="token punctuation">:</span> nowrap <span class="token punctuation">;</span></code></pre><p>还需要加宽度 width 属性来兼容部分浏览器 </p><p><strong>实现多行文本溢出显示</strong></p><pre class=" language-css"><code class="language-css"><span class="token property">display</span> <span class="token punctuation">:</span> -wedkit-box <span class="token punctuation">;</span> <span class="token property">-webkit-box-orient</span> <span class="token punctuation">:</span> vertical <span class="token punctuation">;</span> <span class="token property">-webkit-line-clamp</span> <span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">;</span> <span class="token property">overflow</span> <span class="token punctuation">:</span> hidden <span class="token punctuation">;</span></code></pre><p>适用范围 : 因使用了 Webkit 的 CSS 扩展属性,该方法适用于 Webkit 浏览器 以及移动端 注: </p><p> -webkit-line-clamp 用来限制在一个块元素显示的文本的行数,为了实现 该效果,它需要组合其它的 webkit 属性。 </p><p> 常见结合属性： </p><p> display：-webkit-box； 必须结合的属性，将对象作为弹性伸缩盒 子模式显示。 </p><p> -webkit-box-orient 必须结合的属性，设置或减缩伸缩盒对象的子 元素排列方式。 <strong>溢出显示的另外一种显示方式</strong> </p><p>实现方式：</p><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>   position：relative；   line-height：<span class="token number">20</span>px；   max-height：<span class="token number">40</span>px；   overflow：hidden； <span class="token punctuation">}</span> <span class="token selector">div：after</span><span class="token punctuation">{</span>   <span class="token property">content</span> <span class="token punctuation">:</span> “<span class="token number">...</span>”<span class="token punctuation">;</span>   <span class="token property">position</span> <span class="token punctuation">:</span> absolute <span class="token punctuation">;</span>   <span class="token property">bottom</span> <span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">;</span>   <span class="token property">right</span> <span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">;</span>   <span class="token property">padding-left</span> <span class="token punctuation">:</span> <span class="token number">40</span>px <span class="token punctuation">;</span>    <span class="token property">background</span> <span class="token punctuation">:</span> <span class="token function">-webkit-linear-gradient</span><span class="token punctuation">(</span>left , transparent , <span class="token hexcode">#fff</span> <span class="token number">55%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token property">background</span> <span class="token punctuation">:</span> <span class="token function">-o-linear-gradient</span><span class="token punctuation">(</span>left , transparent , <span class="token hexcode">#fff</span> <span class="token number">55%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token property">background</span> <span class="token punctuation">:</span> <span class="token function">-moz-linear-gradient</span><span class="token punctuation">(</span>left , transparent , <span class="token hexcode">#fff</span> <span class="token number">55%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">background</span> <span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>left , transparent , <span class="token hexcode">#fff</span> <span class="token number">55%</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> </code></pre><p>此方法也有弊端：就是未超出行的情况下也会出现省略号 </p><p>注:</p><ol><li>将 height 设置为 line-height 的整数倍,防止超出的文字露出。</li><li>给 p::after 添加渐变背景可避免文字只显示一半。 </li><li>由于 ie6-7 不显示 content 内容，所以要添加标签兼容 ie6-7，兼容 ie8 需要将 ：：after 替换成 ：after</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><blockquote><p>类组件可以使用其他特性，如状态 state 和生命周期钩子。</p><p>当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。</p><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。</p></blockquote><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><blockquote><p>Typescript是强类型的Javascript超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</p></blockquote><h3 id="Typescript的优缺点："><a href="#Typescript的优缺点：" class="headerlink" title="Typescript的优缺点："></a>Typescript的优缺点：</h3><blockquote><p><strong>优点：</strong></p><p>1：快速简单，易于学习。</p><p>2：编译时提供错误检查， 在代码运行前就会进行错误提示。</p><p>3：支持所有的JS库。</p><p>4：支持ES6，提供了ES6所有优点和更高的生产力。</p><p>5：使用继承提供可重用性。</p><p>6：有助于代码结构。</p><p>7：通过定义模块来定义命名空间。</p><p><strong>缺点：</strong></p><p>1：需要长时间的来编译代码。</p><p>2：在使用第三方库时，需要有三方库的定义文件，并不是所有三方库都提供了定义文件，提供的定义文件是否准确也值得商榷。</p></blockquote><h3 id="Ts中的类型层级"><a href="#Ts中的类型层级" class="headerlink" title="Ts中的类型层级"></a>Ts中的类型层级</h3><p>在TypeScript（Ts）中，类型系统是非常强大和灵活的。类型层级（Type Hierarchy）通常指的是类型之间的继承、交叉、联合、条件等关系，这些关系共同构成了TypeScript的类型结构。虽然TypeScript没有一个显式的“类型层级”结构图，但我们可以理解一些主要的概念和它们之间的关系。</p><p>以下是TypeScript中类型层级的一些关键概念：</p><blockquote><ol><li>基础类型（Basic Types）<ul><li>包括<code>number</code>、<code>string</code>、<code>boolean</code>、<code>symbol</code>、<code>undefined</code>、<code>null</code>、<code>void</code>、<code>any</code>、<code>unknown</code>、<code>never</code>和<code>object</code>。</li><li>这些是最基本的类型，它们构成了TypeScript类型系统的基石。</li></ul></li><li>字面量类型（Literal Types）<ul><li>允许你指定变量只能是某个特定的值，如<code>let x: 42;</code>。</li></ul></li><li>数组和元组（Arrays and Tuples）<ul><li>数组类型表示一组相同类型的值的集合，如<code>let arr: number[] = [1, 2, 3];</code>。</li><li>元组类型允许你表示一个已知元素数量和类型的数组，如<code>let tuple: [string, number] = [&#39;hello&#39;, 42];</code>。</li></ul></li><li>枚举类型（Enum Types）<ul><li>枚举类型是一种特殊的数值类型，它允许你为一组命名的数值常量赋予有意义的名称。</li></ul></li><li>类类型（Class Types）<ul><li>类是TypeScript面向对象编程的基础，它们有自己的属性和方法。</li><li>你可以通过<code>new</code>关键字创建类的实例，并访问其属性和方法。</li></ul></li><li>接口（Interfaces）<ul><li>接口是TypeScript中定义对象形状的一种方式。</li><li>它们可以描述对象应该有哪些属性和方法，但不包含这些属性或方法的实现。</li></ul></li><li>类型别名（Type Aliases）<ul><li>类型别名是给一个类型起的新名字。</li><li>它们有助于简化复杂的类型签名，并提高代码的可读性。</li></ul></li><li>交叉类型（Intersection Types）<ul><li>交叉类型是将多个类型合并为一个类型。</li><li>这允许一个值同时具有多个类型的特性。</li></ul></li><li>联合类型（Union Types）<ul><li>联合类型表示一个值可以是几种类型之一。</li><li>这在处理多种可能类型的值时非常有用。</li></ul></li><li>条件类型（Conditional Types）<ul><li>条件类型允许你基于条件来选择不同的类型。</li><li>这在编写泛型代码时特别有用，可以根据输入参数的类型来返回不同的类型。</li></ul></li><li>泛型（Generics）<ul><li>泛型允许你编写灵活、可重用的代码，这些代码可以处理多种数据类型。</li><li>泛型通过类型参数来定义，这些参数可以在函数、接口和类中使用。</li></ul></li><li>索引类型（Index Types）<ul><li>索引类型用于描述具有索引签名的对象，这些对象允许你使用字符串或数字作为键来访问其属性。</li></ul></li><li>映射类型（Mapped Types）<ul><li>映射类型是基于另一个类型生成的新类型。</li><li>它们对于根据现有类型创建新类型（例如，添加或修改属性）非常有用。</li></ul></li><li>类型守卫（Type Guards）<ul><li>类型守卫是一种表达式，它执行一些运行时检查，并返回一个类型断言。</li><li>类型守卫有助于缩小联合类型的范围，并在运行时确定值的实际类型。</li></ul></li></ol></blockquote><p>这些概念共同构成了TypeScript的类型层级，使你能够构建复杂、类型安全的代码库。</p><h3 id="Ts中内置的工具类型"><a href="#Ts中内置的工具类型" class="headerlink" title="Ts中内置的工具类型"></a>Ts中内置的工具类型</h3><p>在TypeScript（Ts）中，内置的工具类型提供了一些对类型进行操作的便捷方式，从而能够创建更复杂的类型或简化类型定义。以下是一些常用的内置工具类型：</p><ol><li><p>Partial<T></p><ul><li><p>这个工具类型将类型的所有属性都变为可选的。换句话说，它接受一个类型<code>T</code>，并返回一个新的类型，其中<code>T</code>的所有属性都变成了可选属性。</p></li><li><p>示例：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>    age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   type PartialPerson <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 相当于  </span>type PartialPerson <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>    age<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>Required<T></p><ul><li><p>与<code>Partial</code>相反，<code>Required</code>工具类型将类型的所有属性都变为必选的。</p></li><li><p>示例：</p><pre class=" language-typescript"><code class="language-typescript">type RequiredPerson <span class="token operator">=</span> Required<span class="token operator">&lt;</span>PartialPerson<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 相当于  </span>type RequiredPerson <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>    age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>Readonly<T></p><ul><li><p>这个工具类型将类型的所有属性都设置为只读，意味着这些属性只能被读取，不能被重新赋值。</p></li><li><p>示例：</p><pre class=" language-typescript"><code class="language-typescript">type ReadonlyPerson <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span>Person<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 相当于  </span>type ReadonlyPerson <span class="token operator">=</span> <span class="token punctuation">{</span>    readonly name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>    readonly age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>Pick&lt;T, K extends keyof T&gt;</p><ul><li><p><code>Pick</code>工具类型从类型<code>T</code>中挑选出一组属性<code>K</code>来构造一个新的类型。</p></li><li><p>示例：</p><pre class=" language-typescript"><code class="language-typescript">type NameOnly <span class="token operator">=</span> Pick<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 相当于  </span>type NameOnly <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>Omit&lt;T, K extends keyof T&gt;</p><ul><li><p>与<code>Pick</code>相反，<code>Omit</code>工具类型从类型<code>T</code>中排除一组属性<code>K</code>来构造一个新的类型。</p></li><li><p>示例：</p><pre class=" language-typescript"><code class="language-typescript">type AgeOnly <span class="token operator">=</span> Omit<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 相当于  </span>type AgeOnly <span class="token operator">=</span> <span class="token punctuation">{</span>    age<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>Record&lt;K extends keyof any, T&gt;</p><ul><li><p><code>Record</code>工具类型用于构造一个对象的类型，该对象的属性键是<code>K</code>中的类型，属性值是<code>T</code>类型。</p></li><li><p>示例：</p><pre class=" language-typescript"><code class="language-typescript">type NameMapping <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">number</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 相当于  </span><span class="token comment" spellcheck="true">// {  </span><span class="token comment" spellcheck="true">//   [key: string]: number;  </span><span class="token comment" spellcheck="true">// }</span></code></pre></li></ul></li><li><p>Exclude&lt;T, U&gt;</p><ul><li><p>这个工具类型从类型<code>T</code>中排除所有可以赋值给类型<code>U</code>的属性或值，返回一个新的类型。</p></li><li><p>示例：</p><pre class=" language-typescript"><code class="language-typescript">typescript复制代码type T0 <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"b"</span> <span class="token operator">|</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "b" | "c"</span></code></pre></li></ul></li><li><p>Extract&lt;T, U&gt;</p><ul><li><p>与<code>Exclude</code>相反，<code>Extract</code>工具类型从类型<code>T</code>中提取所有可以赋值给类型<code>U</code>的属性或值，返回一个新的类型。</p></li><li><p>示例：</p><pre class=" language-typescript"><code class="language-typescript">typescript复制代码type T0 <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"b"</span> <span class="token operator">|</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"a"</span> <span class="token operator">|</span> <span class="token string">"f"</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "a"</span></code></pre></li></ul></li><li><p>NonNullable<T></p><ul><li><p>这个工具类型从类型<code>T</code>中排除<code>null</code>和<code>undefined</code>，返回一个新的类型。</p></li><li><p>示例：</p><pre class=" language-typescript"><code class="language-typescript">typescript复制代码type T0 <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span><span class="token keyword">string</span> <span class="token operator">|</span> <span class="token keyword">number</span> <span class="token operator">|</span> undefined<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// string | number</span></code></pre></li></ul></li></ol><p>这些工具类型在TypeScript的类型编程中非常有用，可以帮助你创建更复杂、更灵活的类型定义。</p><h3 id="Ts中常用的自定义工具类型"><a href="#Ts中常用的自定义工具类型" class="headerlink" title="Ts中常用的自定义工具类型"></a>Ts中常用的自定义工具类型</h3><p>在TypeScript（Ts）中，除了内置的工具类型，开发人员也经常根据项目的特殊需求定义自定义工具类型。这些自定义工具类型可以根据项目的具体需求来创建，以简化代码和提高工作效率。</p><p>虽然没有一个固定的“常用”自定义工具类型列表，但以下是一些可能的示例和概念，这些示例和概念可以作为创建自定义工具类型的灵感：</p><blockquote><ol><li>自定义的“选择”类型（Pick-like types）<ul><li>与内置的<code>Pick</code>类型类似，但可能具有额外的逻辑或功能。例如，你可能想要创建一个类型，该类型不仅从原始类型中选择属性，还对这些属性进行某种转换或验证。</li></ul></li><li>自定义的“排除”类型（Omit-like types）<ul><li>与内置的<code>Omit</code>类型类似，但提供了更多的灵活性。例如，你可能想要排除所有具有特定类型或满足特定条件的属性。</li></ul></li><li>类型映射（Type Mapping）<ul><li>使用映射类型（Mapped Types）和条件类型（Conditional Types）来创建新的类型，这些类型基于原始类型的每个属性进行某种转换或操作。例如，你可能想要创建一个类型，该类型将原始类型中的所有字符串属性转换为大写。</li></ul></li><li>类型合并（Type Merging）<ul><li>创建一个自定义工具类型，用于合并两个或多个类型的属性。这可以通过扩展类型、交叉类型（Intersection Types）或其他技术来实现。</li></ul></li><li>类型守卫的扩展（Extended Type Guards）<ul><li>自定义类型守卫可以用于在运行时确定值的实际类型，并返回更具体的类型信息。你可以创建自定义的类型守卫来处理特定于你项目的类型或逻辑。</li></ul></li><li>特定于领域的类型（Domain-specific types）<ul><li>对于特定的业务领域或应用场景，可能需要定义一些自定义的工具类型来更好地表示和操作数据。例如，在处理日期、时间、货币或其他复杂数据类型时，可能需要定义特定的自定义类型。</li></ul></li><li>自定义的实用程序类型（Utility types）<ul><li>创建一些实用的自定义类型，用于简化常见的类型操作或转换。这些类型可能类似于内置的实用程序类型（如<code>Partial</code>、<code>Required</code>等），但提供了更具体的功能或更适用于你的项目。</li></ul></li></ol></blockquote><p>请注意，以上示例仅作为创建自定义工具类型的灵感来源，并不是必须遵循的规范。在实际项目中，你应该根据项目的具体需求和约束来定义自定义工具类型。</p><h3 id="Ts中的类型推断、类型断言、非空断言"><a href="#Ts中的类型推断、类型断言、非空断言" class="headerlink" title="Ts中的类型推断、类型断言、非空断言"></a>Ts中的类型推断、类型断言、非空断言</h3><p>在TypeScript（Ts）中，类型推断、类型断言和非空断言是处理类型系统时非常重要的概念。下面我将分别解释这三个概念：</p><p><strong>1. 类型推断（Type Inference）</strong></p><p>类型推断是TypeScript编译器自动推断变量或表达式类型的机制。当你声明一个变量并给它赋值时，TypeScript会根据这个值来推断出变量的类型，而不需要显式地指定。</p><p>例如：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译器推断 age 的类型为 number  </span><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">"Alice"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译器推断 name 的类型为 string</span></code></pre><p>在上面的例子中，<code>age</code> 的类型被推断为 <code>number</code>，而 <code>name</code> 的类型被推断为 <code>string</code>。</p><p><strong>2. 类型断言（Type Assertion）</strong></p><p>类型断言是一种显式地告诉TypeScript编译器某个值或表达式的类型是什么的方式。当TypeScript编译器无法推断出某个值或表达式的类型，或者当你知道某个值或表达式的类型比编译器推断的更具体时，你可以使用类型断言。</p><p>类型断言有两种语法：</p><ul><li><strong>尖括号语法</strong>：<code>&lt;Type&gt;value</code></li><li><strong>as 关键字</strong>：<code>value as Type</code>（推荐在JSX或<code>tsconfig.json</code>中配置了<code>&quot;jsx&quot;: &quot;react&quot;</code>时使用）</li></ul><p>例如：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> someValue <span class="token operator">=</span> <span class="token string">"42"</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span>someValue<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用尖括号语法进行类型断言  </span><span class="token comment" spellcheck="true">// 或者  </span><span class="token keyword">let</span> num2 <span class="token operator">=</span> someValue as <span class="token keyword">number</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用as关键字进行类型断言</span></code></pre><p>注意：类型断言是告诉编译器“相信我，我知道这个值的类型”，因此应谨慎使用，因为它可能会导致运行时错误。</p><p><strong>3. 非空断言（Non-null Assertion Operator）</strong></p><p>非空断言运算符 <code>!</code> 是一个后缀表达式运算符，用于告诉TypeScript编译器某个值不是 <code>null</code> 或 <code>undefined</code>。这在你确定某个值不可能是 <code>null</code> 或 <code>undefined</code>，但TypeScript编译器无法确定时特别有用。</p><p>例如：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> obj<span class="token punctuation">:</span> <span class="token punctuation">{</span> prop<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> prop<span class="token punctuation">:</span> <span class="token string">"Hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>prop<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用非空断言确保 prop 存在</span></code></pre><p>在上面的例子中，即使 <code>prop</code> 属性是可选的，但我们确信在这个特定的上下文中 <code>prop</code> 一定是存在的，因此我们使用非空断言 <code>!</code> 来告诉TypeScript编译器这一点。</p><p>同样地，非空断言也应该谨慎使用，因为它会绕过TypeScript的 <code>null</code> 和 <code>undefined</code> 检查，可能导致运行时错误。在使用非空断言之前，请确保你完全确定该值不会是 <code>null</code> 或 <code>undefined</code>。</p><h4 id="Ts中type和interface的区别"><a href="#Ts中type和interface的区别" class="headerlink" title="Ts中type和interface的区别"></a>Ts中type和interface的区别</h4><p>在 TypeScript（Ts）中，<code>type</code> 和 <code>interface</code> 都是用于定义类型别名的机制，但它们之间有一些关键的区别和使用场景。以下是 <code>type</code> 和 <code>interface</code> 之间的主要区别：</p><p><strong>1. 语法和扩展性</strong></p><ul><li><strong>interface</strong> 使用关键字 <code>interface</code> 定义，并且可以通过 <code>extends</code> 关键字进行扩展。</li><li><strong>type</strong> 使用关键字 <code>type</code> 定义，可以使用交叉类型（<code>&amp;</code>）来组合多个类型。</li></ul><p><strong>示例：</strong></p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 使用 interface 扩展  </span><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>      name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>      breed<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用 type 交叉类型  </span>type Named <span class="token operator">=</span> <span class="token punctuation">{</span>      name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>    type Dog <span class="token operator">=</span> Named <span class="token operator">&amp;</span> <span class="token punctuation">{</span>      breed<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><strong>2. 可声明成员</strong></p><ul><li><strong>interface</strong> 可以声明属性、方法、索引签名和另一个接口。</li><li><strong>type</strong> 除了可以声明与 <code>interface</code> 相同的成员外，还可以声明基本类型、字面量类型、元组、联合类型和交叉类型。</li></ul><p><strong>示例：</strong></p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 使用 interface 声明属性和方法  </span><span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>      radius<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>      <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用 type 声明字面量类型和联合类型  </span>type Status <span class="token operator">=</span> <span class="token string">'success'</span> <span class="token operator">|</span> <span class="token string">'failure'</span> <span class="token operator">|</span> <span class="token string">'pending'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用 type 声明元组  </span>type Pair<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span>T<span class="token punctuation">,</span> T<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用 type 声明交叉类型（已在前面示例中展示）</span></code></pre><p><strong>3. 使用场景</strong></p><ul><li><strong>interface</strong> 通常用于定义对象的形状，特别是在面向对象编程中定义类的契约。</li><li><strong>type</strong> 更通用，可以用于定义任何类型别名，包括基本类型、复杂类型以及组合类型。</li></ul><p><strong>4. 互操作性</strong></p><ul><li>在某些情况下，<code>type</code> 和 <code>interface</code> 可以互换使用，但它们的互操作性受到一些限制。例如，你不能在类类型上直接实现一个 <code>type</code>，但可以实现一个 <code>interface</code>。</li></ul><p><strong>5. 默认值</strong></p><ul><li><strong>interface</strong> 不能为属性提供默认值。</li><li><strong>type</strong> 可以使用字面量类型来提供属性的默认值，但这并不是传统意义上的“默认值”，而是表示该属性只能是特定的值之一。</li></ul><p><strong>6. 兼容性</strong></p><ul><li>当两个 <code>interface</code> 合并时（例如，在不同的文件中声明了同一个 <code>interface</code>），它们会被合并成一个类型。</li><li>对于 <code>type</code>，当两个具有相同名称的 <code>type</code> 声明出现在不同的作用域中时，它们会被视为不同的类型，这可能会导致编译错误。</li></ul><p><strong>7. 泛型</strong></p><ul><li><strong>interface</strong> 可以声明泛型接口。</li><li>**type` 也可以声明泛型类型别名。</li></ul><p><strong>示例：</strong></p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 使用 interface 声明泛型接口  </span><span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>      data<span class="token punctuation">:</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用 type 声明泛型类型别名  </span>type ListType<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span>      data<span class="token punctuation">:</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>在选择使用 <code>type</code> 还是 <code>interface</code> 时，应根据具体的使用场景和需求来决定。在大多数情况下，两者都可以实现相同的功能，但它们的语法和特性有所不同。</p><h3 id="Ts中的any、unkonwn、never"><a href="#Ts中的any、unkonwn、never" class="headerlink" title="Ts中的any、unkonwn、never"></a>Ts中的any、unkonwn、never</h3><p>在TypeScript（Ts）中，<code>any</code>、<code>unknown</code> 和 <code>never</code> 是三个特殊的类型，它们用于处理类型系统中的某些边缘情况或不确定性。</p><p><strong>1. <code>any</code></strong></p><p><code>any</code> 类型是一个特殊的类型，表示“任何类型”。当你不知道一个变量或表达式确切的类型时，你可以将其类型设置为 <code>any</code>。将一个值设置为 <code>any</code> 类型后，你可以在这个值上调用任何方法或访问任何属性，而不会收到编译错误。然而，这也意味着你失去了TypeScript提供的类型检查的好处，所以应该尽量避免过度使用 <code>any</code> 类型。</p><p>示例：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token keyword">any</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>  x<span class="token punctuation">.</span><span class="token function">someNonExistentMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不会编译错误，因为 x 是 any 类型</span></code></pre><p><strong>2. <code>unknown</code></strong></p><p><code>unknown</code> 类型是一个安全的、顶级的、未知的类型。与 <code>any</code> 不同，<code>unknown</code> 类型的变量允许你进行某些操作（如赋值给 <code>any</code> 类型的变量或进行类型断言），但在你明确知道它的实际类型之前，你不能在其上调用任何方法或访问任何属性。这使得 <code>unknown</code> 类型比 <code>any</code> 类型更安全，因为它强制你进行显式的类型检查。</p><p>示例：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> y<span class="token punctuation">:</span> unknown <span class="token operator">=</span> <span class="token function">getSomeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 假设 getSomeValue 返回 unknown 类型的值  </span><span class="token comment" spellcheck="true">// y.someMethod(); // 错误：因为 y 是 unknown 类型，不能直接调用方法  </span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> y <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 现在可以，因为我们确定了 y 是 string 类型  </span><span class="token punctuation">}</span></code></pre><p><strong>3. <code>never</code></strong></p><p><code>never</code> 类型表示的是那些永不存在的值的类型。<code>never</code> 类型是所有类型的子类型，也可以看作是一个空的类型集。它通常用于表示函数永远不会返回（例如，函数总是抛出错误或进入无限循环），或者用于表示一个变量永远不会被赋值（例如，一个总是抛出错误的函数中的局部变量）。</p><p>示例：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">error</span><span class="token punctuation">(</span>message<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> never <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 变量 x 被赋值为一个 never 类型的表达式  </span><span class="token comment" spellcheck="true">// 但是，由于 never 类型没有值，所以 x 在这里实际上是没有意义的  </span><span class="token keyword">let</span> x<span class="token punctuation">:</span> never <span class="token operator">=</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Something went wrong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这会抛出错误，但 x 的类型仍然是 never  </span>  <span class="token comment" spellcheck="true">// 另一个示例：一个总是返回 false 的函数返回类型为 never  </span><span class="token keyword">function</span> <span class="token function">alwaysFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> never <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">false</span> as never<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用类型断言将 false 转换为 never 类型  </span><span class="token punctuation">}</span></code></pre><p>注意：在实际编程中，你很少会显式地声明一个变量为 <code>never</code> 类型，但 <code>never</code> 类型在 TypeScript 的类型系统中是一个重要的概念，用于处理那些不可能发生的情况。</p><h4 id="说说对-TypeScript-装饰器的理解？"><a href="#说说对-TypeScript-装饰器的理解？" class="headerlink" title="说说对 TypeScript 装饰器的理解？"></a>说说对 TypeScript 装饰器的理解？</h4><p>TypeScript 装饰器（Decorators）是一种特殊类型的声明，它可以被附加到类声明、方法、属性或参数上。装饰器使用 <code>@expression</code> 的形式，其中 <code>expression</code> 必须求值为一个函数，该函数将在运行时被调用，用来修改类的行为。</p><p>装饰器在 TypeScript 和 Angular 框架中特别常见，尤其是在 Angular 的组件、服务、指令等中。它们提供了一种声明式的方式来修改类的行为或属性，而无需修改类的代码。</p><p>以下是装饰器的一些关键点和用法：</p><ol><li><p><strong>类型</strong>：装饰器可以是类装饰器、方法装饰器、属性装饰器或参数装饰器。</p><ul><li>类装饰器：应用于类声明。</li><li>方法装饰器：应用于类的方法。</li><li>属性装饰器：应用于类的属性。</li><li>参数装饰器：应用于方法的参数。</li></ul></li><li><p><strong>语法</strong>：装饰器使用 <code>@</code> 符号，后面跟着一个函数表达式。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">classDecorator</span><span class="token punctuation">(</span><span class="token keyword">constructor</span><span class="token punctuation">:</span> <span class="token keyword">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...  </span><span class="token punctuation">}</span>   @classDecorator  <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...  </span><span class="token punctuation">}</span></code></pre></li><li><p><strong>参数</strong>：</p><ul><li>类装饰器接收一个参数，即类的构造函数。</li><li>方法装饰器接收三个参数：类的原型、方法名、以及方法的描述符（一个对象，包含 <code>value</code>、<code>writable</code>、<code>enumerable</code> 和 <code>configurable</code> 属性）。</li><li>属性装饰器接收两个参数：类的原型和属性名。</li><li>参数装饰器接收三个参数：类的原型、方法名（或访问器名）以及参数索引。</li></ul></li><li><p><strong>用途</strong>：</p><ul><li>日志和调试：可以记录类的实例化、方法的调用等。</li><li>依赖注入：在 Angular 中，装饰器用于自动注入服务。</li><li>权限控制：可以在方法或属性上添加访问权限检查。</li><li>修改或扩展类的功能：可以在运行时修改类的行为或添加新的方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>装饰器是实验性的特性，尽管在 TypeScript 中已经稳定，但在某些 JavaScript 环境中可能不受支持。</li><li>装饰器在编译时会被转换为函数调用，并附加到类的构造函数或方法上。</li><li>由于装饰器是在运行时被调用的，所以它们可能影响性能，特别是在大型应用程序中。</li></ul></li><li><p><strong>与注解（Annotations）的区别</strong>：在 Java 和其他某些语言中，注解和装饰器是类似的概念，但在 TypeScript 中，它们没有区别。装饰器就是 TypeScript 实现的注解功能。</p></li></ol><p>最后，要注意的是，装饰器在 TypeScript 中是一个高级特性，通常用于框架或库的开发中。在简单的应用程序中，可能不需要使用装饰器。但在复杂的项目中，它们可以极大地提高代码的可读性和可维护性。</p><h3 id="TypeScript-的泛型"><a href="#TypeScript-的泛型" class="headerlink" title="TypeScript 的泛型"></a>TypeScript 的泛型</h3><p>TypeScript 的泛型（Generics）是一种在定义函数、接口或类时，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。泛型允许我们编写灵活、可复用的代码，而不需要为每种数据类型都编写一遍。</p><p><strong>泛型的基本使用</strong></p><p>在 TypeScript 中，我们可以使用 <code>T</code>（或其他任何大写字母）来表示泛型类型。例如，我们可以定义一个泛型函数：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> identity<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span> T <span class="token punctuation">{</span>      <span class="token keyword">return</span> arg<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>在这个例子中，<code>T</code> 是一个类型变量，它表示我们要传入的参数类型，同时也是返回值的类型。当我们调用这个函数时，我们可以传入任何类型的参数，函数会返回同类型的值：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> output <span class="token operator">=</span> identity<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"myString"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出为 "myString"  </span><span class="token keyword">let</span> numOutput <span class="token operator">=</span> identity<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出为 123</span></code></pre><p><strong>泛型在接口和类中的使用</strong></p><p>泛型也可以用于定义接口和类。例如，我们可以定义一个泛型接口：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">GenericIdentityFn</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token punctuation">(</span>arg<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span> T<span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">function</span> identityFn<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span> T <span class="token punctuation">{</span>      <span class="token keyword">return</span> arg<span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">let</span> myIdentity<span class="token punctuation">:</span> GenericIdentityFn<span class="token operator">&lt;</span><span class="token keyword">number</span><span class="token operator">></span> <span class="token operator">=</span> identityFn<span class="token punctuation">;</span></code></pre><p>在这个例子中，我们定义了一个泛型接口 <code>GenericIdentityFn</code>，它接受一个类型为 <code>T</code> 的参数，并返回一个类型为 <code>T</code> 的值。然后我们定义了一个函数 <code>identityFn</code>，它的类型与 <code>GenericIdentityFn&lt;T&gt;</code> 匹配，并指定了 <code>T</code> 为 <code>number</code> 类型。</p><p><strong>泛型约束</strong></p><p>有时我们可能希望对泛型进行约束，以确保它至少具有某些属性或方法。这时，我们可以使用 <code>extends</code> 关键字来定义泛型约束：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Lengthwise</span> <span class="token punctuation">{</span>      length<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Lengthwise</span><span class="token operator">></span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span> T <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 现在我们可以访问arg.length了  </span>    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>在这个例子中，我们定义了一个泛型接口 <code>Lengthwise</code>，它要求任何实现该接口的类型都必须具有一个 <code>length</code> 属性。然后我们在 <code>loggingIdentity</code> 函数中使用了泛型约束 <code>T extends Lengthwise</code>，这意味着 <code>T</code> 必须是实现了 <code>Lengthwise</code> 接口的类型。因此，在这个函数中，我们可以安全地访问 <code>arg.length</code>。</p><p>以上就是对 TypeScript 泛型的基本介绍。泛型是 TypeScript 中非常强大和实用的特性之一，它允许我们编写更加灵活和可复用的代码。</p><p>相关<a href="https://www.jianshu.com/p/c8aaba6e8ce0">试题</a></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h3 id="渲染Canvas底层原理"><a href="#渲染Canvas底层原理" class="headerlink" title="渲染Canvas底层原理"></a>渲染Canvas底层原理</h3><p>Canvas的渲染底层原理主要涉及HTML5中的Canvas API和图形渲染上下文（Graphics Context）。以下是Canvas渲染的底层原理的简要概述：</p><blockquote><ol><li><strong>创建Canvas元素</strong>：首先，在HTML文档中创建一个<code>&lt;canvas&gt;</code>元素。这个元素本身并不直接显示任何内容，而是作为一个容器，用于承载后续的图形绘制。</li><li><strong>图形渲染上下文</strong>：当<code>&lt;canvas&gt;</code>元素被创建后，浏览器会为其创建一个图形渲染上下文（Graphics Context）。这个上下文是一个接口，提供了一系列的绘图API，允许开发者在<code>&lt;canvas&gt;</code>元素上进行各种绘图操作。</li><li><strong>使用Canvas API绘图</strong>：通过JavaScript代码，我们可以访问<code>&lt;canvas&gt;</code>元素的图形渲染上下文，并使用Canvas API进行绘图。这些API包括绘制线条、填充颜色、绘制图形（如圆形、矩形等）、绘制文本等。</li><li><strong>像素渲染</strong>：在绘图过程中，Canvas会将绘制的图形转换成像素数据。这个过程通常是由GPU（图形处理器）来完成的，GPU能够高效地处理大量的像素数据，从而实现流畅的图形渲染。</li><li><strong>屏幕显示</strong>：最后，Canvas将处理好的像素数据渲染到屏幕上，形成最终的图形显示。这个过程是由操作系统和浏览器共同完成的，它们负责将GPU输出的像素数据呈现在屏幕上。</li></ol></blockquote><p>需要注意的是，Canvas的渲染性能受到多种因素的影响，包括设备的性能、浏览器的实现方式、绘图的复杂度等。因此，在使用Canvas进行图形渲染时，需要注意优化代码和算法，以提高渲染性能。</p><p>此外，还有一些技术可以用于优化Canvas的渲染性能，例如使用离屏Canvas（OffscreenCanvas）进行预渲染、使用Web Workers进行多线程渲染等。这些技术可以进一步提高Canvas的渲染效率和性能。</p><h3 id="canvas-与-svg-的区别"><a href="#canvas-与-svg-的区别" class="headerlink" title="canvas 与 svg 的区别"></a>canvas 与 svg 的区别</h3><p>Canvas和SVG在网页图形渲染方面都有各自的优势和适用场景，它们之间存在一些显著的区别。</p><ol><li><p>图片格式与绘制方式：</p><blockquote><ul><li>Canvas是通过JavaScript在内存中绘制图像，然后通过浏览器将其呈现在屏幕上。绘制的图形是位图，即像素图，依赖于分辨率，能以.png和.jpg等格式保存存储图像。</li><li>SVG则是基于XML的矢量图像格式，使用矢量图像技术绘制图形。这意味着SVG图像可以任意缩放而不失真，适用于各种屏幕和打印分辨率。</li></ul></blockquote></li><li><p>事件处理与交互性：</p></li></ol><blockquote><ul><li>Canvas不支持事件处理器，即不能直接在绘制的图形上绑定事件。但是，可以通过监听整个Canvas元素的事件，并使用坐标判断来确定用户点击的是哪个图形。</li><li>SVG支持事件处理器，可以在SVG元素上绑定事件，如鼠标点击、鼠标移动等，实现更丰富的交互效果。</li></ul></blockquote><ol><li>动画与动态效果：</li></ol><blockquote><ul><li>Canvas和SVG都支持创建各种动画效果。Canvas通过JavaScript控制图形的位置、大小和颜色等属性来实现动态效果。而SVG也可以通过JavaScript来改变SVG元素的属性，实现动态交互效果。</li></ul></blockquote><ol><li>跨平台兼容性：</li></ol><blockquote><ul><li>Canvas和SVG都是基于Web标准的技术，可以在各种现代浏览器上运行，而不需要额外的插件或软件。这使得它们成为开发跨平台应用的理想选择。</li></ul></blockquote><ol><li>可扩展性与灵活性：</li></ol><blockquote><ul><li>Canvas提供了丰富的扩展功能，开发者可以通过自定义绘图算法和渲染引擎来实现更高级的图形效果。同时，Canvas还支持与其他Web技术的无缝集成，如CSS和JavaScript，使开发更加灵活和强大。</li><li>SVG同样具有可扩展性，因为它是基于XML的，可以很容易地与其他XML技术集成。此外，SVG还支持使用CSS样式进行美化，实现更丰富的视觉效果。</li></ul></blockquote><ol start="2"><li>适用范围：</li></ol><blockquote><ul><li>由于Canvas是逐像素进行渲染的，一旦图形绘制完成，就不会继续被浏览器关注。因此，Canvas适合有许多对象要被频繁重绘的图形密集型应用，如游戏。</li><li>SVG是通过DOM操作来显示的，因此更适合带有大型渲染区域的应用程序，如地图。此外，SVG还适合需要高度交互性和可缩放性的应用。</li></ul></blockquote><p>综上所述，Canvas和SVG在图片格式、事件处理、动画效果、跨平台兼容性、可扩展性和适用范围等方面都存在明显的区别。在选择使用哪种技术时，需要根据具体的应用需求和场景进行权衡和选择。</p><h2 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h2><h3 id="Http缓存："><a href="#Http缓存：" class="headerlink" title="Http缓存："></a>Http缓存：</h3><blockquote><p>http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。</p><p>http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。</p></blockquote><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-cache-2.jpg" alt="http-cache-2"></p><h4 id="1、http缓存的分类："><a href="#1、http缓存的分类：" class="headerlink" title="1、http缓存的分类："></a>1、http缓存的分类：</h4><p> 根据是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存) 根据是否可以被单个或者多个用户使用来分类，可分为(私有缓存，共享缓存) 强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。</p><p><strong>强制缓存</strong><br>强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。</p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-force-cache.jpg" alt="http缓存-强制"></p><p><strong>协商缓存</strong><br>当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现</p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-negotiation-cache.jpg" alt="http缓存-协商"></p><h4 id="2、如何使用HTTP缓存-？"><a href="#2、如何使用HTTP缓存-？" class="headerlink" title="2、如何使用HTTP缓存 ？"></a>2、如何使用HTTP缓存 ？</h4><p>一般需要缓存的资源有html页面和其他静态资源：<br><strong>html页面缓存的设置主要是在标签中嵌入标签，这种方式只对页面有效，对页面上的资源无效,静态资源的缓存一般是在web服务器上配置的</strong></p><ol><li>html页面禁用缓存的设置如下：</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pragma<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>no-cache<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>// 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cache-control<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>no-cache<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>// 其他主流浏览器识别的标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>expires<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>// 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段</code></pre><ol start="2"><li>html设置缓存如下：</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Cache-Control<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>max-age<span class="token punctuation">=</span>7200<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>// 其他主流浏览器识别的标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Expires<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Mon, 20  Aug 2018 23:00:00 GMT<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>// 仅有IE浏览器才识别的标签</code></pre><h4 id="3、缓存控制"><a href="#3、缓存控制" class="headerlink" title="3、缓存控制"></a>3、缓存控制</h4><p><strong>HTTP/1.1</strong>定义的 <a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control"><code>Cache-Control</code></a> 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p><p><strong>没有缓存</strong></p><pre class=" language-js"><code class="language-js">Cache<span class="token operator">-</span>Control<span class="token punctuation">:</span> no<span class="token operator">-</span>store</code></pre><p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p><p><strong>缓存但重新验证</strong></p><pre class=" language-undefined"><code class="language-undefined">Cache-Control: no-cache</code></pre><p>此方式下，每次有请求发出时缓存会将此请求发到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期（返回304），则缓存才使用本地缓存副本</p><p><strong>私有和公共缓存</strong></p><pre class=" language-cpp"><code class="language-cpp">Cache<span class="token operator">-</span>Control<span class="token operator">:</span> <span class="token keyword">private</span>Cache<span class="token operator">-</span>Control<span class="token operator">:</span> <span class="token keyword">public</span></code></pre><p>“public” 指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了”public”，则一些通常不被中间人缓存的页面（因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。</p><p>而 “private” 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</p><p><strong>过期</strong></p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">Cache</span><span class="token operator">-</span><span class="token builtin">Control</span><span class="token punctuation">:</span> <span class="token builtin">max</span><span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">31536000</span></code></pre><p>过期机制中，最重要的指令是 “<code>max-age=</code>“，表示资源能够被缓存（保持新鲜）的最大时间。</p><p><strong>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？</strong></p><blockquote><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载 相应的资源并进行离线存储。如果已经访问过 app，并且资源已经离线存储了， 如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资 源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如 果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文 件中的资源并进行离线存储 离线的情况下，浏览器就直接使用离线存储的资源</p></blockquote><h4 id="4、http报头-amp-amp-状态码"><a href="#4、http报头-amp-amp-状态码" class="headerlink" title="4、http报头&amp;&amp;状态码"></a>4、http报头&amp;&amp;状态码</h4><blockquote><p>HTTP请求报文由请求行、请求头部、空行和请求数据4个部分组成，下图是请求报文的一般格式。</p><p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。</p></blockquote><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-cache-3.jpg" alt="http缓存-3"></p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>提示信息，请求被成功接收</td></tr><tr><td>2xx</td><td>成功，请求被成功处理 200</td></tr><tr><td>3xx</td><td>重定向相关 304</td></tr><tr><td>4xx</td><td>客户端错误 404</td></tr><tr><td>5xx</td><td>服务端错误 500</td></tr></tbody></table><blockquote><p>200 成功处理了请求，一般情况下都是返回此状态码；<br>201 请求成功并且服务器创建了新的资源。<br>202 接受请求但没创建资源；<br>203 返回另一资源的请求；</p></blockquote><blockquote><p>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置。<br>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p></blockquote><blockquote><p>400 服务器不理解请求的语法。<br>401 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 服务器拒绝请求。<br>404 服务器找不到请求的网页。<br>408 服务器等候请求时发生超时。<br>410 如果请求的资源已永久删除，服务器就会返回此响应。<br>413 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 请求的 URI（通常为网址）过长，服务器无法处理。</p></blockquote><blockquote><p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p></blockquote><h4 id="5、HTTP与HTTPS有什么区别？"><a href="#5、HTTP与HTTPS有什么区别？" class="headerlink" title="5、HTTP与HTTPS有什么区别？"></a>5、HTTP与HTTPS有什么区别？</h4><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</p><p>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><blockquote><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></blockquote><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><blockquote><p>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET产生的URL地址可以被Bookmark，而POST不可以。<br>GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中。</p></blockquote><p>首先从安全性讲，get和post都一样，没啥所谓的哪个更安全<br>get请求参数在url地址上，直接暴露，post请求的参数放body部分，按F12也直接暴露了，所以没啥安全性可言。</p><p>GET参数通过URL传递，POST放在Request body中”这个其实也不准，post请求也可以没body，也可以在url传递呢？</p><p><strong>GET和POST有一个重大区别</strong><br>GET产生一个TCP数据包；POST产生两个TCP数据包。也就是说：<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><h3 id="WebStorage："><a href="#WebStorage：" class="headerlink" title="WebStorage："></a>WebStorage：</h3><p>Web Storage的目的是为了克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目标是：</p><ul><li>提供一种在cookie之外存储会话数据的途径。</li><li>提供一种存储大量可以跨会话存在的数据的机制。</li></ul><p>Web Storage又分为两种： sessionStorage 和localStorage ，即这两个是Storage的一个实例。从字面意思就可以很清楚的看出来，sessionStorage将数据保存在session中，浏览器关闭也就没了；而localStorage则一直将数据保存在客户端本地。其API提供的方法有以下几种：</p><pre class=" language-csharp"><code class="language-csharp">    <span class="token operator">-</span> <span class="token function">setItem</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span> ——  保存数据，以键值对的方式储存信息。    <span class="token operator">-</span> <span class="token function">getItem</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> ——  获取数据，将键值传入，即可获取到对应的<span class="token keyword">value</span>值。    <span class="token operator">-</span> <span class="token function">removeItem</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> ——  删除单个数据，根据键值移除对应的信息。    <span class="token operator">-</span> <span class="token function">clear</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> ——  删除所有的数据    <span class="token operator">-</span> <span class="token function">key</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> —— 获取某个索引的key</code></pre><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。localStorage有length属性，可以查看其有多少条记录的数据。使用方法如下：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">var</span> storage <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>localStorage<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//判断浏览器是否支持localStorage</span>     storage <span class="token operator">=</span> window<span class="token punctuation">.</span>localStorage<span class="token punctuation">;</span>          storage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Rick"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用setItem方法，存储数据</span>     <span class="token function">alert</span><span class="token punctuation">(</span>storage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//调用getItem方法，弹框显示 name 为 Rick</span>     storage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//调用removeItem方法，移除数据</span>     <span class="token function">alert</span><span class="token punctuation">(</span>storage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//调用getItem方法，弹框显示 name 为 null</span><span class="token punctuation">}</span></code></pre><p>localStorage 相对sessionStorage简单一点，需要注意的地方不是很多。</p><h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。需要注意的有以下几点：</p><ul><li>页面刷新不会消除数据;</li><li>只有在当前页面打开的链接，才可以访sessionStorage的数据；</li><li>使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据;</li></ul><h4 id="WebStorage与cookie的区别："><a href="#WebStorage与cookie的区别：" class="headerlink" title="WebStorage与cookie的区别："></a>WebStorage与cookie的区别：</h4><blockquote><p>cookie是在HTML4中使用的给客户端保存数据的，也可以和session配合实现跟踪浏览器用户身份；</p></blockquote><p><strong>相同点：</strong></p><p> cookie，localStorage，sessionStorage都是在客户端保存数据的，存储数据的类型：都是字符串。</p><p><strong>不同点：</strong></p><ol><li>生命周期：</li></ol><blockquote><p>1）、cookie如果不设置有效期，那么就是临时存储（存储在内存中），是会话级别的，会话结束后，cookie也就失效了，如果设置了有效期，那么cookie存储在硬盘里，有效期到了，就自动消失了。</p><p>2）、localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。</p><p>3）、sessionStorage仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。</p><p>可以简单的理解为：sessionStorage，没有设置有效期的cookie。</p><p>如果说把cookie的有效期设置为永远永远，永久，那么就是localStorage。</p><p>cookie没有设置有效期，那么就是sessionStorage                  </p></blockquote><ol start="2"><li><p>网络流量：cookie的数据每次都会发给服务器端，而localstorage和sessionStorage不会与服务器端通信，纯粹为了保存数据，所以，webstorage更加节约网络流量。</p></li><li><p>大小限制：cookie大小限制在4KB，非常小；localstorage和sessionStorage在5M</p></li><li><p>安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获。</p></li></ol><h4 id="cookie的配置："><a href="#cookie的配置：" class="headerlink" title="cookie的配置："></a>cookie的配置：</h4><p>通常我们有两种方式给浏览器设置或获取Cookie：</p><ul><li><p>第一种 通过 HTTP 方式对 Cookie 进行赋值，又分为 Request 和 Response：</p></li><li><ul><li>HTTP Response Headers 中的 Set-Cookie Header</li><li>HTTP Request Headers 中的 Cookie Header</li></ul></li><li><p>第二种 通过JavaScript对document.cookie进行赋值或取值。</p></li></ul><p><strong>1. HTTP Cookie</strong></p><p>Set-Cookie Header，除了必须包含Cookie正文，还可以选择性包含6个属性：</p><pre class=" language-text"><code class="language-text">path、domain、max-age、expires、secure、httponly</code></pre><p>它们之间用英文分号和空格（”; “）连接，示例：</p><pre class=" language-http"><code class="language-http">Set-Cookie:  key=value;   path=path;    domain=domain;    max-age=max-age-in-seconds;    expires=date-in-GMTString-format;    secure; httponly</code></pre><p><strong>JS Cookie</strong></p><p>在浏览器端，通过 document.cookie 也可以设置Cookie，JS Cookie 的内容除了必须包含正文之外，还可选5个属性：</p><pre class=" language-text"><code class="language-text">path、domain、max-age、expires、secure</code></pre><p>下面是简单的示例：</p><pre class=" language-js"><code class="language-js">document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">"key=value; path=path; domain=domain; max-age=max-age-in-seconds; expires=date-in-GMTString-format; secure"</span><span class="token punctuation">;</span></code></pre><p>JS 中设置 Cookie 和 HTTP 方式相比较，少了对 <strong>HttpOnly</strong> 的控制，是因为 JS 不能读写HttpOnly Cookie。</p><h2 id="浏览器安全相关"><a href="#浏览器安全相关" class="headerlink" title="浏览器安全相关"></a>浏览器安全相关</h2><h3 id="盗用cookie的手段"><a href="#盗用cookie的手段" class="headerlink" title="盗用cookie的手段"></a>盗用cookie的手段</h3><p>在别的浏览器中来冒用合法用户访问系统；黑客自然不能手动拿你浏览器中的cookie值，除非黑客就是你身边的人，那他就不是黑客了，是盗贼；</p><p>黑客都是靠技术手段获取别人的东西，例如：利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页中，然后自动从用户浏览器中获取cookie的值，此技术手段被称为<a href="https://blog.csdn.net/zemprogram/article/details/109451863"><strong>XSS攻击</strong></a>；</p><p><strong>如果cookie中设置了HttpOnly属性，且为true，那么通过js脚本将无法读取到cookie信息，这样就能有效的防止XSS攻击，防止cookie内容被盗窃。</strong></p><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>　　 在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.<br>    Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。<br>    Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://juejin.cn/post/6844903955286196237">【THE LAST TIME】彻底吃透 JavaScript 执行机制</a></p><p><a href="https://juejin.cn/post/6844903984335945736">【THE LAST TIME】一文吃透所有JS原型相关知识点</a></p><p><a href="https://imququ.com/post/host-only-cookie.html">你所不知道的HostOnly Cookie</a></p><p><a href="https://blog.csdn.net/zemprogram/article/details/109451863">计算机网络–网络攻击XSS与CSRF</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">CSS Flex 弹性布局（一） - 阮一峰</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">CSS Flex 弹性布局（二） - 阮一峰</a></p><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局 - 阮一峰</a></p><p><a href="https://typescript.bootcss.com/">TypeScript 中文手册</a></p><p><a href="https://www.jianshu.com/p/c8aaba6e8ce0">TypeScript-相关试题</a></p><p><a href="https://blog.csdn.net/qq_27575925/article/details/113758050">深度剖析JavaScript ES5/ AMD/ CMD/ COMMONJS/ ES6模块化</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 个人知识库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
