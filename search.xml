<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式 - Javascript</title>
      <link href="/2023/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Javascript/"/>
      <url>/2023/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Javascript/</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式（Design pattern），在项目开发过程中面临的一般问题的解决方案，包括JS常见设计模式以及应用场景，适合有JS基础的同学进阶学习。</p></blockquote><h3 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h3><p>​    </p><h4 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式 (Singleton Pattern)"></a>单例模式 (Singleton Pattern)</h4><blockquote><p><strong>简介：</strong> 单例模式是一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点来获取该实例。这在需要控制资源访问、配置管理以及避免重复创建对象时非常有用。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Singleton<span class="token punctuation">.</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 在这里可以进行一些初始化操作</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      Singleton<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addData</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用单例</span><span class="token keyword">const</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span><span class="token function">addData</span><span class="token punctuation">(</span><span class="token string">'Item 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance2<span class="token punctuation">.</span><span class="token function">addData</span><span class="token punctuation">(</span><span class="token string">'Item 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: ["Item 1", "Item 2"]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1 <span class="token operator">===</span> instance2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: true，它们是同一个实例</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们定义了一个名为 <code>Singleton</code> 的类，构造函数中检查是否已经存在实例，如果不存在则进行初始化并保存实例。</li><li><code>addData</code> 和 <code>getData</code> 方法用于操作和获取数据。</li><li>使用 <code>new</code> 操作符创建对象实例时，始终返回同一个实例。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>全局资源管理：</strong> 单例模式常用于全局配置、日志记录、数据库连接池等场景中，确保只有一个实例用于管理全局资源。</li><li><strong>延迟加载：</strong> 单例模式可以用于延迟对象的创建，直到首次使用时才创建对象，节省资源。</li><li><strong>避免竞态条件：</strong> 在多线程环境中，单例模式可以用于避免竞态条件，确保只有一个实例被创建。</li></ol></blockquote><p>​    单例模式在需要确保只有一个实例存在的情况下非常有用，同时提供了一个全局访问点以方便访问该实例。</p><p>​    </p><h4 id="工厂模式-Factory-Pattern"><a href="#工厂模式-Factory-Pattern" class="headerlink" title="工厂模式 (Factory Pattern)"></a>工厂模式 (Factory Pattern)</h4><blockquote><p><strong>简介：</strong> 工厂模式是一种创建型设计模式，用于封装对象的创建过程，以便根据需要创建不同类型的对象。它将对象的创建与使用分离，使代码更具灵活性和可维护性。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 定义产品类</span><span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`This is a </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义工厂类</span><span class="token keyword">class</span> <span class="token class-name">ProductFactory</span> <span class="token punctuation">{</span>  <span class="token function">createProduct</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用工厂创建不同类型的产品</span><span class="token keyword">const</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProductFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> product1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">'Widget'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> product2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">'Gadget'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>product1<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "This is a Widget."</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>product2<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "This is a Gadget."</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们定义了一个产品类 <code>Product</code>，它有一个构造函数和一个 <code>getDescription</code> 方法。</li><li>工厂类 <code>ProductFactory</code> 包含一个 <code>createProduct</code> 方法，用于创建产品对象。</li><li>使用工厂类创建不同类型的产品对象，客户端代码只需要指定产品的名称，而不需要知道产品的创建细节。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong></p><ol><li><strong>隐藏对象创建细节：</strong> 工厂模式允许隐藏对象的具体创建方式和初始化过程，使客户端代码不需要关心对象的创建细节。</li><li><strong>统一接口：</strong> 工厂模式提供了一个统一的接口，用于创建不同类型的对象，使客户端代码可以通过相同的方式创建不同对象。</li><li><strong>降低耦合性：</strong> 客户端代码与具体对象的创建过程解耦，使代码更容易维护和扩展。如果需要更改对象的创建方式，只需修改工厂类而不影响客户端代码。</li><li><strong>对象池管理：</strong> 工厂模式可以用于创建和管理对象池，以提高性能和资源利用率。例如，数据库连接池可以使用工厂模式来管理连接对象。</li></ol></blockquote><p>   工厂模式通常在需要创建多个具有相似属性和方法的对象实例时使用，以减少重复的代码并提高代码的可维护性。</p><p>​    </p><h4 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式 (Abstract Factory Pattern)"></a>抽象工厂模式 (Abstract Factory Pattern)</h4><blockquote><p><strong>简介：</strong> 抽象工厂模式是一种创建型设计模式，用于创建一组相关或相互依赖的对象，而无需指定其具体类。它提供一个接口，用于创建产品的家族，而不需要知道具体产品的类。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 抽象工厂接口</span><span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>  <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体工厂类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>  <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>  <span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductA2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProductB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 抽象产品类</span><span class="token keyword">class</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span>  <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体产品类</span><span class="token keyword">class</span> <span class="token class-name">ProductA1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation A1'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ProductB1</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span>  <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation B1'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ProductA2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductA</span> <span class="token punctuation">{</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation A2'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ProductB2</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProductB</span> <span class="token punctuation">{</span>  <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation B2'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用抽象工厂创建产品</span><span class="token keyword">function</span> <span class="token function">clientCode</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> productA <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> productB <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>productA<span class="token punctuation">.</span><span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Operation A1" 或 "Operation A2"</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>productB<span class="token punctuation">.</span><span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Operation B1" 或 "Operation B2"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用具体工厂1</span><span class="token keyword">const</span> factory1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clientCode</span><span class="token punctuation">(</span>factory1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用具体工厂2</span><span class="token keyword">const</span> factory2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clientCode</span><span class="token punctuation">(</span>factory2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们定义了一个抽象工厂接口 <code>AbstractFactory</code>，它包含两个方法 <code>createProductA()</code> 和 <code>createProductB()</code>。</li><li>有两个具体工厂类 <code>ConcreteFactory1</code> 和 <code>ConcreteFactory2</code>，它们分别实现了抽象工厂接口，负责创建一组相关的产品。</li><li>抽象产品类 <code>AbstractProductA</code> 和 <code>AbstractProductB</code> 定义了产品的接口。</li><li>具体产品类 <code>ProductA1</code>、<code>ProductB1</code>、<code>ProductA2</code> 和 <code>ProductB2</code> 实现了抽象产品类，提供具体的产品。</li></ul></blockquote><p>​    </p><p><strong>用途：</strong></p><blockquote><ol><li><strong>创建一组相关对象：</strong> 抽象工厂模式用于创建一组相关的产品，例如创建不同风格的用户界面组件，如按钮、文本框、和下拉框。</li><li><strong>确保产品一致性：</strong> 它确保创建的产品是一致的，因为每个具体工厂都负责创建一组产品，这些产品之间具有一致的风格和行为。</li><li><strong>隐藏对象创建细节：</strong> 抽象工厂模式隐藏了具体对象的创建细节，客户端代码只需要与抽象工厂接口交互，而不需要知道具体的产品类。</li><li><strong>支持产品族扩展：</strong> 可以轻松扩展产品族，只需创建新的具体工厂类，无需修改现有客户端代码。</li></ol></blockquote><p>​    抽象工厂模式通常在需要创建一组相关产品，同时保持这些产品一致性的情况下使用。</p><p>​    </p><h4 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式 (Builder Pattern)"></a>建造者模式 (Builder Pattern)</h4><blockquote><p>​    <strong>简介：</strong> 建造者模式是一种创建型设计模式，用于分步构建一个复杂对象。它将对象的构建过程与其表示分离，允许同一构建过程创建不同的表示。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 产品类</span><span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addPart</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parts<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">listParts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parts<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">', '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 抽象建造者</span><span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>  <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体建造者</span><span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>product<span class="token punctuation">.</span><span class="token function">addPart</span><span class="token punctuation">(</span><span class="token string">'Part A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>product<span class="token punctuation">.</span><span class="token function">addPart</span><span class="token punctuation">(</span><span class="token string">'Part B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>product<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 指挥者</span><span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用建造者构建产品</span><span class="token keyword">const</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> product <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Product Parts:'</span><span class="token punctuation">,</span> product<span class="token punctuation">.</span><span class="token function">listParts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Product Parts: Part A, Part B"</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个产品类 <code>Product</code>，它包含一个数组用于存储部件。</li><li>抽象建造者 <code>Builder</code> 定义了构建产品的步骤，包括 <code>buildPartA</code> 和 <code>buildPartB</code> 方法，以及获取最终产品的 <code>getResult</code> 方法。</li><li>具体建造者 <code>ConcreteBuilder</code> 继承了抽象建造者，并实现了具体的构建步骤。</li><li>指挥者 <code>Director</code> 接受一个建造者，并通过调用建造者的方法来构建产品。</li><li>最后，我们使用具体建造者来构建产品，并获取最终产品。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>构建复杂对象：</strong> 建造者模式用于创建复杂对象，其中构建过程包含多个步骤，不同步骤可以生成不同的表示。</li><li><strong>分离构建和表示：</strong> 它允许将对象的构建过程与其表示分离，从而使代码更加灵活，可以使用不同的构建过程来创建不同的对象。</li><li><strong>避免重叠构造器：</strong> 当有多个构造器参数时，可以使用建造者模式来避免创建多个重叠的构造器。</li></ol></blockquote><p>​    建造者模式常用于创建复杂的对象，例如创建配置对象、文档对象、以及图形对象等。</p><p>​    </p><h4 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式 (Prototype Pattern)"></a>原型模式 (Prototype Pattern)</h4><blockquote><p>​    <strong>简介：</strong>原型模式是一种创建型设计模式，用于创建对象的新实例，同时保持原始对象的原型。这允许通过复制现有对象来创建新对象，而无需重新创建它们。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 原型对象</span><span class="token keyword">class</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>property1 <span class="token operator">=</span> <span class="token string">'Default Value'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建新对象并复制原型属性</span>    <span class="token keyword">const</span> clone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">this<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    clone<span class="token punctuation">.</span>property1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property1<span class="token punctuation">;</span>    <span class="token keyword">return</span> clone<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体原型对象</span><span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">extends</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>property1 <span class="token operator">=</span> <span class="token string">'Custom Value'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用原型创建新对象</span><span class="token keyword">const</span> prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> clone1 <span class="token operator">=</span> prototype<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> clone2 <span class="token operator">=</span> prototype<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>clone1<span class="token punctuation">.</span>property1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Custom Value"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>clone2<span class="token punctuation">.</span>property1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Custom Value"</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个原型对象 <code>Prototype</code>，它包含一个属性 <code>property1</code> 和一个 <code>clone</code> 方法，用于创建新对象并复制原型属性。</li><li>具体原型对象 <code>ConcretePrototype</code> 继承了原型对象，并重写了属性 <code>property1</code>。</li><li>我们创建一个具体原型对象 <code>prototype</code>，然后通过调用 <code>clone</code> 方法来创建新对象 <code>clone1</code> 和 <code>clone2</code>。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>创建对象副本：</strong> 原型模式用于创建对象的副本，新对象包含与原始对象相同的属性和方法。</li><li><strong>避免构造函数调用：</strong> 原型模式创建对象时不会调用构造函数，可以提高性能和避免可能的副作用。</li><li><strong>支持动态配置：</strong> 可以在原型对象上设置默认属性，然后通过复制原型来创建对象，并根据需要更改属性值。</li></ol></blockquote><p>​    原型模式通常在需要创建多个类似对象实例，且这些对象共享某些初始属性或状态时使用。</p><h3 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h3><p>​    </p><h4 id="装饰器模式-Decorator-Pattern"><a href="#装饰器模式-Decorator-Pattern" class="headerlink" title="装饰器模式 (Decorator Pattern)"></a>装饰器模式 (Decorator Pattern)</h4><blockquote><p>​    <strong>简介：</strong>装饰器模式是一种结构型设计模式，用于动态地将新行为附加到对象上，而无需修改其代码。它允许你在运行时通过将对象包装在装饰器对象中来添加新的功能。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 基础组件</span><span class="token keyword">class</span> <span class="token class-name">Coffee</span> <span class="token punctuation">{</span>  <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Coffee'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 装饰器基类</span><span class="token keyword">class</span> <span class="token class-name">CoffeeDecorator</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>coffee<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>coffee <span class="token operator">=</span> coffee<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体装饰器类</span><span class="token keyword">class</span> <span class="token class-name">MilkDecorator</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeDecorator</span> <span class="token punctuation">{</span>  <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">', Milk'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SugarDecorator</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeDecorator</span> <span class="token punctuation">{</span>  <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>coffee<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">', Sugar'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用装饰器</span><span class="token keyword">const</span> plainCoffee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Plain Coffee:'</span><span class="token punctuation">,</span> plainCoffee<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Cost:'</span><span class="token punctuation">,</span> plainCoffee<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> coffeeWithMilk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MilkDecorator</span><span class="token punctuation">(</span>plainCoffee<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Coffee with Milk:'</span><span class="token punctuation">,</span> coffeeWithMilk<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Cost:'</span><span class="token punctuation">,</span> coffeeWithMilk<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> coffeeWithMilkAndSugar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SugarDecorator</span><span class="token punctuation">(</span>coffeeWithMilk<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Coffee with Milk and Sugar:'</span><span class="token punctuation">,</span> coffeeWithMilkAndSugar<span class="token punctuation">.</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Cost:'</span><span class="token punctuation">,</span> coffeeWithMilkAndSugar<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们有一个基础组件 <code>Coffee</code>，它有 <code>cost</code> 和 <code>getDescription</code> 方法。</li><li>装饰器基类 <code>CoffeeDecorator</code> 包装了基础组件，并重写了相同的方法以添加额外的功能。</li><li>具体装饰器类 <code>MilkDecorator</code> 和 <code>SugarDecorator</code> 继承自装饰器基类，它们重写了 <code>cost</code> 和 <code>getDescription</code> 方法来添加牛奶和糖的功能。</li><li>我们可以创建一个基础组件对象，然后通过将装饰器对象包装在它上面来添加额外的功能。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>动态扩展对象功能：</strong> 装饰器模式允许你在不修改现有对象的情况下，动态地添加新功能。</li><li><strong>避免类爆炸：</strong> 它避免了通过创建多个子类来添加功能，从而减少了类的数量。</li><li><strong>开放封闭原则：</strong> 装饰器模式遵循开放封闭原则，允许你添加新功能而不修改已有代码。</li></ol></blockquote><p>​    装饰器模式通常在需要在运行时添加或删除对象的功能时使用。</p><p>​    </p><h4 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式 (Adapter Pattern)"></a>适配器模式 (Adapter Pattern)</h4><blockquote><p>​    <strong>简介：</strong>适配器模式是一种结构型设计模式，用于将一个类的接口转换成客户端所期望的另一个接口。它允许不兼容的接口能够一起工作。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 老接口</span><span class="token keyword">class</span> <span class="token class-name">OldSystem</span> <span class="token punctuation">{</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation A from Old System'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 新接口</span><span class="token keyword">class</span> <span class="token class-name">NewSystem</span> <span class="token punctuation">{</span>  <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Operation B from New System'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 适配器类</span><span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>newSystem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>newSystem <span class="token operator">=</span> newSystem<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>newSystem<span class="token punctuation">.</span><span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用适配器</span><span class="token keyword">const</span> newSystem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewSystem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span>newSystem<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newSystem<span class="token punctuation">.</span><span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Operation B from New System"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>adapter<span class="token punctuation">.</span><span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 输出: "Operation B from New System"</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们有一个老系统 <code>OldSystem</code>，它有一个名为 <code>operationA</code> 的方法。</li><li>我们引入了一个新系统 <code>NewSystem</code>，它有一个名为 <code>operationB</code> 的方法。</li><li>为了使老系统的 <code>operationA</code> 方法能够使用新系统的功能，我们创建了一个适配器 <code>Adapter</code>，它包装了新系统的实例并将 <code>operationA</code> 映射到新系统的 <code>operationB</code>。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>兼容新旧代码：</strong> 适配器模式允许在新旧系统之间创建一个桥梁，以便它们可以一起工作，而无需修改已有代码。</li><li><strong>接口转换：</strong> 当需要将一个接口转换成另一个接口时，适配器模式可以用于实现这种转换。</li><li><strong>解耦性：</strong> 适配器模式可以降低两个不同接口之间的耦合性，使系统更加灵活和可维护。</li></ol></blockquote><p>​        适配器模式通常在需要将已有接口与新接口协同工作，或者在整合不同系统时使用。</p><p>​    </p><h4 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式 (Proxy Pattern)"></a>代理模式 (Proxy Pattern)</h4><blockquote><p>​    <strong>简介：</strong>代理模式是一种结构型设计模式，它允许你提供一个代理对象来控制对另一个对象的访问。代理通常用于在访问对象之前或之后执行一些额外的操作，例如延迟加载、权限控制、日志记录等。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 真实主题</span><span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token punctuation">{</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'RealSubject: Handling request.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 代理</span><span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>realSubject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>realSubject <span class="token operator">=</span> realSubject<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>realSubject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">logAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 模拟权限检查</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Proxy: Checking access.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">logAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 模拟日志记录</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Proxy: Logging access.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> realSubject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>realSubject<span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们有一个真实主题 <code>RealSubject</code>，它实现了一个 <code>request</code> 方法。</li><li>代理类 <code>Proxy</code> 包装了真实主题，并在访问真实主题之前执行了权限检查和日志记录。</li><li>客户端代码通过代理对象来访问真实主题。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>远程代理：</strong> 代理模式可以用于实现远程对象的代理，允许客户端访问远程服务器上的对象。</li><li><strong>虚拟代理：</strong> 代理模式可以用于实现虚拟代理，延迟加载对象以节省资源。</li><li><strong>权限控制：</strong> 代理模式可以用于实现权限控制，只有具有适当权限的用户才能访问某些对象。</li><li><strong>日志记录：</strong> 代理模式可以用于记录对象的访问历史和行为，以便调试和监控。</li></ol></blockquote><p>​    代理模式通常在需要在访问对象之前或之后执行某些操作，或者在访问对象时控制访问的情况下使用。</p><p>​    </p><h4 id="桥接模式-Bridge-Pattern"><a href="#桥接模式-Bridge-Pattern" class="headerlink" title="桥接模式 (Bridge Pattern)"></a>桥接模式 (Bridge Pattern)</h4><blockquote><p>​    <strong>简介：</strong>桥接模式是一种结构型设计模式，用于将一个抽象与其实现部分分离，使它们可以独立地变化。它将一个大类或一组类分成两个独立的层次结构，使抽象和实现可以独立扩展。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 实现接口</span><span class="token keyword">class</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体实现类A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorA</span> <span class="token keyword">extends</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Concrete Implementor A Operation'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体实现类B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorB</span> <span class="token keyword">extends</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'Concrete Implementor B Operation'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 抽象类</span><span class="token keyword">class</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>implementor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>implementor <span class="token operator">=</span> implementor<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>implementor<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体抽象类X</span><span class="token keyword">class</span> <span class="token class-name">ConcreteAbstractionX</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Concrete Abstraction X: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>implementor<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体抽象类Y</span><span class="token keyword">class</span> <span class="token class-name">ConcreteAbstractionY</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Concrete Abstraction Y: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>implementor<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> implementorA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> implementorB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementorB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> abstractionX <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteAbstractionX</span><span class="token punctuation">(</span>implementorA<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> abstractionY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteAbstractionY</span><span class="token punctuation">(</span>implementorB<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>abstractionX<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Concrete Abstraction X: Concrete Implementor A Operation"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>abstractionY<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出: "Concrete Abstraction Y: Concrete Implementor B Operation"</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们有一个实现接口 <code>Implementor</code>，它包含一个 <code>operation</code> 方法。</li><li>具体实现类 <code>ConcreteImplementorA</code> 和 <code>ConcreteImplementorB</code> 分别实现了 <code>Implementor</code> 接口，并提供具体的操作。</li><li>抽象类 <code>Abstraction</code> 包含一个 <code>Implementor</code> 实例，并提供了一个 <code>operation</code> 方法，该方法调用 <code>Implementor</code> 实例的操作。</li><li>具体抽象类 <code>ConcreteAbstractionX</code> 和 <code>ConcreteAbstractionY</code> 继承自 <code>Abstraction</code>，并可以修改 <code>Implementor</code> 实例的操作结果。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>分离抽象和实现：</strong> 桥接模式将抽象和实现分离，允许它们独立变化，从而提高了代码的灵活性。</li><li><strong>多维度变化：</strong> 当一个类有多个独立的变化维度时，桥接模式可以避免类的指数性增长。</li></ol></blockquote><p>​    桥接模式通常在需要处理多个变化维度且希望避免创建多个类的情况下使用。</p><p>​    </p><h4 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式 (Composite Pattern)"></a>组合模式 (Composite Pattern)</h4><blockquote><p>​    <strong>简介：</strong>组合模式是一种结构型设计模式，用于将对象组合成树状结构以表示部分-整体层次结构。它使客户端可以统一地处理单个对象和组合对象。</p></blockquote><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 抽象组件</span><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 叶子组件</span><span class="token keyword">class</span> <span class="token class-name">Leaf</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Leaf </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is operated.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 复合组件</span><span class="token keyword">class</span> <span class="token class-name">Composite</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Composite </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is operated.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> child <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>      child<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">add</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">remove</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用组合模式</span><span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">'Root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> branch1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">'Branch 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> branch2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">'Branch 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> leaf1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">'Leaf 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> leaf2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">'Leaf 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> leaf3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">'Leaf 3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>branch1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaf1<span class="token punctuation">)</span><span class="token punctuation">;</span>branch1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaf2<span class="token punctuation">)</span><span class="token punctuation">;</span>branch2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaf3<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>branch1<span class="token punctuation">)</span><span class="token punctuation">;</span>root<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>branch2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用操作</span>root<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了抽象组件类 <code>Component</code>，它包含一个 <code>name</code> 属性和一个 <code>operation</code> 方法。</li><li>叶子组件 <code>Leaf</code> 继承自 <code>Component</code>，实现了具体的 <code>operation</code> 方法。</li><li>复合组件 <code>Composite</code> 也继承自 <code>Component</code>，它包含一个 <code>children</code> 数组来存储子组件，并实现了 <code>operation</code>、<code>add</code> 和 <code>remove</code> 方法。</li><li>我们创建了一个组合结构，包括根节点、分支节点和叶子节点，然后通过 <code>add</code> 方法将它们组合在一起。</li><li>最后，我们调用根节点的 <code>operation</code> 方法，它会递归执行所有子组件的 <code>operation</code> 方法。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>表示部分-整体层次结构：</strong> 组合模式用于表示具有部分-整体层次结构的对象，允许客户端一致地处理单个对象和组合对象。</li><li><strong>简化客户端代码：</strong> 客户端不需要知道具体的组合结构，只需与抽象组件类交互。</li><li><strong>支持递归操作：</strong> 组合模式支持递归操作，可以对整个组合结构执行操作。</li></ol></blockquote><p>​    组合模式通常在需要构建具有层次结构的对象，并希望客户端能够一致地处理不同层次的对象时使用。</p><h3 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h3><p>​    </p><h4 id="观察者模式-Observer-Pattern"><a href="#观察者模式-Observer-Pattern" class="headerlink" title="观察者模式 (Observer Pattern)"></a>观察者模式 (Observer Pattern)</h4><blockquote><p>​    <strong>简介：</strong>观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象可以自动收到被观察对象的状态变化通知并进行相应的处理。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 主题 (被观察者)</span><span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>observers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">removeObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> observer <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>      observer<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 观察者接口</span><span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>  <span class="token function">update</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体观察者</span><span class="token keyword">class</span> <span class="token class-name">ConcreteObserverA</span> <span class="token keyword">extends</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>  <span class="token function">update</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Observer A received the update from subject.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConcreteObserverB</span> <span class="token keyword">extends</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>  <span class="token function">update</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Observer B received the update from subject.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> observerA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserverA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> observerB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserverB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>observerA<span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>observerB<span class="token punctuation">)</span><span class="token punctuation">;</span>subject<span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个主题（被观察者） <code>Subject</code>，它包含了一个观察者数组 <code>observers</code>，并提供了添加、移除、通知观察者的方法。</li><li>观察者接口 <code>Observer</code> 定义了一个 <code>update</code> 方法，具体的观察者需要实现这个方法。</li><li>具体观察者 <code>ConcreteObserverA</code> 和 <code>ConcreteObserverB</code> 继承自 <code>Observer</code>，并实现了 <code>update</code> 方法来处理主题的通知。</li><li>客户端代码创建了一个主题对象，然后添加了两个观察者，最后通过 <code>notifyObservers</code> 方法通知观察者。</li></ul></blockquote><p>​<br>​</p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>解耦性：</strong> 观察者模式可以将主题与观察者解耦，使主题不需要知道观察者的具体实现。</li><li><strong>一对多通知：</strong> 它允许一个主题通知多个观察者，每个观察者可以根据自己的需求对通知做出响应。</li><li><strong>动态变化：</strong> 观察者模式支持动态地添加或移除观察者，主题和观察者之间的关系可以随时变化。</li></ol></blockquote><p>​    观察者模式通常在需要实现发布-订阅系统、事件处理、用户界面组件更新等场景中使用。</p><p>​    </p><h4 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式 (Strategy Pattern)"></a>策略模式 (Strategy Pattern)</h4><blockquote><p> <strong>简介：</strong>策略模式是一种行为型设计模式，它定义了一系列算法，将每个算法封装成一个策略，使这些策略可以互相替换。客户端可以选择不同的策略来实现不同的行为。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 策略接口</span><span class="token keyword">class</span> <span class="token class-name">PaymentStrategy</span> <span class="token punctuation">{</span>  <span class="token function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体策略类：信用卡支付</span><span class="token keyword">class</span> <span class="token class-name">CreditCardPayment</span> <span class="token keyword">extends</span> <span class="token class-name">PaymentStrategy</span> <span class="token punctuation">{</span>  <span class="token function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Paid $</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>amount<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> with Credit Card.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体策略类：PayPal支付</span><span class="token keyword">class</span> <span class="token class-name">PayPalPayment</span> <span class="token keyword">extends</span> <span class="token class-name">PaymentStrategy</span> <span class="token punctuation">{</span>  <span class="token function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Paid $</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>amount<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> with PayPal.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体策略类：现金支付</span><span class="token keyword">class</span> <span class="token class-name">CashPayment</span> <span class="token keyword">extends</span> <span class="token class-name">PaymentStrategy</span> <span class="token punctuation">{</span>  <span class="token function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Paid $</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>amount<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> in Cash.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 环境类</span><span class="token keyword">class</span> <span class="token class-name">ShoppingCart</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>paymentStrategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paymentStrategy <span class="token operator">=</span> paymentStrategy<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">checkout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span> <span class="token punctuation">{</span>      total <span class="token operator">+</span><span class="token operator">=</span> item<span class="token punctuation">.</span>price<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paymentStrategy<span class="token punctuation">.</span><span class="token function">pay</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> cart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShoppingCart</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CreditCardPayment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cart<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Item 1'</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token number">25</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cart<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Item 2'</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cart<span class="token punctuation">.</span><span class="token function">checkout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个策略接口 <code>PaymentStrategy</code>，它包含一个 <code>pay</code> 方法。</li><li>具体策略类 <code>CreditCardPayment</code>、<code>PayPalPayment</code> 和 <code>CashPayment</code> 分别继承自 <code>PaymentStrategy</code>，并实现了 <code>pay</code> 方法来完成具体的支付方式。</li><li>环境类 <code>ShoppingCart</code> 接受一个支付策略，并包含一个 <code>items</code> 数组来存储购物车中的物品。</li><li>客户端代码创建了一个购物车对象，选择了信用卡支付策略，然后添加了两个物品并进行结算。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>多算法选择：</strong> 策略模式用于在运行时选择算法，使客户端能够灵活地选择不同的策略。</li><li><strong>解耦性：</strong> 它将算法的实现与客户端代码分离，提高了代码的可维护性。</li><li><strong>替代继承：</strong> 策略模式可以替代多层继承，避免类爆炸问题。</li></ol></blockquote><p>​    策略模式通常在需要动态地切换算法或在一个类有多种行为变体的情况下使用。</p><p>​    </p><h4 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式 (Command Pattern)"></a>命令模式 (Command Pattern)</h4><blockquote><p><strong>简介：</strong>命令模式是一种行为型设计模式，它将请求封装成一个对象，以便可以对请求的参数化、队列化、记录日志、撤销等操作，从而使系统更加灵活。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 命令接口</span><span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>  <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体命令类：打开电视</span><span class="token keyword">class</span> <span class="token class-name">TVOnCommand</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv <span class="token operator">=</span> tv<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">turnOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体命令类：关闭电视</span><span class="token keyword">class</span> <span class="token class-name">TVOffCommand</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv <span class="token operator">=</span> tv<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">turnOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接收者：电视</span><span class="token keyword">class</span> <span class="token class-name">TV</span> <span class="token punctuation">{</span>  <span class="token function">turnOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TV is ON'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">turnOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TV is OFF'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 遥控器（调用者）</span><span class="token keyword">class</span> <span class="token class-name">RemoteControl</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>commands <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addCommand</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>commands<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">pressButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> command <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commands<span class="token punctuation">)</span> <span class="token punctuation">{</span>      command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">undoButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> command <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>commands<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      command<span class="token punctuation">.</span><span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> tv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> tvOnCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TVOnCommand</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> tvOffCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TVOffCommand</span><span class="token punctuation">(</span>tv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> remoteControl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RemoteControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>remoteControl<span class="token punctuation">.</span><span class="token function">addCommand</span><span class="token punctuation">(</span>tvOnCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>remoteControl<span class="token punctuation">.</span><span class="token function">addCommand</span><span class="token punctuation">(</span>tvOffCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>remoteControl<span class="token punctuation">.</span><span class="token function">pressButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 打开电视</span>remoteControl<span class="token punctuation">.</span><span class="token function">undoButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 关闭电视</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个命令接口 <code>Command</code>，它包含 <code>execute</code> 和 <code>undo</code> 方法。</li><li>具体命令类 <code>TVOnCommand</code> 和 <code>TVOffCommand</code> 分别继承自 <code>Command</code>，并封装了打开和关闭电视的操作。</li><li>接收者 <code>TV</code> 包含了实际的电视操作。</li><li>遥控器 <code>RemoteControl</code> 包含了命令列表，并提供了 <code>pressButton</code> 和 <code>undoButton</code> 方法来执行和撤销命令。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>将请求封装成对象：</strong> 命令模式将请求和其参数封装成一个对象，可以用于参数化、队列化、撤销等操作。</li><li><strong>解耦性：</strong> 客户端不需要知道命令的具体实现，从而降低了命令发送者和接收者之间的耦合度。</li><li><strong>支持撤销操作：</strong> 命令模式支持撤销操作，通过 <code>undo</code> 方法可以还原之前的操作。</li></ol></blockquote><p>​    命令模式通常在需要将请求参数化、支持撤销操作或实现命令队列等场景中使用。</p><p>​    </p><h4 id="发布-订阅模式-Publish-Subscribe-Pattern"><a href="#发布-订阅模式-Publish-Subscribe-Pattern" class="headerlink" title="发布-订阅模式 (Publish-Subscribe Pattern)"></a>发布-订阅模式 (Publish-Subscribe Pattern)</h4><blockquote><p>​    <strong>简介：</strong>发布-订阅模式是一种行为型设计模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。<br>​    </p></blockquote><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 发布者 (发布事件的对象)</span><span class="token keyword">class</span> <span class="token class-name">Publisher</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">subscribe</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">notify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> subscriber <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">)</span> <span class="token punctuation">{</span>      subscriber<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 订阅者 (订阅事件的对象)</span><span class="token keyword">class</span> <span class="token class-name">Subscriber</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">update</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> received update with data: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> publisher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Publisher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> subscriberA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subscriber</span><span class="token punctuation">(</span><span class="token string">'Subscriber A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> subscriberB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subscriber</span><span class="token punctuation">(</span><span class="token string">'Subscriber B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> subscriberC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subscriber</span><span class="token punctuation">(</span><span class="token string">'Subscriber C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subscriberA<span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subscriberB<span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subscriberC<span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">'Message 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscriberB<span class="token punctuation">)</span><span class="token punctuation">;</span>publisher<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">'Message 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个发布者 <code>Publisher</code>，它包含了一个订阅者数组 <code>subscribers</code>，并提供了订阅、取消订阅和通知的方法。</li><li>订阅者 <code>Subscriber</code> 有一个 <code>name</code> 属性，并实现了 <code>update</code> 方法来处理接收到的通知。</li><li>客户端代码创建了一个发布者对象，然后添加了三个订阅者，并发送两条通知消息。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>解耦性：</strong> 发布-订阅模式用于解耦发布者和订阅者，使它们可以独立演化。</li><li><strong>事件处理：</strong> 它常用于事件处理机制，让多个对象监听并响应事件。</li><li><strong>消息通信：</strong> 发布-订阅模式可用于消息通信，不同部分之间可以通过事件进行通信。</li></ol></blockquote><p>​    发布-订阅模式通常在需要实现松散耦合、事件驱动、多对多通信等场景中使用。</p><p>​    </p><h4 id="模块模式-Module-Pattern"><a href="#模块模式-Module-Pattern" class="headerlink" title="模块模式 (Module Pattern)"></a>模块模式 (Module Pattern)</h4><blockquote><p>​    <strong>简介：</strong>模块模式是一种设计模式，用于将代码组织成可维护和可重用的模块，同时隐藏了内部实现的细节。它通过使用闭包来创建私有变量和函数，提供了一种封装数据和行为的方法。</p></blockquote><p>​<br><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 模块</span><span class="token keyword">const</span> myModule <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 私有变量</span>  <span class="token keyword">let</span> privateVar <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 私有函数</span>  <span class="token keyword">function</span> <span class="token function">privateFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Private Function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    privateVar<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 公有接口（可以访问私有成员）</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    publicVar<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>    publicFunction<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Public Function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">privateFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    getPrivateVar<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> privateVar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 客户端代码</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myModule<span class="token punctuation">.</span>publicVar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 访问公有变量</span>myModule<span class="token punctuation">.</span><span class="token function">publicFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 调用公有函数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myModule<span class="token punctuation">.</span><span class="token function">getPrivateVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 获取私有变量</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们创建了一个匿名的立即执行函数，它返回一个包含公有接口的对象，这个对象可以访问模块内部的私有变量和函数。</li><li>模块内部定义了私有变量 <code>privateVar</code> 和私有函数 <code>privateFunction</code>，它们无法在模块外部直接访问。</li><li>公有接口包含了公有变量 <code>publicVar</code>、公有函数 <code>publicFunction</code> 和一个获取私有变量的方法 <code>getPrivateVar</code>。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>封装数据和行为：</strong> 模块模式用于将数据和行为封装在一个模块内，隐藏了内部实现的细节，提供了一个清晰的公共接口。</li><li><strong>单例模式：</strong> 模块模式可以用于创建单例对象，确保只有一个实例存在。</li><li><strong>避免全局污染：</strong> 使用模块模式可以避免将变量和函数添加到全局作用域，减少了命名冲突的可能性。</li></ol></blockquote><p>​    模块模式通常在需要封装一组相关的变量和函数，并将其隐藏在模块内部的情况下使用，以提高代码的可维护性和可复用性。</p><p>​    </p><h4 id="模板方法模式-Template-Method-Pattern"><a href="#模板方法模式-Template-Method-Pattern" class="headerlink" title="模板方法模式 (Template Method Pattern)"></a>模板方法模式 (Template Method Pattern)</h4><blockquote><p>​    <strong>简介：</strong>模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，将具体步骤的实现延迟到子类。模板方法使子类可以在不改变算法结构的情况下重新定义算法的某些步骤。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 模板类</span><span class="token keyword">class</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Game initialized.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Game ended.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体游戏类：Basketball</span><span class="token keyword">class</span> <span class="token class-name">BasketballGame</span> <span class="token keyword">extends</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>  <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Playing basketball.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体游戏类：Soccer</span><span class="token keyword">class</span> <span class="token class-name">SoccerGame</span> <span class="token keyword">extends</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>  <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Playing soccer.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> basketball <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasketballGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>basketball<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> soccer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoccerGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>soccer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个抽象的游戏类 <code>Game</code>，它包含了一个模板方法 <code>start</code>，以及初始化方法 <code>initialize</code>、游戏方法 <code>play</code> 和结束方法 <code>end</code>。</li><li><code>start</code> 方法按照固定的顺序调用了 <code>initialize</code>、<code>play</code> 和 <code>end</code> 方法，这个顺序定义了游戏的骨架。</li><li>具体游戏类 <code>BasketballGame</code> 和 <code>SoccerGame</code> 继承自 <code>Game</code> 并实现了 <code>play</code> 方法，从而定义了具体的游戏行为。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>定义算法骨架：</strong> 模板方法模式用于定义算法的骨架，将算法的步骤抽象出来，并允许子类提供具体实现。</li><li><strong>代码复用：</strong> 它提供了一种重用代码的方式，将通用部分放在模板方法中，将变化的部分留给子类。</li><li><strong>防止滥用继承：</strong> 模板方法模式避免了滥用继承，因为它允许在不改变算法结构的情况下重定义部分步骤。</li></ol></blockquote><p>​    模板方法模式通常在需要定义算法骨架、有多个子类共享一些公共行为、避免代码重复等情况下使用。</p><p>​    </p><h4 id="迭代器模式-Iterator-Pattern"><a href="#迭代器模式-Iterator-Pattern" class="headerlink" title="迭代器模式 (Iterator Pattern)"></a>迭代器模式 (Iterator Pattern)</h4><blockquote><p>​    <strong>简介：</strong>迭代器模式是一种行为型设计模式，用于提供一种顺序访问集合对象元素的方法，而不需要暴露集合的内部表示。它允许客户端访问集合对象中的元素，而不必了解底层数据结构。</p></blockquote><p>​<br><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 迭代器接口</span><span class="token keyword">class</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>collection <span class="token operator">=</span> collection<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体迭代器：数组迭代器</span><span class="token keyword">class</span> <span class="token class-name">ArrayIterator</span> <span class="token keyword">extends</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>  <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>collection<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>collection<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 集合类</span><span class="token keyword">class</span> <span class="token class-name">Collection</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">getIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> collection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Collection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>collection<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token string">'Item 1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>collection<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token string">'Item 2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>collection<span class="token punctuation">.</span><span class="token function">addItem</span><span class="token punctuation">(</span><span class="token string">'Item 3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> iterator <span class="token operator">=</span> collection<span class="token punctuation">.</span><span class="token function">getIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个迭代器接口 <code>Iterator</code>，它包含了 <code>hasNext</code> 和 <code>next</code> 方法。</li><li>具体迭代器 <code>ArrayIterator</code> 继承自 <code>Iterator</code>，实现了针对数组的迭代逻辑。</li><li>集合类 <code>Collection</code> 包含一个数组 <code>items</code> 和一个获取迭代器的方法 <code>getIterator</code>。</li><li>客户端代码创建了一个集合对象，添加了三个元素，然后获取了一个迭代器并使用 <code>while</code> 循环遍历元素。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>封装集合遍历逻辑：</strong> 迭代器模式封装了集合遍历的逻辑，使客户端代码不必了解底层数据结构。</li><li><strong>支持多种集合类型：</strong> 它可以为不同类型的集合提供通用的遍历方式，无需修改客户端代码。</li><li><strong>提供一致的接口：</strong> 迭代器模式为不同集合提供了一致的接口，简化了客户端代码。</li></ol></blockquote><p>​    迭代器模式通常在需要遍历集合对象、隐藏集合的内部结构、支持不同类型的集合等场景中使用。</p><p>​    </p><h4 id="责任链模式-Chain-of-Responsibility-Pattern"><a href="#责任链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="责任链模式 (Chain of Responsibility Pattern)"></a>责任链模式 (Chain of Responsibility Pattern)</h4><blockquote><p> <strong>简介：</strong>责任链模式是一种行为型设计模式，用于构建一个对象链，每个对象都有机会处理请求，但请求会在链上传递直到有一个对象处理它为止。责任链模式将请求发送者与接收者解耦，允许多个对象都有机会处理请求。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 处理请求的抽象处理者</span><span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">setSuccessor</span><span class="token punctuation">(</span>successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">=</span> successor<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体处理者 A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerA</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>  <span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>request <span class="token operator">===</span> <span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Handler A is handling the request.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>successor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体处理者 B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerB</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>  <span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>request <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Handler B is handling the request.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>successor <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>successor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> handlerA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> handlerB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>handlerA<span class="token punctuation">.</span><span class="token function">setSuccessor</span><span class="token punctuation">(</span>handlerB<span class="token punctuation">)</span><span class="token punctuation">;</span>handlerA<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Handler A is handling the request.</span>handlerA<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Handler B is handling the request.</span>handlerA<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (No handler can handle the request.)</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个抽象的处理者类 <code>Handler</code>，它包含一个指向下一个处理者的引用 <code>successor</code> 和一个 <code>handleRequest</code> 方法。</li><li>具体处理者类 <code>ConcreteHandlerA</code> 和 <code>ConcreteHandlerB</code> 继承自 <code>Handler</code>，并实现了自己的 <code>handleRequest</code> 方法来处理请求。</li><li>客户端代码创建了两个具体处理者对象，然后通过 <code>setSuccessor</code> 方法设置它们的处理顺序，最后调用第一个处理者的 <code>handleRequest</code> 方法来处理请求。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong> </p><ol><li><strong>解耦发送者和接收者：</strong> 责任链模式将请求的发送者和接收者解耦，允许多个对象都有机会处理请求，从而降低了它们之间的依赖关系。</li><li><strong>动态构建责任链：</strong> 可以动态地添加、删除或修改处理者，以满足不同的请求处理需求。</li><li><strong>避免硬编码逻辑：</strong> 责任链模式可以避免硬编码请求的处理逻辑，使代码更加灵活和可维护。</li></ol></blockquote><p>​    责任链模式通常在需要动态决定请求的处理顺序、多个对象有机会处理请求、避免请求发送者和接收者之间紧密耦合的情况下使用。</p><p>​    </p><h4 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式 (State Pattern)"></a>状态模式 (State Pattern)</h4><blockquote><p>​    <strong>简介：</strong>状态模式是一种行为型设计模式，它允许对象在内部状态发生改变时改变它的行为。这种模式将状态封装成独立的类，并将上下文对象委托给当前状态对象，以便在状态发生变化时切换到不同的状态。</p></blockquote><p>​    </p><p><strong>示例代码：</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 状态接口</span><span class="token keyword">class</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>  <span class="token function">handle</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体状态类：开机状态</span><span class="token keyword">class</span> <span class="token class-name">PowerOnState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>  <span class="token function">handle</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TV is ON'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PowerOffState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 具体状态类：关机状态</span><span class="token keyword">class</span> <span class="token class-name">PowerOffState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>  <span class="token function">handle</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'TV is OFF'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PowerOnState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 上下文类</span><span class="token keyword">class</span> <span class="token class-name">TVContext</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PowerOffState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">setState</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 客户端代码</span><span class="token keyword">const</span> tv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TVContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tv<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TV is OFF</span>tv<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TV is ON</span>tv<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TV is OFF</span></code></pre><p>​    </p><blockquote><p><strong>代码解读：</strong></p><ul><li>我们首先定义了一个状态接口 <code>State</code>，它包含一个 <code>handle</code> 方法。</li><li>具体状态类 <code>PowerOnState</code> 和 <code>PowerOffState</code> 继承自 <code>State</code>，并分别实现了 <code>handle</code> 方法来处理开机和关机状态。</li><li>上下文类 <code>TVContext</code> 包含一个当前状态对象，并提供了 <code>setState</code> 和 <code>request</code> 方法。<code>setState</code> 方法用于切换当前状态，而 <code>request</code> 方法用于发出请求，委托给当前状态来处理。</li></ul></blockquote><p>​    </p><blockquote><p><strong>用途：</strong></p><ol><li><strong>封装状态：</strong> 状态模式将每个状态封装成一个独立的类，使状态的变化对上下文对象透明，提高了代码的可维护性。</li><li><strong>减少条件语句：</strong> 它避免了大量的条件语句，使代码更加清晰和可读。</li><li><strong>支持扩展性：</strong> 可以轻松地添加新的状态类，扩展系统的行为。</li></ol></blockquote><p>​    状态模式通常在需要对象在不同状态下执行不同操作的场景中使用，它有助于将状态转换和状态处理的逻辑封装起来，提高了代码的可扩展性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js设计与实现</title>
      <link href="/2023/06/12/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/06/12/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue的设计模式"><a href="#Vue的设计模式" class="headerlink" title="Vue的设计模式"></a>Vue的设计模式</h3><h4 id="MVC-和-MVVM-区别"><a href="#MVC-和-MVVM-区别" class="headerlink" title="MVC 和 MVVM 区别"></a>MVC 和 MVVM 区别</h4><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范</p><ul><li>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li><li>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</li><li>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据</li></ul><p>MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。</p><h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><p>MVVM 新增了 VM 类</p><blockquote><p>ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</p></blockquote><p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</p><p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p><blockquote><p>注意：Vue 并没有完全遵循 MVVM 的思想 这一点官网自己也有说明。严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</p></blockquote><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/../images/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/vue-life.jpg" alt="Vue生命周期"></p><blockquote><p><strong>beforeCreate</strong> 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问</p><p><strong>created</strong> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom</p><p><strong>beforeMount</strong> 在挂载开始之前被调用：相关的 render 函数首次被调用。</p><p><strong>mounted</strong> 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点</p><p><strong>beforeUpdate</strong> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p><p><strong>updated</strong> 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。</p><p><strong>beforeDestroy</strong> 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。</p><p><strong>destroyed</strong> Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p><p><strong>activated</strong> keep-alive 专属，组件被激活时调用</p><p><strong>deactivated</strong> keep-alive 专属，组件被销毁时调用</p></blockquote><h4 id="keep-alive-中的生命周期有哪些"><a href="#keep-alive-中的生命周期有哪些" class="headerlink" title="keep-alive 中的生命周期有哪些"></a>keep-alive 中的生命周期有哪些</h4><blockquote><p>​    keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存，在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。 如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。</p><p>​    同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。 当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期； 当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。</p></blockquote><h4 id="异步请求在哪一步发起？"><a href="#异步请求在哪一步发起？" class="headerlink" title="异步请求在哪一步发起？"></a>异步请求在哪一步发起？</h4><blockquote><p>可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p><p>如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面  loading 时间；</li><li>ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul></blockquote><h4 id="Vue-的父子组件生命周期钩子函数执行顺序"><a href="#Vue-的父子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父子组件生命周期钩子函数执行顺序"></a>Vue 的父子组件生命周期钩子函数执行顺序</h4><blockquote><p><strong>加载渲染过程:</strong></p><p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p><p><strong>子组件更新过程:</strong></p><p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p><p><strong>父组件更新过程:</strong></p><p>父 beforeUpdate-&gt;父 updated</p><p><strong>销毁过程:</strong></p><p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p></blockquote><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><h4 id="组件中为什么-data-是一个函数？"><a href="#组件中为什么-data-是一个函数？" class="headerlink" title="组件中为什么 data 是一个函数？"></a>组件中为什么 <code>data</code> 是一个函数？</h4><blockquote><p>在 Vue 组件中，为什么 <code>data</code> 是一个函数而不是一个对象的原因是为了确保每个组件实例都有其自己的数据副本。当组件被定义时，<code>data</code> 必须是一个函数。每次创建组件实例时，Vue 都会调用该函数来返回一个全新的数据对象。</p><p>这是因为 Vue 组件可以在应用中存在多个实例，每个实例都应该具有独立的状态和数据。如果 <code>data</code> 是一个对象，那么所有组件实例将共享相同的数据对象，这将导致一个实例的数据变化会影响到其他实例。</p><p>通过将 <code>data</code> 定义为函数，Vue 在创建组件实例时会为每个实例调用该函数，从而返回一个新的数据对象。这样，每个组件实例都有自己的数据副本，它们之间相互独立，可以独立地修改和维护各自的状态。</p></blockquote><h4 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h4><p>v-model 其实就是语法糖，v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><blockquote><p>text 和 textarea 元素使用 value property 和 input 事件；</p><p>checkbox 和 radio 使用 checked property 和 change 事件；</p><p>select 字段将 value 作为 prop 并将 change 作为事件。</p></blockquote><p>在普通标签上:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  //这一行等于下一行<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth <span class="token punctuation">=</span> $event.target.value<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>在组件上:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>currency-input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>price<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>currentcy-input</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--上行代码是下行的语法糖 &lt;currency-input :value="price" @input="price = arguments[0]">&lt;/currency-input>--></span><span class="token comment" spellcheck="true">&lt;!-- 子组件定义 --></span>Vue.component('currency-input', { template: `  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>    <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>input<span class="token punctuation">"</span></span>    <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span>    <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>input<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>   <span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> `, props: ['value'],})</code></pre><h4 id="Vue数据双向绑定原理"><a href="#Vue数据双向绑定原理" class="headerlink" title="Vue数据双向绑定原理"></a>Vue数据双向绑定原理</h4><h5 id="vue的响应式基本原理："><a href="#vue的响应式基本原理：" class="headerlink" title="vue的响应式基本原理："></a>vue的响应式基本原理：</h5><blockquote><p>1、vue会遍历此data中对象所有的属性，</p><p>2、并使用Object.defineProperty进行数据劫持，把这些属性全部转为getter/setter，</p><p>3、而每个组件实例都有watcher对象，</p><p>4、它会在组件渲染的过程中把属性记录为依赖，</p><p>5、之后当依赖项的 setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p></blockquote><p>eg：</p><p>Object.defineProperty( ):</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    name <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"My name is "</span> <span class="token operator">+</span> name  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span> person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jayhodon'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// My name is Jayhodon</span></code></pre><h5 id="vue的响应式原理设计三个重要对象："><a href="#vue的响应式原理设计三个重要对象：" class="headerlink" title="vue的响应式原理设计三个重要对象："></a>vue的响应式原理设计三个重要对象：</h5><blockquote><p>Observer对象：vue中的数据对象在初始化过程中转换为Observer对象。</p><p>Watcher对象：将模板和Observer对象结合在一起生成Watcher实例，Watcher是订阅者中的订阅者。</p><p>Dep对象：Watcher对象和Observer对象之间纽带，每一个Observer都有一个Dep实例，用来存储订阅者Watcher。</p></blockquote><p>当属性变化会执行主题对象Observer的dep.notify方法， 这个方法会遍历订阅者Watcher列表向其发送消息， Watcher会执行run方法去更新视图。模板编译过程中的指令和数据绑定都会生成Watcher实例，实例中的watch属性也会生成Watcher实例。</p><p>总的来说就是：</p><blockquote><p>1、在生命周期的initState方法中将data，prop，method，computed，watch中的数据劫持， 通过observe方法与Object.defineProperty方法将相关对象转为换Observer对象。</p><p>2、然后在initRender方法中解析模板，通过Watcher对象，Dep对象与观察者模式将模板中的 指令与对象的数据建立依赖关系，使用全局对象Dep.target实现依赖收集。</p><p>3、当数据变化时，setter被调用，触发Object.defineProperty方法中的dep.notify方法， 遍历该数据依赖列表，执行器update方法通知Watcher进行视图更新。</p></blockquote><h5 id="使用Object-defineProperty实现监听变量"><a href="#使用Object-defineProperty实现监听变量" class="headerlink" title="使用Object.defineProperty实现监听变量:"></a>使用Object.defineProperty实现监听变量:</h5><p>实现步骤：</p><p>Observer：</p><p> 用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Observer<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    walk<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            self<span class="token punctuation">.</span><span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    defineReactive<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> childObj <span class="token operator">=</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 递归遍历所有子属性</span>        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>            enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> getter <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断是否需要添加订阅者，并添加订阅者</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> val<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> setter <span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>                dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果数据发生了变化，则通知所有的订阅者</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>value <span class="token operator">||</span> <span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数</span><span class="token keyword">function</span> Dep <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Dep<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    addSub<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    notify<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code></pre><p>Watcher：</p><p> 可以收到属性的变化通知并执行相应的函数，从而更新视图。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> exp<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>exp <span class="token operator">=</span> exp<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将自己添加到订阅器的操作</span><span class="token punctuation">}</span>Watcher<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    update<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    run<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>exp<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> oldVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!==</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>cb<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 缓存自己</span>        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>exp<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">// 强制执行监听器里的get函数</span>        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 释放自己</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这时只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> SelfVue <span class="token punctuation">(</span>data<span class="token punctuation">,</span> el<span class="token punctuation">,</span> exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>exp<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化模板数据的值</span>    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> exp<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>完整版参考自：<a href="https://www.cnblogs.com/libin-1/p/6893712.html">vue的双向绑定原理及实现</a>    <a href="https://github.com/canfoo/self-vue/tree/master/v3">源 码</a></p><h5 id="使用ES6的proxy简单实现监听变量"><a href="#使用ES6的proxy简单实现监听变量" class="headerlink" title="使用ES6的proxy简单实现监听变量:"></a>使用ES6的proxy简单实现监听变量:</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> msg<span class="token punctuation">:</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//懒监听，去获取的时候才监听对象里面的对象，而不是直接递归循环监听</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//数组新增会执行两次，一次是修改length，一次是添加值</span>  <span class="token keyword">let</span> oldValue <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>oldValue<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//找不到老值，新增</span>  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>oldValue <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//老值和新值不相等，修改</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>proxy<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span></code></pre><p>区别：</p><blockquote><p>1、语法层面上</p><p>defineProperty只能响应首次渲染时候的属性，</p><p>defineProperty无法一次性监听所有属性，必须通过遍历或者递归的方式来实现且无法监听新增的属性，对于数组defineProperty则需要劫持数组方法。</p><p>Proxy需要的是整体监听，不需要关心里面有什么属性，而且Proxy的配置项有13种，可以做更细致的事情，这是之前的defineProperty无法达到的。</p><p>2、兼容层面上</p><p>vue2.x之所以只能兼容到IE8就是因为defineProperty无法兼容IE8,其他浏览器也会存在轻微兼容问题。</p><p>proxy的话除了IE，其他浏览器都兼容，这次vue3还是使用了它，说明vue3直接放弃了IE的兼容考虑。</p></blockquote><p> 为什么Vue 3 使用 Proxy 替代了 Vue 2 中的 Object.defineProperty：</p><blockquote><ol><li>更好的性能：Vue 3 使用 Proxy 可以提供比 Object.defineProperty 更高的性能。Proxy 可以拦截更多的操作，包括属性访问、属性设置、删除属性等，而 Object.defineProperty 只能拦截属性的读取和设置。</li><li>更好的扩展性：Proxy 提供了更多的拦截方法，可以针对更多的操作进行定制。这使得 Vue 3 在响应式系统的实现上更加灵活和可扩展。</li><li>更好的支持嵌套对象：Proxy 对于嵌套对象的响应式支持更加完善。Vue 3 的响应式系统可以追踪到嵌套对象的变化，并在需要时触发更新。</li><li>更好的 TypeScript 支持：Proxy 的类型推断更准确，可以提供更好的 TypeScript 支持，让开发者在编码过程中能够获得更准确的类型提示和错误检查。</li></ol></blockquote><p>​    总体来说，Vue 3 使用 Proxy 替代了 Vue 2 中的 Object.defineProperty，主要是为了提供更好的性能、更好的扩展性、更好的嵌套对象支持和更好的 TypeScript 支持。这些改进使得 Vue 3 在响应式系统的实现上更加先进和灵活，提供了更好的开发体验和性能优化。</p><h4 id="Vue-中的数据为什么频繁变化时只会更新一次-？"><a href="#Vue-中的数据为什么频繁变化时只会更新一次-？" class="headerlink" title="Vue 中的数据为什么频繁变化时只会更新一次 ？"></a>Vue 中的数据为什么频繁变化时只会更新一次 ？</h4><p>​    在 Vue 中，当数据频繁变化时，Vue 会对数据变化进行优化处理，以减少不必要的更新操作，从而提高性能。    </p><blockquote><p>Vue 使用了异步更新队列的机制，即将数据变化的通知放入队列中，然后在下一个事件循环周期中统一进行更新操作。这样做的好处是，当数据频繁变化时，不会立即触发更新，而是等待下一个事件循环周期进行批量更新，从而避免了频繁的更新操作。</p><p>具体来说，当多次修改数据时，Vue 会将这些修改操作合并为一个更新操作。例如，连续对同一个数据进行多次修改，只会触发一次更新操作，以最终的修改结果为准。</p><p>这种优化机制可以有效减少不必要的 DOM 操作和重新渲染，提升性能和效率。同时，也避免了频繁的更新导致的性能问题和不必要的资源消耗。</p></blockquote><p>​    然而，需要注意的是，由于异步更新机制，Vue 在某些特定场景下可能无法立即获取到最新的数据。如果需要在数据更新后立即执行某些操作，可以利用 Vue 提供的 <code>$nextTick</code> 方法或使用 Vue 的生命周期钩子函数来确保在更新完成后执行相应的操作。</p><p>​    总之，Vue 的更新机制保证了数据变化的高效处理，并通过合并操作减少了不必要的更新，提升了应用的性能和响应速度。</p><p>​    </p><h5 id="this-nextTick-作用及实现原理"><a href="#this-nextTick-作用及实现原理" class="headerlink" title="this.$nextTick() 作用及实现原理"></a>this.$nextTick() 作用及实现原理</h5><p>​    <code>this.$nextTick()</code> 是 Vue 实例提供的一个方法，用于在 DOM 更新完成后执行回调函数。它的作用是确保在下次 DOM 更新循环结束后执行回调函数，以获取到最新的 DOM 状态。</p><blockquote><p>实现原理：</p><ol><li>当调用 <code>this.$nextTick()</code> 方法时，Vue 会将传入的回调函数添加到一个队列中，该队列用于存储待执行的回调函数。</li><li>Vue 会检测当前是否存在微任务（Promise 或 MutationObserver）或宏任务（setTimeout 或 setImmediate）队列。</li><li>如果存在微任务或宏任务队列，则将回调函数添加到微任务或宏任务队列中，确保在下一个事件循环周期中执行。</li><li>如果当前不存在微任务或宏任务队列，则创建一个微任务队列，并将回调函数添加到其中。</li><li>在下一个事件循环周期中，Vue 会执行微任务队列中的所有回调函数，并将其从队列中移除。</li></ol></blockquote><p>​    通过这种机制，<code>this.$nextTick()</code> 方法可以保证在 DOM 更新完成后执行回调函数，以便获取到最新的 DOM 状态。这在某些场景下非常有用，比如在修改数据后立即获取更新后的 DOM 元素，或在更新后对某些 DOM 操作进行后续处理。</p><p>​    需要注意的是，由于 <code>this.$nextTick()</code> 方法使用了异步更新机制，因此回调函数的执行时机不是立即的，而是在下一个事件循环周期中。如果需要在回调函数执行完成后执行一些操作，可以在回调函数中进行处理，或者使用 <code>Promise</code> 或 <code>async/await</code> 来等待回调函数执行完成。</p><h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><h4 id="Vue-组件通讯有哪几种方式"><a href="#Vue-组件通讯有哪几种方式" class="headerlink" title="Vue 组件通讯有哪几种方式"></a>Vue 组件通讯有哪几种方式</h4><blockquote><ol><li><p>props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的</p></li><li><p>$parent,$children 获取当前组件的父组件和当前组件的子组件</p></li><li><p>父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用，用于跨级通讯)</p></li><li><p>$refs 获取组件实例</p></li><li><p>envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式</p></li><li><p>vuex 状态管理</p></li></ol></blockquote><p><strong>props &amp; $emit:</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>Son @changeData<span class="token operator">=</span><span class="token string">"changeData"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span> <span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'@/components/son'</span> <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>   name<span class="token punctuation">:</span><span class="token string">'Father'</span><span class="token punctuation">,</span>   components<span class="token punctuation">:</span><span class="token punctuation">{</span>Son<span class="token punctuation">}</span><span class="token punctuation">,</span>   methods<span class="token punctuation">:</span><span class="token punctuation">{</span>     <span class="token function">changeData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//来自子组件的数据</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>el<span class="token operator">-</span>button @click<span class="token operator">=</span><span class="token string">"handleEmit"</span><span class="token operator">></span>通知父组件需要更改数据了<span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span> <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>   name<span class="token punctuation">:</span><span class="token string">'Son'</span><span class="token punctuation">,</span>   methods<span class="token punctuation">:</span><span class="token punctuation">{</span>     <span class="token function">handleEmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'changeData'</span><span class="token punctuation">,</span><span class="token string">'这是来自子组件的数据'</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>$parent &amp; $children：</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>子组件<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span><span class="token string">"Son"</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>      sonData<span class="token punctuation">:</span> <span class="token string">'子组件的数据'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">sonHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'子组件的方法'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>fatherData<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//父组件的数据</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span><span class="token function">fantherHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//父组件的方法</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>Son<span class="token operator">></span>父组件<span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'./son.vue'</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'father'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    Son  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>      fatherData<span class="token punctuation">:</span> <span class="token string">'父组件的数据'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">fantherHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'父组件的方法'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sonTitle<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//子组件的数据</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sonHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//子组件的方法</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>这里要注意父组件要在mounted（）这个生命周期对子组件进行取值因为在这时候子组件才完成了 created 与 mounted，并且获取到的数据是一个数组的形式。</p><p><strong>provide $ inject：</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*父组件*/</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span> provide<span class="token punctuation">:</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span><span class="token punctuation">{</span>     provideData<span class="token punctuation">:</span> <span class="token string">'父组件的数据'</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*子组件*/</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  inject<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'provideData'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  created <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>provideName<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//"父组件的数据"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>$refs：</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>Son ref<span class="token operator">=</span><span class="token string">"son"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'./son.vue'</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'father'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    Son  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>son<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*组件实例*/</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>envetBus：</strong></p><p>需要先创建一个公共的eventBus.js，并将Vue实例暴露出去</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p> 在需要组件通信的组件A中引入eventBus.js，并通过$emit发布回调事件</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>组件A<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>el<span class="token operator">-</span>button @click<span class="token operator">=</span><span class="token string">"changeData"</span><span class="token operator">></span>修改数据A<span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>button<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../bus.js"</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">changeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"editData"</span><span class="token punctuation">,</span> <span class="token string">'这是修改后的数据'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>组件B中同样引入eventBus.js文件，并通过$on监听事件回调</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>组件B<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../bus.js"</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  mounted<span class="token punctuation">:</span><span class="token punctuation">{</span>    EventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'editData'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><h4 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h4><p>在 Vue 中，父子组件之间可以通过 props 和事件来进行通信。</p><ol><li><p>父组件向子组件传递数据：通过在父组件中使用 props 将数据传递给子组件。子组件可以在其模板中通过使用 props 来接收父组件传递的数据。</p><p>父组件：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>ChildComponent <span class="token punctuation">:</span>message<span class="token operator">=</span><span class="token string">"parentMessage"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">'./ChildComponent.vue'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      parentMessage<span class="token punctuation">:</span> <span class="token string">'Hello from parent'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>    ChildComponent<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>子组件：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre></li><li><p>子组件通过触发事件改变父组件的值：子组件可以通过 $emit 方法触发自定义事件，从而通知父组件进行相应的操作。</p><p>父组件：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>ChildComponent <span class="token punctuation">:</span>counter<span class="token operator">=</span><span class="token string">"counter"</span> @increment<span class="token operator">=</span><span class="token string">"handleIncrement"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>Counter<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> counter <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">'./ChildComponent.vue'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      counter<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>    ChildComponent<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">handleIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>子组件：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"handleClick"</span><span class="token operator">></span>Increment<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'counter'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre></li></ol><p>​    通过上述方式，父子组件可以进行数据的传递和通信。子组件可以通过触发事件的方式来改变父组件的值。需要注意的是，子组件不能直接修改父组件的 props 数据，而是通过事件向父组件发送请求，由父组件进行相应的操作来修改数据。</p><p>​    如果子组件需要修改父组件的数据，父组件可以将需要修改的数据作为 props 传递给子组件，然后子组件通过触发事件来请求父组件进行数据的修改。这样可以保持数据流的单向性，提高组件的可维护性和可预测性。</p><h4 id="平行组件通信"><a href="#平行组件通信" class="headerlink" title="平行组件通信"></a>平行组件通信</h4><p>在 Vue 中，平行组件之间的通信可以通过以下几种方式实现：</p><blockquote><ol><li>使用共享状态（Shared State）：可以创建一个共享的数据源，例如 Vuex 状态管理库或者一个全局的事件总线。所有的平行组件都可以访问和修改这个共享的状态，从而实现通信。</li><li>使用父组件作为中介：如果平行组件位于同一个父组件下，可以通过父组件作为中介来进行通信。平行组件通过将需要共享的数据或者方法传递给父组件，再由父组件将数据或者方法传递给其他平行组件。</li><li>使用事件总线：可以创建一个全局的事件总线，利用 Vue 的实例作为事件中心，平行组件通过订阅和触发事件来进行通信。</li><li>使用浏览器的事件系统：平行组件可以通过浏览器的事件系统（如 <code>window.dispatchEvent</code> 和 <code>window.addEventListener</code>）来进行通信。组件可以通过触发自定义事件，然后在其他组件中通过监听这些事件来实现通信。</li><li>使用非父子组件通信插件：可以使用一些 Vue 的插件来实现非父子组件之间的通信，例如 Vue Bus、mitt 等。</li></ol></blockquote><p>​    需要根据具体的场景和需求选择合适的通信方式。在选择通信方式时，可以考虑组件之间的关系、数据的复杂度以及通信的频率等因素。</p><h3 id="状态管理-Vuex"><a href="#状态管理-Vuex" class="headerlink" title="状态管理 - Vuex"></a>状态管理 - Vuex</h3><p>​    Vuex是Vue.js官方提供的状态管理模式和库。它被设计用于解决Vue应用中的状态管理问题。Vuex基于Flux架构和Redux模式，提供了一种集中管理和共享状态的机制。</p><p>Vuex的核心概念包括：</p><blockquote><ol><li>State（状态）：用于存储应用的状态数据，类似于组件中的data。它是响应式的，可以通过getter获取和修改。</li><li>Mutation（变更）：用于修改状态的方法，类似于组件中的methods。只能进行同步操作，且只能在mutation中修改状态。</li><li>Action（动作）：用于处理异步操作或复杂的业务逻辑，可以包含多个mutation的组合。可以触发mutation来修改状态。</li><li>Getter（获取器）：用于派生状态，类似于组件中的computed。可以对状态进行计算和包装，提供派生的数据。</li><li>Module（模块）：将大型应用的状态拆分为多个模块，每个模块有自己的state、mutation、action和getter。</li></ol></blockquote><p>​    通过使用Vuex，我们可以集中管理和共享应用的状态，使得状态的变化和处理逻辑更可控和可维护。它适用于大型的、状态复杂的应用，可以简化组件之间的通信，提高代码的可读性和可测试性。同时，Vuex也提供了开发工具和插件，方便调试和扩展。</p><p>​    在Vue应用中使用Vuex需要先安装和配置，然后在组件中引入和使用。通过定义state、mutations、actions和getters，我们可以在组件中访问和修改共享状态。Vuex还提供了一些辅助函数和工具，用于简化使用和处理异步操作。</p><h4 id="mutations-能不能做异步"><a href="#mutations-能不能做异步" class="headerlink" title="mutations 能不能做异步"></a>mutations 能不能做异步</h4><p>​    在Vuex中，mutations默认是同步操作，只能用于修改状态的同步变更。这是为了确保状态的变更是可追踪和可预测的。</p><p>​    在某些情况下，我们可能需要在mutations中进行异步操作，比如在异步请求数据后再修改状态。然而，直接在mutations中执行异步操作是不被推荐的做法，因为它会破坏状态变更的可追踪性。</p><p>​    如果需要进行异步操作，可以使用actions来处理。Actions可以包含异步操作，并且可以触发mutations来修改状态。这样可以保持状态变更的可追踪性，同时也可以方便地进行异步处理。</p><p>示例代码：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Vuex store</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>    count<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">increment</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">decrement</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      state<span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">asyncIncrement</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在组件中使用</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'decrement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">asyncIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'asyncIncrement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>​    在上述示例中，通过<code>context.commit</code>来触发mutation的执行，<code>this.$store.dispatch</code>来触发action的执行。这样就可以实现异步操作并且保持状态变更的可追踪性。</p><p>​    虽然mutations默认是同步操作，但可以通过actions来处理异步操作，并在actions中触发mutations来修改状态。这样可以更好地控制和管理状态的变更过程。</p><h4 id="Vuex-页面刷新数据丢失怎么解决"><a href="#Vuex-页面刷新数据丢失怎么解决" class="headerlink" title="Vuex 页面刷新数据丢失怎么解决"></a>Vuex 页面刷新数据丢失怎么解决</h4><p>​    当刷新页面时，由于Vuex中的数据存储在内存中，数据会丢失。这是因为Vuex是基于客户端的状态管理库，数据不会被持久化保存。每次刷新页面都会重新初始化Vuex的状态。</p><p>​    为了解决刷新页面导致Vuex数据丢失的问题，可以考虑以下几种方法：</p><blockquote><ol><li>使用持久化方案：可以将Vuex的状态持久化保存到本地存储（如localStorage或sessionStorage）中。在应用初始化时，从本地存储中读取状态并还原到Vuex中。这样可以在刷新页面后重新加载保存的状态，避免数据丢失。</li><li>利用路由参数或URL查询参数传递数据：将需要持久化的数据通过路由参数或URL查询参数传递给其他页面。这样在刷新页面时，可以通过获取路由参数或URL查询参数来恢复数据。</li><li>使用后端存储方案：如果应用需要长期保存状态数据，并且在不同设备或浏览器中共享状态，可以考虑将状态数据存储在后端服务器或数据库中。在刷新页面时，可以通过请求后端获取保存的状态数据并还原到Vuex中。</li></ol></blockquote><p>​    vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件。推荐使用 <code>vuex-persist</code> 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中</p><blockquote><p>​    ps: 需要根据具体的应用场景和需求选择适合的方法。持久化方案和后端存储方案可能需要进行数据序列化和反序列化操作，以确保数据的正确保存和恢复。同时，需要注意数据的安全性和隐私保护，避免敏感数据泄露。</p></blockquote><h4 id="Vuex-和-localStorage-的区别"><a href="#Vuex-和-localStorage-的区别" class="headerlink" title="Vuex 和 localStorage 的区别"></a>Vuex 和 localStorage 的区别</h4><p>Vuex和localStorage是两种不同的概念和用途：</p><blockquote><ol><li>Vuex：Vuex是Vue.js官方提供的状态管理库。它用于在Vue应用中集中管理和共享状态。Vuex的目的是解决组件之间共享数据、状态管理和数据流的问题。Vuex提供了一种集中式的数据存储机制，可以在多个组件中访问和修改共享的状态，以实现组件之间的通信和数据同步。Vuex的数据存储在内存中，它是基于内存的状态管理解决方案，适用于应用内部的数据共享和状态管理。</li><li>localStorage：localStorage是Web浏览器提供的一种本地存储机制。它允许将数据以键值对的形式存储在浏览器的本地存储空间中，并且数据在页面刷新或关闭后仍然保持有效。localStorage提供了持久化的存储能力，可以在不同的页面和会话中共享数据。localStorage中的数据以字符串形式存储，需要进行数据的序列化和反序列化。</li></ol></blockquote><p>区别：</p><blockquote><ul><li>Vuex是专门为Vue应用设计的状态管理库，用于管理应用内的状态和数据流，解决组件之间的数据共享和状态管理问题。而localStorage是Web浏览器提供的一种本地存储机制，用于持久化地存储数据，并且在不同的浏览器会话中共享数据。</li><li>Vuex的数据存储在内存中，适用于应用内部的数据共享和状态管理，而localStorage的数据存储在浏览器的本地存储空间中，可以在不同的页面和会话中共享数据。</li><li>Vuex提供了一套API和机制用于管理和修改状态，包括使用mutation修改状态、使用action处理异步操作等。而localStorage是基于键值对的简单存储机制，只能通过setItem和getItem等方法进行基本的数据存储和读取，没有提供数据管理和状态变更的机制。</li></ul></blockquote><p>​    Vuex适用于Vue应用内部的状态管理和数据共享，而localStorage适用于持久化地存储和共享数据。在具体使用时，可以根据应用需求选择合适的方案或结合两者使用。</p><h3 id="虚拟-dom-和-diff-算法"><a href="#虚拟-dom-和-diff-算法" class="headerlink" title="虚拟 dom 和 diff 算法"></a>虚拟 dom 和 diff 算法</h3><p>​    虚拟DOM（Virtual DOM）和差异算法（Diff Algorithm）是前端领域中常用的概念，它们在优化页面渲染性能和提升开发效率方面发挥了重要作用。</p><blockquote><p>​    虚拟DOM是一种以JavaScript对象形式表示的轻量级的内存中的DOM表示。它是对真实DOM的一种抽象和模拟，在内存中进行操作和计算，然后再将结果批量更新到真实的DOM上。虚拟DOM的目的是在保持视图和状态同步的同时，减少对真实DOM的直接操作，从而提升性能和响应速度。</p><p>​    差异算法（Diff Algorithm）是虚拟DOM的核心算法之一，用于比较两个虚拟DOM树之间的差异，并将差异应用到真实的DOM上。通过比较新旧虚拟DOM树的差异，可以准确地找出需要更新的部分，避免全量更新整个DOM树，从而减少不必要的操作和性能损耗。</p></blockquote><p>​    Diff算法的基本原理是对比新旧虚拟DOM树的节点，找出发生变化的节点，然后根据变化类型（插入、更新、移除等）对真实DOM进行相应的操作。Diff算法通常采用深度优先遍历的方式，通过递归遍历虚拟DOM树的节点，对比节点之间的差异，生成更新操作的指令。</p><p>常用的Diff算法有两种实现方式：基于递归的Diff算法和基于循环的Diff算法。</p><blockquote><p>​    基于递归的Diff算法简单直观，但在处理大型虚拟DOM树时可能存在性能问题。</p><p>​    基于循环的Diff算法采用迭代的方式，通过循环遍历虚拟DOM树的节点，以较低的时间复杂度找出差异。</p></blockquote><p>​    虚拟DOM和差异算法是前端开发中用于优化页面渲染性能的重要技术。虚拟DOM提供了一种高效的内存中的DOM表示，而差异算法则能够准确地比较两个虚拟DOM树之间的差异，最小化对真实DOM的操作，从而提高页面的性能和响应速度。</p><h4 id="什么是虚拟-dom-？有什么用？"><a href="#什么是虚拟-dom-？有什么用？" class="headerlink" title="什么是虚拟 dom ？有什么用？"></a>什么是虚拟 dom ？有什么用？</h4><p>​    虚拟DOM（Virtual DOM）是一种在内存中构建和操作的虚拟的DOM树。它是对真实DOM的一种抽象和模拟，用JavaScript对象表示整个DOM结构及其属性。</p><p>​    虚拟DOM的基本思想是将页面的状态（数据）和视图（DOM）分离，通过对虚拟DOM的操作来更新视图，而不是直接操作真实的DOM。当数据发生变化时，会通过比较新旧虚拟DOM的差异（Diff算法），找出需要更新的部分，然后将更新应用到真实DOM上，从而保持页面和数据的同步。</p><p>虚拟DOM的主要优点包括：</p><blockquote><ol><li>性能优化：通过将DOM操作集中在虚拟DOM上，减少了直接操作真实DOM的次数，从而提高了性能。虚拟DOM可以批量更新真实DOM，避免了频繁的重绘和回流。</li><li>跨平台能力：虚拟DOM可以在不同的平台上运行，例如浏览器、移动端、服务器端等。这样可以实现一次编写，多平台复用。</li><li>方便的UI组件化：虚拟DOM可以将整个页面划分为组件，每个组件都有自己的虚拟DOM。这样可以实现组件的高度复用和模块化开发。</li><li>简化复杂的UI更新逻辑：通过比较新旧虚拟DOM的差异，可以精确地找出需要更新的部分，避免全量更新整个DOM树，从而简化了复杂的UI更新逻辑。</li></ol></blockquote><p>​    虚拟DOM通过在内存中构建和操作DOM的抽象表示，提供了一种高效、跨平台、组件化的方式来管理和更新页面的视图。它是现代前端框架（如React、Vue等）中的重要概念，能够提升开发效率和页面性能。</p><h5 id="虚拟DOM的解析过程"><a href="#虚拟DOM的解析过程" class="headerlink" title="虚拟DOM的解析过程:"></a>虚拟DOM的解析过程:</h5><p>虚拟DOM的解析过程可以简单分为三个步骤：<strong>创建</strong>、<strong>更新</strong>和<strong>渲染</strong>。</p><blockquote><ol><li>创建虚拟DOM（Virtual DOM）：在应用程序初始化时，通过使用特定的语法或调用相关API创建虚拟DOM。虚拟DOM是使用JavaScript对象表示整个DOM结构及其属性，它包括节点类型、标签名、属性、子节点等信息。</li><li>更新虚拟DOM：当应用程序的状态（数据）发生变化时，需要更新虚拟DOM以反映这些变化。这个过程通常由框架或库内部的更新机制自动处理，它会根据新的数据生成新的虚拟DOM，并与旧的虚拟DOM进行比较，找出差异（Diff算法）。</li><li>渲染虚拟DOM：在更新虚拟DOM后，需要将最新的虚拟DOM渲染到真实的DOM上，以更新页面的显示。这个过程通常由框架或库提供的渲染引擎负责处理，它会根据虚拟DOM的变化，将变化部分应用到真实DOM上，从而更新页面的内容。</li></ol></blockquote><p>具体来说，虚拟DOM的解析过程如下：</p><blockquote><ol><li>创建虚拟DOM：根据应用程序的需求，通过特定的语法或调用相关API创建虚拟DOM。这可以是手动创建的，也可以是由框架或库自动生成的。</li><li>更新虚拟DOM：当应用程序的状态发生变化时，生成新的虚拟DOM，并与旧的虚拟DOM进行比较，找出差异（Diff算法）。差异通常包括节点的增、删、改、移等操作。</li><li>应用差异：将差异应用到真实DOM上，更新页面的显示。这个过程可以通过操作真实DOM进行，也可以通过一些优化技术（例如批量更新、异步渲染等）来提高性能。</li><li>渲染页面：根据最新的虚拟DOM，将其渲染到真实DOM上，更新页面的内容。这可以是整个虚拟DOM的渲染，也可以是部分虚拟DOM的渲染，具体取决于差异的范围。</li></ol></blockquote><p>​    虚拟DOM的解析过程是一个通过创建、更新和渲染虚拟DOM来实现页面更新的过程。它通过比较差异，减少了对真实DOM的频繁操作，提高了性能和用户体验。</p><h4 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h4><p>​    Diff算法是虚拟DOM更新的核心算法，它用于比较新旧虚拟DOM之间的差异，并根据差异进行最小化的DOM操作，以提高更新效率。</p><p>​    Diff算法的基本原理是通过逐层比较新旧虚拟DOM的节点，找出节点之间的差异，并记录下来。它遵循以下几个基本规则：</p><blockquote><ol><li>同层比较：Diff算法会逐层比较新旧虚拟DOM的节点，并将它们进行一一对比。如果节点类型不同，直接替换节点；如果节点类型相同但属性不同，更新节点的属性；如果节点类型和属性都相同，继续比较其子节点。</li><li>列表比较：当比较的节点是列表（数组）类型时，Diff算法会使用特定的算法进行列表比较，例如使用唯一的key来标识列表项，以避免整个列表重新渲染。</li><li>唯一标识：Diff算法会使用唯一的标识（通常是key属性）来识别节点，以便在比较过程中准确定位节点的位置，从而进行精确的差异对比和操作。</li><li>递归比较：Diff算法会递归地比较节点的子节点，以确保所有层级的差异都能被发现和处理。</li></ol></blockquote><p>​    通过以上规则，Diff算法能够在比较的过程中找出两个虚拟DOM之间的差异，并生成一个差异对象（或称为补丁），记录下需要进行的DOM操作，例如插入、删除、更新等。然后，这个差异对象可以被应用到真实的DOM上，进行最小化的DOM操作，以实现页面的更新。</p><p>​    Diff算法的优点是能够准确地识别差异，并最小化DOM操作，提高页面更新的效率。然而，它也有一些限制和性能方面的考虑，例如当比较的虚拟DOM结构非常复杂时，Diff算法的性能可能会下降，需要合理地设计虚拟DOM结构和优化更新策略来提升性能。</p><p>​    Diff算法是虚拟DOM实现高效更新的核心，它通过比较新旧虚拟DOM之间的差异，实现最小化的DOM操作，从而提高页面更新的效率。</p><h4 id="Vue-中-key-的作用"><a href="#Vue-中-key-的作用" class="headerlink" title="Vue 中 key 的作用"></a>Vue 中 key 的作用</h4><p>在Vue中，key是用于识别VNode（虚拟DOM节点）的特殊属性。它的作用主要有以下几个方面：</p><blockquote><ol><li>提供唯一标识：每个VNode都应该具有唯一的key值，用于在diff算法中准确地识别VNode节点的变化。通过key，Vue可以精确地判断哪些VNode是新增的、哪些是删除的，从而最小化DOM操作，提高页面更新的效率。</li><li>优化列表渲染：当使用v-for指令进行列表渲染时，每个列表项都应该提供一个唯一的key值。这样，Vue可以基于key的变化来确定列表项的新增、删除、移动等操作，从而避免重新渲染整个列表，提高列表渲染的性能。</li><li>维持组件状态：当使用key在动态组件或条件渲染中切换组件时，key的变化可以强制Vue销毁旧组件并创建新组件。这样做可以保持组件的状态和避免重用旧组件的状态，确保组件能够正确地更新和重新渲染。</li></ol></blockquote><p>​    需要注意的是，key的值应该是稳定且唯一的。在使用v-for渲染列表时，推荐使用具有唯一性的属性值作为key，如ID或其他唯一标识符。避免使用索引作为key，因为索引在列表发生变化时可能会导致错误的渲染结果。</p><p>​    Vue中的key属性用于唯一标识VNode，它在diff算法中起着重要的作用，能够提高页面更新的效率、优化列表渲染，并维持组件的状态。合理使用key可以确保Vue能够准确地识别和处理VNode的变化，提供更好的性能和用户体验。</p><h3 id="Vue2-与-Vue3的区别"><a href="#Vue2-与-Vue3的区别" class="headerlink" title="Vue2 与 Vue3的区别"></a>Vue2 与 Vue3的区别</h3><h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><blockquote><ul><li>Vue2：Vue2的生命周期包括beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed等钩子函数。这些钩子函数允许我们在组件的不同生命周期阶段执行特定的操作，例如在created钩子函数中进行数据初始化，在mounted钩子函数中操作DOM元素等。</li><li>Vue3：Vue3保留了大部分Vue2的生命周期钩子函数，但也引入了新的钩子函数如setup。setup钩子函数用于代替Vue2中的beforeCreate和created钩子函数，它提供了更灵活的组合式函数编程方式，可以更好地封装组件逻辑和复用代码。</li></ul></blockquote><h4 id="Diff算法："><a href="#Diff算法：" class="headerlink" title="Diff算法："></a>Diff算法：</h4><blockquote><ul><li>Vue2：Vue2使用基于虚拟DOM的Diff算法来计算需要更新的最小操作，然后将这些操作应用于真实的DOM树。Vue2的Diff算法会比较新旧虚拟DOM树的差异，然后只对差异部分进行更新，以减少不必要的DOM操作，提高性能和渲染效率。</li><li>Vue3：Vue3在Diff算法方面进行了优化。首先，Vue3使用了基于Proxy的响应式系统，通过代理对象来监听数据的变化，从而减少了对getter和setter的劫持，提升了性能。其次，Vue3引入了静态标记，即在编译阶段对模板进行静态分析，标记出静态节点，从而避免在Diff算法中对这些静态节点进行比较，进一步提高了性能和渲染效率。</li></ul></blockquote><h4 id="数据响应式原理："><a href="#数据响应式原理：" class="headerlink" title="数据响应式原理："></a>数据响应式原理：</h4><blockquote><ul><li>Vue2：Vue2使用Object.defineProperty实现数据的响应式。当数据被访问或修改时，Vue2通过劫持数据的get和set方法来追踪数据的变化。这样一来，当数据发生变化时，Vue2能够检测到变化并通知相关的组件进行更新。</li><li>Vue3：Vue3使用Proxy对象实现数据的响应式。Proxy对象可以代理目标对象并拦截对目标对象的访问和修改操作。通过代理对象的监听和触发机制，Vue3能够实时地追踪数据的变化，并触发相应的更新操作，从而实现数据响应式。</li></ul></blockquote><h4 id="组件通讯："><a href="#组件通讯：" class="headerlink" title="组件通讯："></a>组件通讯：</h4><blockquote><ul><li>Vue2：Vue2中组件通讯主要通过props和$emit进行父子组件之间的通讯。父组件通过props将数据传递给子组件，子组件通过$emit触发自定义事件来通知父组件。此外，Vue2还提供了事件总线、Vuex等方式来实现非父子组件之间的通讯。</li><li>Vue3：Vue3保留了Vue2的组件通讯方式，即父子组件之间通过props和emit进行通讯。而与Vue2不同的是，Vue3引入了Composition API，提供了更灵活的组合式函数编程方式来处理组件之间的通讯。通过使用Composition API中的响应式函数、上下文传递等特性，我们可以更方便地在组件之间共享状态和方法。</li></ul></blockquote><h4 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h4><p>​    Composition API 是 Vue 3 中引入的一种新的 API 风格，用于编写组件的逻辑和复用代码。它是一种基于函数的 API，与 Vue 2 中的选项式 API（Options API）相比，Composition API 更加灵活、组合性更强，能够更好地组织和管理组件的代码。</p><p>​    使用 Composition API，我们可以将一个组件的相关逻辑聚合在一起，而不是按照选项的顺序分散在不同的生命周期钩子函数中。这使得组件的逻辑更加清晰、可读性更高，同时也方便代码的复用和测试。</p><p>​    Composition API 提供了一系列的函数和响应式的 API，例如 <code>setup</code> 函数、<code>ref</code>、<code>reactive</code>、<code>watch</code> 等，用于定义组件的状态和行为。下面是 Composition API 的一些特点和用法：</p><blockquote><ol><li><code>setup</code> 函数：在组件中使用 <code>setup</code> 函数来定义组件的状态和行为。<code>setup</code> 函数在组件创建之前执行，可以访问组件的 props 和 context，并返回一个对象，这个对象中的属性和方法将被暴露给组件的模板部分使用。</li><li><code>ref</code> 和 <code>reactive</code>：<code>ref</code> 和 <code>reactive</code> 是用于创建响应式数据的 API。<code>ref</code> 用于创建一个单一的响应式数据，而 <code>reactive</code> 用于创建一个包含多个属性的响应式对象。</li><li><code>watch</code>：<code>watch</code> 函数用于监听响应式数据的变化，并在数据变化时执行相应的操作。它可以监听单个数据或多个数据，还可以设置深度监听、异步监听等。</li><li>生命周期钩子函数：在 Composition API 中，生命周期钩子函数的命名发生了变化，例如 <code>beforeCreate</code> 和 <code>created</code> 改为了 <code>onBeforeMount</code> 和 <code>onMounted</code>。这些钩子函数可以在 <code>setup</code> 函数中使用，与其他逻辑代码一起组合。</li><li>自定义函数：在 Composition API 中，我们可以自定义函数来封装和复用一些逻辑代码，而不必依赖于特定的生命周期钩子函数。</li></ol></blockquote><p>​    使用 Composition API，我们能够更好地组织组件的代码，提高代码的可读性和维护性。它适用于编写中小型到大型复杂组件，并且提供了更好的代码复用和测试能力。</p><p>​    Vue3在许多其他方面也进行了改进和优化，如编译优化、TypeScript支持、组合式API等。开发者在选择Vue版本时，需要根据项目需求和实际情况综合考虑，以及考虑迁移成本和团队熟悉度等因素。</p><h3 id="路由-vue-router"><a href="#路由-vue-router" class="headerlink" title="路由 - vue-router"></a>路由 - vue-router</h3><h4 id="vue-router-中常用的路由模式实现原理吗"><a href="#vue-router-中常用的路由模式实现原理吗" class="headerlink" title="vue-router 中常用的路由模式实现原理吗"></a>vue-router 中常用的路由模式实现原理吗</h4><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a><strong>hash 模式</strong></h5><ol><li>location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li><li>可以为 hash 的改变添加监听事件</li></ol><pre class=" language-javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"hashchange"</span><span class="token punctuation">,</span> funcRef<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了</p><blockquote><p>特点：兼容性好但是不美观</p></blockquote><h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a><strong>history 模式</strong></h5><p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p><p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p><blockquote><p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p></blockquote><h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><p>路由守卫是在路由导航过程中进行拦截和控制的功能。</p><p>Vue Router 提供了以下几种类型的路由守卫：</p><blockquote><ol><li>全局前置守卫（Global Before Guards）：<ul><li><code>beforeEach(to, from, next)</code>：在每个路由跳转之前调用，可以用来进行全局的前置验证或处理逻辑。</li></ul></li><li>路由独享的守卫（Per-Route Guards）：<ul><li><code>beforeEnter(to, from, next)</code>：在某个特定路由配置中定义的守卫，只会对该路由生效。</li></ul></li><li>组件内的守卫（In-Component Guards）：<ul><li><code>beforeRouteEnter(to, from, next)</code>：在进入路由对应的组件之前调用，可以访问组件实例，但此时组件实例还没有被创建。</li><li><code>beforeRouteUpdate(to, from, next)</code>：在当前路由组件复用时调用，例如在同一路由下切换不同的参数。</li><li><code>beforeRouteLeave(to, from, next)</code>：在离开当前路由组件时调用，可以阻止离开或在离开前进行一些处理。</li></ul></li></ol></blockquote><p>这些守卫函数接收三个参数：</p><ul><li><code>to</code>：即将进入的目标路由对象</li><li><code>from</code>：当前导航正要离开的路由对象</li><li><code>next</code>：函数，用于进入下一个守卫或确认导航</li></ul><p>在守卫函数中，可以通过调用 <code>next()</code> 方法来进行导航控制：</p><ul><li>调用 <code>next()</code> 进行正常导航</li><li>调用 <code>next(false)</code> 中止当前导航</li><li>调用 <code>next(&#39;/path&#39;)</code> 或 <code>next(&#123; path: &#39;/path&#39; &#125;)</code> 进行重定向导航</li></ul><p>使用路由守卫可以实现诸如登录验证、权限控制、页面访问限制等功能，提供了灵活且强大的路由导航控制机制。 <a href="https://router.vuejs.org/guide/advanced/navigation-guards.html">Vue Router 的官方文档</a></p><h3 id="Vue相关"><a href="#Vue相关" class="headerlink" title="Vue相关"></a>Vue相关</h3><h4 id="vue-内置指令"><a href="#vue-内置指令" class="headerlink" title="vue 内置指令"></a>vue 内置指令</h4><p><img src="/../images/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/vue-command.jpg" alt="vue内置指令"></p><h4 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h4><p><code>v-if</code> 和 <code>v-show</code> 都是 Vue 中的条件渲染指令，用于根据条件来控制元素的显示和隐藏。它们之间的区别如下：</p><blockquote><ol><li>编译时机：<code>v-if</code> 是在编译阶段进行条件判断，如果条件为假，那么该元素及其子元素将不会被编译和渲染到 DOM 中。而 <code>v-show</code> 是在编译阶段将元素渲染到 DOM 中，然后通过 CSS 的 <code>display</code> 属性控制元素的显示和隐藏。</li><li>切换消耗：由于 <code>v-if</code> 是在编译阶段进行条件判断，当条件发生变化时，会触发元素的创建或销毁，因此切换时的消耗较大。而 <code>v-show</code> 只是通过修改 CSS 的 <code>display</code> 属性来切换元素的可见性，所以切换时的消耗较小。</li><li>初始渲染开销：由于 <code>v-if</code> 是在编译阶段进行条件判断，当条件为假时，元素及其子元素不会被编译和渲染，所以初始渲染的开销较小。而 <code>v-show</code> 在初始渲染时，会将元素及其子元素都渲染到 DOM 中，然后通过 CSS 控制其可见性，所以初始渲染的开销较大。</li><li>条件切换频率：如果需要频繁切换元素的显示和隐藏，建议使用 <code>v-show</code>，因为它只是通过修改 CSS 属性来切换，性能更好。如果切换频率较低，可以使用 <code>v-if</code>，因为它在条件为假时会销毁元素，可以减少页面中的 DOM 元素数量。</li></ol></blockquote><p>​    <code>v-if</code> 适用于条件切换频率较低的情况，可以节省初始渲染开销和内存占用；<code>v-show</code> 适用于频繁切换元素的可见性，可以减少切换消耗。根据具体的需求和场景选择合适的条件渲染指令。</p><h4 id="v-if-和-v-for-哪个优先级更高"><a href="#v-if-和-v-for-哪个优先级更高" class="headerlink" title="v-if 和 v-for 哪个优先级更高"></a>v-if 和 v-for 哪个优先级更高</h4><p>​    在 Vue 中，<code>v-for</code> 指令的优先级高于 <code>v-if</code> 指令。这意味着当一个元素同时使用了 <code>v-if</code> 和 <code>v-for</code>，<code>v-for</code> 将首先被解析和执行，然后在每个迭代的元素上进行 <code>v-if</code> 的条件判断。</p><p>​    具体来说，当使用 <code>v-if</code> 和 <code>v-for</code> 同时存在于同一个元素上时，Vue 的编译器会先处理 <code>v-for</code>，根据数据集合生成对应的元素列表。然后，在每个生成的元素上，会再依次应用 <code>v-if</code> 的条件判断。这意味着，如果 <code>v-if</code> 的条件为假，对应的元素将不会被渲染到最终的 DOM 中。</p><p>​    <code>v-for</code> 会先根据 <code>items</code> 数据集合生成对应的元素列表，然后在每个元素上应用 <code>v-if</code> 的条件判断。只有当 <code>item.visible</code> 的值为真时，对应的元素才会被渲染到最终的 DOM 中。</p><p>​    需要注意的是，在某些特定情况下，使用 <code>v-if</code> 和 <code>v-for</code> 同时存在可能会导致性能问题，因为每次迭代都需要进行条件判断。在这种情况下，可以考虑使用计算属性或过滤器来预先筛选数据集合，以减少渲染的元素数量，从而提升性能。</p><h4 id="slot（插槽）的作用"><a href="#slot（插槽）的作用" class="headerlink" title="slot（插槽）的作用"></a>slot（插槽）的作用</h4><p>​    插槽（Slot）是 Vue 中一种用于扩展组件内容的机制。通过插槽，你可以在组件的模板中预留出一些位置，然后在使用该组件时，将内容插入到这些位置上。</p><p>插槽的作用主要有以下几个方面：</p><blockquote><ol><li>内容分发：插槽允许组件的使用者向组件中传递内容，并在组件内部进行渲染。使用插槽可以将组件设计得更加灵活，使得组件可以接受不同的内容进行渲染，从而满足不同的需求。</li><li>组件组合：通过插槽，你可以将多个组件组合在一起，形成更复杂的组合组件。插槽使得组件之间的组合变得简单，你可以将多个组件的内容组合在一起，并且可以在父组件中决定如何组合它们。</li><li>默认内容：插槽可以设置默认内容，当使用组件时没有提供具体内容时，将会使用默认的插槽内容进行渲染。这样可以确保即使没有传入内容，组件仍然可以正常显示一些默认的内容。</li></ol></blockquote><p>​    在 Vue 中，有两种类型的插槽：具名插槽和默认插槽。具名插槽允许你为插槽指定名称，并在组件中根据名称进行内容分发。默认插槽是没有名称的，当组件中没有具名插槽时，会将内容分发到默认插槽中。</p><p>​    通过使用插槽，你可以将组件的结构和样式与具体的内容进行解耦，提高了组件的可复用性和灵活性。它是 Vue 中非常强大和常用的特性之一。</p><h4 id="关于-Vue-的单向数据流"><a href="#关于-Vue-的单向数据流" class="headerlink" title="关于 Vue 的单向数据流"></a>关于 Vue 的单向数据流</h4><p>​    数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><blockquote><p>注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</p></blockquote><p>​    如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改。</p><h4 id="computed-和-watch-的区别和运用的场景"><a href="#computed-和-watch-的区别和运用的场景" class="headerlink" title="computed 和 watch 的区别和运用的场景"></a>computed 和 watch 的区别和运用的场景</h4><p>​    computed 是<a href="https://juejin.cn/post/6956407362085191717">计算属性</a>，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。</p><p>​    <a href="https://juejin.cn/post/6954925963226382367">watch</a>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p><p>​    计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑计算属性原理详解 </p><h4 id="vue-中使用了哪些设计模式"><a href="#vue-中使用了哪些设计模式" class="headerlink" title="vue 中使用了哪些设计模式"></a>vue 中使用了哪些设计模式</h4><blockquote><p>1.工厂模式 - 传入参数即可创建实例</p><p>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p><p>2.单例模式 - 整个程序有且仅有一个实例</p><p>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉</p><p>3.发布-订阅模式 (vue 事件机制)</p><p>4.观察者模式 (响应式数据原理)</p><p>5.装饰模式: (@装饰器的用法)</p><p>6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="Vue-模板编译原理"><a href="#Vue-模板编译原理" class="headerlink" title="Vue 模板编译原理"></a>Vue 模板编译原理</h4><p>Vue 的模板编译原理主要包括以下步骤：</p><blockquote><ol><li>解析：Vue 的模板编译器将模板字符串解析为抽象语法树（AST）。AST 是一个树状结构，表示了模板中的各个节点和它们之间的关系。</li><li>优化：在解析完成后，编译器会对生成的 AST 进行优化。这个优化过程包括静态节点标记、静态根节点提升和事件侦听器的缓存等。这些优化可以提高渲染性能和减少运行时的开销。</li><li>代码生成：在优化完成后，编译器会根据 AST 生成渲染函数。渲染函数是一个 JavaScript 函数，它接收数据作为参数，返回一个虚拟 DOM 树。渲染函数可以将模板中的数据和逻辑转换为实际的 DOM 操作。</li><li>组件化编译：如果模板中包含组件，编译器会递归地对组件进行编译。这样可以将组件的模板编译为渲染函数，并生成组件的渲染逻辑。</li></ol></blockquote><p>​    在运行时，Vue 实例会通过编译后的渲染函数生成虚拟 DOM，并将其与实际的 DOM 进行比对，只更新需要改变的部分，以提高性能。</p><p>​    Vue 的模板编译原理将模板字符串解析为 AST，经过优化后生成渲染函数，然后在运行时使用渲染函数生成虚拟 DOM，并进行差异比对来更新视图。这种编译的过程使得 Vue 具有高效的渲染性能和灵活的组件化开发能力。</p><h4 id="Vue-的性能优化"><a href="#Vue-的性能优化" class="headerlink" title="Vue 的性能优化"></a>Vue 的性能优化</h4><p>Vue 的性能优化可以从以下几个方面考虑：</p><blockquote><ol><li>减少不必要的重新渲染：Vue 使用响应式系统来跟踪数据的变化并更新视图。为了减少不必要的重新渲染，可以使用合理的计算属性和侦听器，避免不必要的计算和更新。另外，使用 v-if 和 v-show 来条件渲染元素，只渲染当前需要显示的部分。</li><li>列表渲染优化：在使用 v-for 渲染列表时，使用唯一的 key 属性来提高性能。Vue 使用 key 来跟踪每个节点的身份，以便在更新过程中进行重用和重新排序，而不是完全重新创建和销毁 DOM 节点。</li><li>懒加载和异步组件：对于大型的页面或组件，可以使用懒加载和异步组件来延迟加载和渲染。这可以加快初始加载时间并减少首屏渲染的工作量。</li><li>使用 v-if 和 v-for 的选择：在需要根据条件动态渲染的元素上使用 v-if，而不是在列表上使用 v-for。因为 v-if 在条件不满足时会完全销毁和重建元素，而 v-for 只是在数据发生变化时更新元素。</li><li>使用虚拟列表或无限滚动：当需要处理大量数据列表时，可以使用虚拟列表或无限滚动的技术来提高性能。这样可以减少一次性渲染的节点数量，只渲染可见部分，从而减少内存占用和渲染时间。</li><li>合理使用异步更新：Vue 提供了 nextTick 方法和 $nextTick 实例方法来在下次 DOM 更新周期之后执行回调。合理使用异步更新可以将多个更新合并成一次，减少不必要的计算和渲染。</li><li>基于路由的代码分割：通过合理的路由配置和动态导入，将页面的代码拆分成更小的块，按需加载和渲染，提高初始加载速度和页面切换的响应性。</li><li>合理使用缓存：对于一些计算开销较大的结果或静态数据，可以使用缓存来避免重复计算或请求。例如，使用计算属性的缓存选项或使用工具库进行数据缓存。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器相关</title>
      <link href="/2023/05/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/05/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h3><h4 id="Chrome-架构：仅仅打开了-1-个页面，为什么有-4-个进程"><a href="#Chrome-架构：仅仅打开了-1-个页面，为什么有-4-个进程" class="headerlink" title="Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程"></a>Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程</h4><blockquote><p><strong>线程和进程区别</strong>：多线程可以并行处理任务，线程不能单独存在，它是由进程来启动和管理的。一个进程是一个程序的运行实例。</p><p><strong>线程和进程的关系</strong>：1、进程中任意一线程执行出错，都会导致整个进程的崩溃。2、线程之间共享进程中的数据。3、当一个进程关闭后，操作系统会回收进程所占用的内存。4、进程之间的内容相互隔离。</p><p><strong>单进程 浏览器</strong>：1、不稳定。单进程中的插件、渲染线程崩溃导致整个浏览器崩溃。2、不流畅。脚本（死循环）或插件会使浏览器卡顿。3、不安全。插件和脚本可以获取到操作系统任意资源。</p><p><strong>多进程浏览器</strong>：1、解决不稳定。进程相互隔离，一个页面或者插件崩溃时，影响仅仅时当前插件或者页面，不会影响到其他页面。2、解决不流畅。脚本阻塞当前页面渲染进程，不会影响到其他页面。3、解决不安全。采用多进程架构使用沙箱。沙箱看成时操作系统给进程上来一把锁，沙箱的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据。</p><p><strong>多进程架构</strong>：分为 浏览器进程、渲染进程、GPU 进程、网络进程、插件进程。</p><p><strong>缺点</strong>：1、资源占用高。2、体系架构复杂。</p><p><strong>面向服务架构</strong>：把原来的各种模块重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过 IPC 通讯，使得系统更内聚、松耦合、易维护和拓展。</p></blockquote><h4 id="TCP-协议：如何保证页面文件能被完整送达浏览器"><a href="#TCP-协议：如何保证页面文件能被完整送达浏览器" class="headerlink" title="TCP 协议：如何保证页面文件能被完整送达浏览器"></a>TCP 协议：如何保证页面文件能被完整送达浏览器</h4><blockquote><ul><li>IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息；</li><li>UDP 头中除了目的端口，还有源端口号等信息；</li><li>IP 负责把数据包送达目的主机；</li><li>UDP 负责把数据包送达具体应用；</li><li>对于错误的数据包，UDP 不提供重发机制，只是丢弃当前的包，不能保证数据的可靠性，但是传输速度非常块；</li><li>TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接；</li></ul></blockquote><h4 id="HTTP-请求流程：为什么很多站点第二次打开速度会很快"><a href="#HTTP-请求流程：为什么很多站点第二次打开速度会很快" class="headerlink" title="HTTP 请求流程：为什么很多站点第二次打开速度会很快"></a>HTTP 请求流程：为什么很多站点第二次打开速度会很快</h4><blockquote><ul><li>浏览器中的 HTTP 请求从发起到结束一共经历如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接；</li><li>构建请求。浏览器构建请求行，构建好后，准备发起网络请求；</li><li>查找缓存。在真正发起请求前浏览器会查询缓存中是否有请求资源副本，有则拦截请求，返回资源副本，否则进入网络请求；</li><li>准备 IP 地址和端口。HTTP 网络请求需要和服务器建立 TCP 连接，而建立 TCP 连接需要准备 IP 地址和端口号，浏览器需要请求 DNS 返回域名对应的 IP，同时会缓存域名解析结果，供下次查询使用；</li><li>等待 TCP 队列。Chrome 机制，同一个域名同时最多只能建立 6 个 TCP 连接；</li><li>建立 TCP 连接。TCP 通过“三次握手”建立连接，传输数据，“四次挥手”断开连接；</li><li>发送 HTTP 请求。建立 TCP 连接后，浏览器就可以和服务器进行 HTTP 数据传输了，首先会向服务器发送请求行，然后以请求头形式发送一些其他信息，如果是 POST 请求还会发送请求体；</li><li>服务器处理请求。首先服务器会返回响应行，随后，服务器向浏览器发送响应头和响应体。通常服务器返回数据，就要关闭 TCP 连接，如果请求头或者响应头有 Connection:keep-alive TCP 保持打开状态；</li></ul></blockquote><h4 id="导航流程：从输入-URL-到页面展示这中间发生了什么"><a href="#导航流程：从输入-URL-到页面展示这中间发生了什么" class="headerlink" title="导航流程：从输入 URL 到页面展示这中间发生了什么"></a>导航流程：从输入 URL 到页面展示这中间发生了什么</h4><blockquote><ul><li><p>用户输入 URL 并回车</p></li><li><p>浏览器进程检查 URL，组装协议，构成完整 URL</p></li><li><p>浏览器进程通过进程通信（IPC）把 URL 请求发送给网络进程</p></li><li><p>网络进程接收到 URL 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</p></li><li><p>如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下：</p></li><li><ul><li>进行 DNS 解析，获取服务器 IP 地址，端口</li><li>利用 IP 地址和服务器建立 tcp 连接</li><li>构建请求头信息</li><li>发送请求头信息</li><li>服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li></ul></li><li><p>网络进程解析响应流程：</p></li><li><ul><li>检查状态码，如果是 301/302，则需要重定向，从 Location 自动读取地址，重新进行第 4 步，如果是 200，则继续处理请求</li><li>200 响应处理：检查响应类型 Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续渲染。如果是 html 则通知浏览器进程准备渲染进程进行渲染</li></ul></li><li><p>准备渲染进程</p></li><li><ul><li>浏览器进程检查当前 URL 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li></ul></li><li><p>传输数据、更新状态</p></li><li><ul><li>渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”</li><li>渲染进程接收完数据后，向浏览器发送“确认提交”</li><li>浏览器进程接收到确认消息后 engine 浏览器界面状态：安全、地址 URL、前进后退的历史状态、更新 web 页面</li></ul></li></ul></blockquote><h4 id="渲染流程：HTML、CSS-和-JavaScript-是如何变成页面的"><a href="#渲染流程：HTML、CSS-和-JavaScript-是如何变成页面的" class="headerlink" title="渲染流程：HTML、CSS 和 JavaScript 是如何变成页面的"></a>渲染流程：HTML、CSS 和 JavaScript 是如何变成页面的</h4><blockquote><ul><li><p>浏览器不能直接理解 HTML 数据，需要将其转化为 DOM 树结构；</p></li><li><p>生成 DOM 树后，根据 CSS 样式表，计算出 DOM 树所有节点样式；</p></li><li><p>创建布局树：遍历 DOM 树所有可见节点，把这些节点加到布局中，不可见节点忽略，如 head 标签下所有内容，display: none 元素；</p></li><li><p>分层：层叠上下文属性的元素（比如定位属性元素、透明属性元素、CSS 滤镜属性元素）提升为单独的一层，需要裁剪的地方（比如出现滚动条）也会被创建为图层；</p></li><li><p>图层绘制：完成图层树构建后，渲染引擎会对图层树每一层进行绘制，把一个图层拆分成小的绘制指令，再把指令按照顺序组成一个带绘制列表；</p></li><li><p>有些情况图层很大，一次绘制所有图层内容，开销太大，合成线程会将图层划分为图块（256x256 或者 512x512）；</p></li><li><p>合成线程将图块提交给栅格线程进行栅格化，将图块转换为位图。栅格化过程都会使用 GPU 加速，生成的位图保存周期 GPU 内存中；</p></li><li><p>一旦所有图块都被栅格化，合成线程会生成一个绘制图块命令（DrawQuad），然会将命令提交给浏览器进程，viz 组件接收到该指令，将页面内容绘制到内存中，显示在屏幕上；</p></li><li><p>重排：通过 JavaScript 或者 CSS 修改元素几何位置属性，会触发重新布局，解析后面一系列子阶段；重绘：不引起布局变换，直接进入绘制及其以后子阶段；合成：跳过布局和绘制阶段，执行的后续操作，发生在合成线程，非主线程；</p></li></ul></blockquote><h4 id="渲染流水线：CSS-如何影响首次加载时的白屏时间？"><a href="#渲染流水线：CSS-如何影响首次加载时的白屏时间？" class="headerlink" title="渲染流水线：CSS 如何影响首次加载时的白屏时间？"></a>渲染流水线：CSS 如何影响首次加载时的白屏时间？</h4><blockquote><ul><li>DOM 构建结束之后，css 文件还未下载完成，渲染流水线空闲，因为下一步是合成布局树，合成布局树需要 CSSOM 和 DOM，这里需要等待 CSS 加载结束并解析成 CSSOM；</li><li>CSSOM 两个作用：提供给 JavaScript 操作样式表能力，为布局树的合成提供基础样式信息；</li><li>在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转化为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。</li></ul></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="浏览器底层基础"><a href="#浏览器底层基础" class="headerlink" title="浏览器底层基础"></a>浏览器底层基础</h3><h4 id="变量提升：javascript-代码是按顺序执行的吗"><a href="#变量提升：javascript-代码是按顺序执行的吗" class="headerlink" title="变量提升：javascript 代码是按顺序执行的吗"></a>变量提升：javascript 代码是按顺序执行的吗</h4><blockquote><ul><li>JavaScript 代码在执行之前需要先编译，在编译阶段，变量和函数会被存放到变量环境中，变量默认值会被设置为 undefined；</li><li>在代码执行阶段，JavaScript 引擎会从变量环境中查找自定义的变量和函数；</li><li>如果在编译阶段，窜爱两个相同的函数，那么最终放在变量环境中的是最后定义的那个，后定义的覆盖先定义的；</li></ul></blockquote><h4 id="调用栈：为什么-JavaScript-代码会出现栈溢出"><a href="#调用栈：为什么-JavaScript-代码会出现栈溢出" class="headerlink" title="调用栈：为什么 JavaScript 代码会出现栈溢出"></a>调用栈：为什么 JavaScript 代码会出现栈溢出</h4><blockquote><ul><li>每调用一个函数，JavaScript 引擎会为其创建执行上下文压入调用栈，然后，JavaScript 引擎开始执行函数代码。</li><li>如果一个函数 A 调用另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</li><li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li></ul></blockquote><h4 id="块级作用域：var-缺陷以及为什么要引入-let-和-const"><a href="#块级作用域：var-缺陷以及为什么要引入-let-和-const" class="headerlink" title="块级作用域：var 缺陷以及为什么要引入 let 和 const"></a>块级作用域：var 缺陷以及为什么要引入 let 和 const</h4><blockquote><ul><li>let、const 申明的变量不会被提升。在 javascript 引擎编译后，会保存在词法环境中。</li><li>块级作用域在代码执行时，将 let、const 变量存放在词法环境的一个单独的区域。词法环境内部维护一个小型的栈结构，作用域内部变量压入栈顶。作用域执行完，从栈顶弹出。</li></ul></blockquote><h4 id="作用域链和闭包：代码中出现相同的变量，JavaScript-引擎如何选择"><a href="#作用域链和闭包：代码中出现相同的变量，JavaScript-引擎如何选择" class="headerlink" title="作用域链和闭包：代码中出现相同的变量，JavaScript 引擎如何选择"></a>作用域链和闭包：代码中出现相同的变量，JavaScript 引擎如何选择</h4><blockquote><ul><li>使用一个变量，JavaScript 引擎会在当前的执行上下文中查找变量，如果没有找到，会继续在 outer（执行环境指向外部执行上下文的引用）所指向的执行上下文中查找；</li><li>JavaScript 执行过程，作用域链是由词法作用域决定，而词法作用域是由代码中函数声明的位置决定；</li><li>根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使外部函数已经执行结束了，但是内部函数引用外部函数的变量依旧保存在内存中，把这些变量的集合称为闭包；</li></ul></blockquote><h4 id="this：从-JavaScript-执行上下文视角讲-this"><a href="#this：从-JavaScript-执行上下文视角讲-this" class="headerlink" title="this：从 JavaScript 执行上下文视角讲 this"></a>this：从 JavaScript 执行上下文视角讲 this</h4><blockquote><p>当执行 new CreateObj 的时候，JavaScript 引擎做了四件事：</p><ul><li>首先创建一个控对象 tempObj；</li><li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 createObj 的执行上下文创建时，它的 this 就指向 tempObj 对象；</li><li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向 tempObj 对象；</li><li>最后返回 tempObj 对象。</li></ul><p>this 的使用分为：</p><ul><li>当函数最为对象的方法调用时，函数中的 this 就是该对象；</li><li>当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；</li><li>嵌套函数中的 this 不会继承外层函数的 this 值；</li><li>箭头函数没有自己的执行上下文，this 是外层函数的 this。</li></ul></blockquote><h4 id="DOM-树：JavaScript-是如何影响-DOM-树构建的"><a href="#DOM-树：JavaScript-是如何影响-DOM-树构建的" class="headerlink" title="DOM 树：JavaScript 是如何影响 DOM 树构建的"></a>DOM 树：JavaScript 是如何影响 DOM 树构建的</h4><blockquote><ul><li>HTML 解析器（HTMLParse）负责将 HTML 字节流转换为 DOM 结构；</li><li>HTML 解析器并不是等整个文档加载完成之后再解析，而是网络进程加载流多少数据，便解析多少数据；</li><li>字节流转换成 DOM 三个阶段：1、字节流转换为 Token；2、维护一个 Token 栈，遇到 StartTag Token 入栈，遇到 EndTag Token 出栈；3、为每个 Token 创建一个 DOM 节点；</li><li>JavaScript 文件和 CSS 样式表文件都会阻塞 DOM 解析；</li></ul></blockquote><h4 id="宏任务和微任务：不是所有的任务都是一个待遇"><a href="#宏任务和微任务：不是所有的任务都是一个待遇" class="headerlink" title="宏任务和微任务：不是所有的任务都是一个待遇"></a>宏任务和微任务：不是所有的任务都是一个待遇</h4><blockquote><ul><li>消息队列中的任务为宏任务。渲染进程内部会维护多个消息队列，比如延时执行队列和普通消息队列，主线程采用 for 循环，不断地从这些任务队列中取出任务并执行；</li><li>微任务是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前；</li><li>V8 在执行 javascript 脚本时，会为其创建一个全局执行上下文，同时会创建一个微任务队列；</li><li>执行微任务过程中产生的微任务不会推迟到下个宏任务中执行，而是在当前宏任务中继续执行；</li></ul></blockquote><h4 id="使用-Promise-告别回调函数"><a href="#使用-Promise-告别回调函数" class="headerlink" title="使用 Promise 告别回调函数"></a>使用 Promise 告别回调函数</h4><ul><li>使用 Promise 解决了回调地狱问题，消灭嵌套和多次处理；</li><li>模拟实现 Promise</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Bromise</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> _onResolve <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>then <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>onResolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    _onResolve <span class="token operator">=</span> onResolve  <span class="token punctuation">}</span>  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">_onResolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="async-await-使用同步方式写异步代码"><a href="#async-await-使用同步方式写异步代码" class="headerlink" title="async await 使用同步方式写异步代码"></a>async await 使用同步方式写异步代码</h4><blockquote><ul><li>生成器函数是一个带星号函数，而且是可以暂停执行和回复执行的；</li><li>生成器函数内部执行一段代码，遇到 yield 关键字，javascript 引擎返回关键字后面的内容给外部，并且暂停该函数的执行；</li><li>外部函数可以同步 next 方法恢复函数的执行；</li><li>协程是一种比线程更加轻量级的存在，协程可以看成是跑在线程上的任务，一个线程可以存在多个协程，但是同时只能执行一个协程，如果 A 协程启动 B 协程，A 为 B 的父协程；</li><li>协程不被操作协同内核所管理，而完全由程序所控制，这样性能提升；</li><li><code>await xxx</code> 会创建一个 Promise 对象，将 <code>xxx</code> 任务提交给微任务队列；</li><li>暂停当前协程的执行，将主线程的控制权力转交给父协程执行，同时将 Promise 对象返回给父协程，继续执行父协程；</li><li>父协程执行结束之前会检查微任务队列，微任务队列中有 <code>resolve(xxx)</code> 等待执行，触发 then 的回调函数；</li><li>回调函数被激活后，会将主线程的控制权交给协程，继续执行后续语句，完成后将控制权还给父协程。</li></ul></blockquote><h4 id="webapi：setTimeout-是怎么实现的"><a href="#webapi：setTimeout-是怎么实现的" class="headerlink" title="webapi：setTimeout 是怎么实现的"></a>webapi：setTimeout 是怎么实现的</h4><blockquote><ul><li>JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程会创建一个回调任务，延时执行队列存放定时器任务；</li><li>当定时器任务到期，就会从延时队列中取出并执行；</li><li>如果当前任务执行时间过久，会影响延时到期定时器任务的执行；</li><li>如果 setTimeout 存在嵌套调用（5 次以上），判断该函数方法被阻塞，那么系统会设置最短时间间隔为 4 秒；</li><li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒，目的是为了降低加载损耗；</li><li>延时执行时间最大值是 24.8 天，因为延时值是以 32 个 bit 存储的；</li><li>setTimeout 设置的回调函数中的 this 指向全局 window。</li></ul></blockquote><h4 id="webapi：XMLHttpRequest-是怎么实现的"><a href="#webapi：XMLHttpRequest-是怎么实现的" class="headerlink" title="webapi：XMLHttpRequest 是怎么实现的"></a>webapi：XMLHttpRequest 是怎么实现的</h4><blockquote><ul><li>XMLHttpRequest onreadystatechange 处理流程：未初始化 -&gt; OPENED -&gt; HEADERS_RECEIVED -&gt; LOADING -&gt; DONE；</li><li>渲染进程会将请求发送给网络进程，然后网络进程负责资源下载，等网络进程接收到数据后，利用 IPC 通知渲染进程；</li><li>渲染进程接收到消息之后，会将 xhr 回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，会根据相关状态来调用回调函数。</li></ul></blockquote><h3 id="浏览器运行机制"><a href="#浏览器运行机制" class="headerlink" title="浏览器运行机制"></a>浏览器运行机制</h3><h4 id="栈空间和堆空间：数据是如何存储的"><a href="#栈空间和堆空间：数据是如何存储的" class="headerlink" title="栈空间和堆空间：数据是如何存储的"></a>栈空间和堆空间：数据是如何存储的</h4><blockquote><p>动态语言：在使用时需要检查数据类型的语言。<br>弱类型语言：支持隐式转换的语言。</p><p>JavaScript 中的 8 种数据类型，它们可以分为两大类——原始类型和引用类型。<br>原始类型数据存放在栈中，引用类型数据存放在堆中。堆中的数据是通过引用与变量关系联系起来的。</p><p>从内存视角了解闭包：词法扫描内部函数，引用了外部函数变量，堆空间创建一个“closure”对象，保存变量。</p></blockquote><h4 id="垃圾回收：垃圾数据如何自动回收"><a href="#垃圾回收：垃圾数据如何自动回收" class="headerlink" title="垃圾回收：垃圾数据如何自动回收"></a>垃圾回收：垃圾数据如何自动回收</h4><blockquote><ul><li>栈中数据回收：执行状态指针 ESP 在执行栈中移动，移过某执行上下文，就会被销毁；</li><li>堆中数据回收：V8 引擎采用标记-清除算法；</li><li>V8 把堆分为两个区域——新生代和老生代，分别使用副、主垃圾回收器；</li><li>副垃圾回收器负责新生代垃圾回收，小对象（1 ～ 8M）会被分配到该区域处理；</li><li>新生代采用 scavenge 算法处理：将新生代空间分为两半，一半空闲，一半存对象，对对象区域做标记，存活对象复制排列到空闲区域，没有内存碎片，完成后，清理对象区域，角色反转；</li><li>新生代区域两次垃圾回收还存活的对象晋升至老生代区域；</li><li>主垃圾回收器负责老生区垃圾回收，大对象，存活时间长；</li><li>新生代区域采用标记-清除算法回收垃圾：从根元素开始，递归，可到达的元素活动元素，否则是垃圾数据；</li><li>为了不造成卡顿，标记过程被切分为一个个子标记，交替进行。</li></ul></blockquote><h4 id="编译器和解析器：V8-如何执行一段-JavaScript-代码的"><a href="#编译器和解析器：V8-如何执行一段-JavaScript-代码的" class="headerlink" title="编译器和解析器：V8 如何执行一段 JavaScript 代码的"></a>编译器和解析器：V8 如何执行一段 JavaScript 代码的</h4><blockquote><ul><li>计算机语言可以分为两种：编译型和解释型语言。编译型语言经过编译器编译后保留机器能读懂的二进制文件，比如 C/C++，go 语言。解释型语言是在程序运行时通过解释器对程序进行动态解释和执行，比如 Python，JavaScript 语言。</li><li>编译型语言的编译过程：编译器首先将代码进行词法分析、语法分析，生成抽象语法树（AST），然后优化代码，最后生成处理器能够理解的机器码；</li><li>解释型语言解释过程：解释器会对代码进行词法分析、语法分析，并生产抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后根据字节码执行程序；</li><li>AST 的生成：第一阶段是分词（词法分析），将一行行源码拆解成一个个 token（语法上不可再分、最小单个字符）。第二阶段是解析（语法分析），将上一步生成的 token 数据，根据语法规则转为 AST，这一阶段会检查语法错误；</li><li>字节码存在的意义：直接将 AST 转化为机器码，执行效率是非常高，但是消耗大量内存，从而先转化为字节码解决内存问题；</li><li>解释器 ignition 在解释执行字节码，同时会手机代码信息，发现某一部分代码是热点代码（HotSpot），编译器把热点的字节码转化为机器码，并保存起来，下次使用；</li><li>字节码配合解释器和编译器的计数实现称为即时编译（JIT）。</li></ul></blockquote><h4 id="消息队列和事件循环：页面是怎么活起来的"><a href="#消息队列和事件循环：页面是怎么活起来的" class="headerlink" title="消息队列和事件循环：页面是怎么活起来的"></a>消息队列和事件循环：页面是怎么活起来的</h4><blockquote><ul><li>每个渲染进程都有一个主线程，主线程会处理 DOM，计算样式，处理布局，JavaScript 任务以及各种输入事件；</li><li>维护一个消息队列，新任务（比如 IO 线程）添加到消息队列尾部，主线程循环地从消息队列头部读取任务，执行任务；</li><li>解决处理优先级高的任务：消息队列的中的任务称为宏任务，每个宏任务中都会包含一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，将该变化添加到微任务队列中；</li><li>解决单个任务执行时长过久：JavaScript 通过回调功能来规避。</li></ul></blockquote><h4 id="分层和合成机制：为什么-CSS-动画比-JavaScript-高效"><a href="#分层和合成机制：为什么-CSS-动画比-JavaScript-高效" class="headerlink" title="分层和合成机制：为什么 CSS 动画比 JavaScript 高效"></a>分层和合成机制：为什么 CSS 动画比 JavaScript 高效</h4><blockquote><ul><li>显示器固定刷新频率是 60HZ，即每秒更新 60 张图片，图片来自显卡的前缓冲区；</li><li>显卡的职责是合成新的图像，保存在后缓冲区，然后后缓冲区和前缓冲区互换，显卡更新频率和显示前刷新频率不一致，就会造成视觉上的卡顿；</li><li>渲染流水线生成的每一副图片称为一帧，生成一帧的方式有重排、重绘和合成三种；</li><li>重排会根据 CSSOM 和 DOM 计算布局树，重绘没有重新布局阶段；</li><li>生成布局树之后，渲染引擎根据布局树特点转化为层树，每一层解析出绘制列表；</li><li>栅格线程根据绘制列表中的指令生成图片，每一层对应一张图片，合成线程将这些图片合成一张图片，发送到后缓存区；</li><li>合成线程会将每个图层分割成大小固定的图块，优先绘制靠近视口的图块；</li></ul></blockquote><h3 id="浏览器性能优化"><a href="#浏览器性能优化" class="headerlink" title="浏览器性能优化"></a>浏览器性能优化</h3><h4 id="页面性能：如何系统优化页面"><a href="#页面性能：如何系统优化页面" class="headerlink" title="页面性能：如何系统优化页面"></a>页面性能：如何系统优化页面</h4><blockquote><ul><li>加载阶段：减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数；</li><li>交互阶段：减少 JavaScript 脚本执行时间，避免强制同步布局：操作 DOM 的同时获取布局样式会引发，避免布局抖动：多次执行强制布局和抖动，合理利用 CSS 合成动画：标记 will-change，避免频繁的垃圾回收；</li><li>CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程中执行，这个过程称为合成，它不会触发重排或者重绘；</li></ul></blockquote><h4 id="虚拟-DOM：虚拟-DOM-和真实-DOM-有何不同"><a href="#虚拟-DOM：虚拟-DOM-和真实-DOM-有何不同" class="headerlink" title="虚拟 DOM：虚拟 DOM 和真实 DOM 有何不同"></a>虚拟 DOM：虚拟 DOM 和真实 DOM 有何不同</h4><blockquote><ul><li>当有数据更新时， React 会生产一个新的虚拟 DOM，然会拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程找出变化的节点，然后将变化的节点应用到 DOM 上；</li><li>最开始的时候，比较两个 DOM 的过程是在一个递归函数里执行的，其核心算法是 reconciliation。通常情况，这个比较过程执行很快，不过虚拟 DOM 比较复杂时，执行比较函数可能占据主线程比较久的时间，这样会导致其他任务的等待，造成页面卡顿。React 团队重写了 reconciliation 算法，称为 Fiber reconciler，之前老的算法称为 Stack reconciler；</li></ul></blockquote><h4 id="HTTP1：HTTP1-性能优化"><a href="#HTTP1：HTTP1-性能优化" class="headerlink" title="HTTP1：HTTP1 性能优化"></a>HTTP1：HTTP1 性能优化</h4><blockquote><ul><li>HTTP/0.9 基于 TCP 协议，三次握手建立连接，发送一个 GET 请求行（没有请求头和请求体），服务器接收请求之后，读取对应 HTML 文件，数据以 ASCII 字符流返回，传输完成断开连接；</li><li>HTTP/1.0 增加请求头和响应头来进行协商，在发起请求时通过请求头告诉服务器它期待返回什么类型问题、什么形式压缩、什么语言以及文件编码。引入来状态吗，Cache 机制等；</li><li>HTTP/1.1 改进持久化连接，解决建立 TCP 连接、传输数据和断开连接带来的大量开销，支持在一个 TCP 连接上可以传输多个 HTTP 请求，目前浏览器对于一个域名同时允许建立 6 个 TCP 持久连接；</li><li>HTTP/1.1 引入 Chunk transfer 支持动态生成内容：服务器将数据分割成若干任意大小的数据块，每个数据块发送时附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。在 HTTP/1.1 需要在响应头中设置完整的数据大小，如 Content-Length。</li></ul></blockquote><h4 id="HTTP2：如何提升网络速度"><a href="#HTTP2：如何提升网络速度" class="headerlink" title="HTTP2：如何提升网络速度"></a>HTTP2：如何提升网络速度</h4><blockquote><ul><li>HTTP/1.1 主要问题：TCP 慢启动；同时开启多条 TCP 连接，会竞争固定宽带；对头阻塞问题；</li><li>HTTP/2 在一个域名下只使用一个 TCP 长连接和消除对头阻塞问题；</li><li>多路复用的实现：HTTP/2 添加了二进制分帧层，将发送或响应数据经过二进制分帧处理，转化为一个个带有请求 ID 编号的帧，服务器或者浏览器接收到响应帧后，根据相同 ID 帧合并为一条完整信息；</li><li>设置请求优先级：发送请求可以设置请求优先级，服务器可以优先处理；</li><li>服务器推送：请求一个 HTML 页面，服务器可以知道引用了哪些 JavaScript 和 CSS 文件，附带一起发送给浏览器；</li><li>头部压缩：对请求头和响应头进行压缩；</li></ul></blockquote><h4 id="HTTP3：甩掉-TCP、TCL-包袱，构建高效网络"><a href="#HTTP3：甩掉-TCP、TCL-包袱，构建高效网络" class="headerlink" title="HTTP3：甩掉 TCP、TCL 包袱，构建高效网络"></a>HTTP3：甩掉 TCP、TCL 包袱，构建高效网络</h4><blockquote><ul><li>虽然 HTTP/2 解决了应用层面的对头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议，而 TCP 最初是为了单连接而设计；</li><li>TCP 可以看成是计算机之间的一个虚拟管道，数据从一端发送到另一端会被拆分为一个个按照顺序排列的数据包，如果在传输过程中，有一个数据因为网络故障或者其他原因丢失，那么整个连接会处于暂停状态，只有等到该数据重新传输；</li><li>由于 TCP 协议僵化，也不可能使用新的协议，HTTP/3 选择了一个折衷的方法，基于现有的 UDP 协议，实现类似 TC 片多路复用，传输可靠等功能，称为 QULC 协议；</li><li>QULC 实现类似 TCP 流量控制，传输可靠功能；集成 TLS 加密功能；实现多路复用功能；</li></ul></blockquote><h3 id="浏览器相关小贴士"><a href="#浏览器相关小贴士" class="headerlink" title="浏览器相关小贴士"></a>浏览器相关小贴士</h3><h4 id="同源策略：为什么-XMLHttpRequst-不能跨域请求"><a href="#同源策略：为什么-XMLHttpRequst-不能跨域请求" class="headerlink" title="同源策略：为什么 XMLHttpRequst 不能跨域请求"></a>同源策略：为什么 XMLHttpRequst 不能跨域请求</h4><blockquote><ul><li>协议、域名和端口号相同的 URL 是同源的；</li><li>同源策略会隔离不同源的 DOM、页面数据和网络通信；</li><li>页面可以引用第三方资源，不过暴露出诸如 XSS 问题，引入内容安全策略 CSP 限制；</li><li>默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，引入跨域资源共享（CORS）进行跨域访问控制；</li></ul></blockquote><h4 id="跨站脚本攻击-XSS：为什么-cookie-中有-httpOnly-属性"><a href="#跨站脚本攻击-XSS：为什么-cookie-中有-httpOnly-属性" class="headerlink" title="跨站脚本攻击 XSS：为什么 cookie 中有 httpOnly 属性"></a>跨站脚本攻击 XSS：为什么 cookie 中有 httpOnly 属性</h4><blockquote><ul><li>XSS 跨站脚本，往 HTML 文件中注入恶意代码，对用户实施攻击；</li><li>XSS 攻击主要有存储型 XSS 攻击、反射型 XSS 攻击和 DOM 的 XSS 攻击；</li><li>阻止 XSS 攻击：服务器对脚本进行过滤或转码，利用 CSP 策略，使用 HttpOnly；</li></ul></blockquote><h4 id="CSRF-攻击：陌生连接不要随便点"><a href="#CSRF-攻击：陌生连接不要随便点" class="headerlink" title="CSRF 攻击：陌生连接不要随便点"></a>CSRF 攻击：陌生连接不要随便点</h4><blockquote><ul><li>CSRF 跨站请求伪造，利用用户的登录状态，通过第三方站点攻击；</li><li>避免 CSRF 攻击：利用 SameSite（三种模式：Strict、Lax、None） 让浏览器禁止第三方站点发起请求携带关键 Cookie；验证请求的来源站点，请求头中的 Referer 和 Origin 属性；利用 CSRF Token；</li></ul></blockquote><h4 id="沙盒：页面和系统之间的隔离墙"><a href="#沙盒：页面和系统之间的隔离墙" class="headerlink" title="沙盒：页面和系统之间的隔离墙"></a>沙盒：页面和系统之间的隔离墙</h4><blockquote><ul><li>浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核石油网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程；</li><li>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程；</li><li>站点隔离（Site Isolation）将同一站点（包含相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行；</li><li>实现站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此无法攻击其他站点；</li></ul></blockquote><h4 id="HTTPS：让数据传输更安全"><a href="#HTTPS：让数据传输更安全" class="headerlink" title="HTTPS：让数据传输更安全"></a>HTTPS：让数据传输更安全</h4><blockquote><ul><li>在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密；</li><li>对称加密：浏览器发送加密套件列表和一个随机数 client-random，服务器会从加密套件中选取一个加密套件，然后生成一个随机数 service-random，返回给浏览器。这样浏览器和服务器都有相同 client-random 和 service-random，再用相同的方法将两者混合生成一个密钥 master secret，双方就可以进行数据加密传输了；</li><li>对称加密缺点：client-random 和 service-random 的过程都是明文，黑客可以拿到协商的加密套件和双方随机数，生成密钥，数据可以被破解；</li><li>非对称加密：浏览器发送加密套件列表给服务器，服务器选择一个加密套件，返回加密套件和公钥，浏览器用公钥加密数据，服务器用私钥解密；</li><li>非对称加密缺点：加密效率太低，不能保证服务器发送给浏览器的数据安全，黑客可以获取公钥；</li><li>对称加密结合非对称加密：浏览器发送对称加密套件列表、非对称加密列表和随机数 client-random 给服务器，服务器生成随机数 service-random，选择加密套件和公钥返回给浏览器，浏览器利用 client-random 和 service-random 计算出 pre-master，然后利用公钥给 pre-master 加密，向服务器发送加密后的数据，服务器用私钥解密出 pre-master 数据，结合 client-random 和 service-random 生成对称密钥，使用对称密钥传输加密数据；</li><li>引入数字证书是为了证明“我就是我”，防止 DNS 被劫持，伪造服务器；</li><li>证书的作用：一个是向浏览器证明服务器的身份，另一个是包含服务器公钥；</li><li>数字签名过程：CA 使用 Hash 函数技术明文信息，得出信息摘要，然后 CA 使用私钥对信息摘要进行加密，加密后的秘文就是数字签名；</li><li>验证数字签名：读取证书明文信息，使用相同 Hash 函数计算得到信息摘要 A，再利用 CA 的公钥解密得到 B，对比 A 和 B，如果一致，则确认证书合法；</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo框架以及GitHub搭载个人博客网站 （小白向）</title>
      <link href="/2022/07/13/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/"/>
      <url>/2022/07/13/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该博文是博主的一个朋友想要了解个人博客网站的搭建而撰写的一篇简易的搭建教程。我贾哥说过学习巩固某一知识点的最好方法便是传授予他人。那么话不多削我们这就开始，因为这是个没有计算机基础的同学所以我会从最基础的地方开始撰写，篇幅可能会有点长请耐心食用。</p></blockquote><h4 id="0-首先最开始的一步就是-科学上网"><a href="#0-首先最开始的一步就是-科学上网" class="headerlink" title="0. 首先最开始的一步就是 科学上网"></a>0. 首先最开始的一步就是 科学上网</h4><blockquote><p>科学上网俗称 ‘翻墙上外网’，首先你要有能够翻墙上外网的能力才可以方便我们上GitHub去注册账户。当然也不局限与这一点，有了科学上网的能力你便可以使用谷歌搜索引擎以及浏览类似YouTube的国外网站或者某些奇奇怪怪的东西。（手动狗头.jpg）</p></blockquote><p>那么怎么进行科学上网（翻墙）呢 ？</p><p>咱也不展开来讲有兴趣的可以自行谷歌一下翻墙原理。</p><p>这里或许有人会和我吐槽我都翻不了墙怎么上谷歌？ 最简单的一个方法就是找一个一站式的翻墙软件。博主这里用的是 <a href="https://666yun.men/#/register?code=E9pw8QiO">蜂巢vpn</a> 这上面都有相应的一个使用教程的。</p><h4 id="1-注册GitHub账号以及下载对应的代码编辑器以及编程环境"><a href="#1-注册GitHub账号以及下载对应的代码编辑器以及编程环境" class="headerlink" title="1. 注册GitHub账号以及下载对应的代码编辑器以及编程环境"></a>1. 注册GitHub账号以及下载对应的代码编辑器以及编程环境</h4><p>既然能科学上网了就先去<a href="https://github.com/">GitHub</a>注册个账号吧 </p><p>然后下载所需的一个代码编辑器 这里推荐 <a href="https://www.runoob.com/w3cnote/vscode-tutorial.html">VSCode</a></p><p>下载完之后呢我们可以在桌面上新建一个文本文档，然后将其改名为.html后缀的文件，再通过右键或者拖拽至VSCode进行打开。</p><blockquote><p>tips: 如果不会的话可以先把下述代码贴在文本文档内再去更改为.html后缀 双击打开 </p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">  <span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">300</span>px <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>你好呀！ 隔壁黄阿姨 (*´▽｀)ノノ❤ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/helloAntHuang.png" alt="helloAntHuang"></p><p>这就是我们简单设计的静态页面啦，但是只能跑在自己的电脑上或者是把生成的.html发给别人，别人在自己的电脑上打开。</p><p>这时候距离我们建立一个个人博客网站的目标好像差了不是一星半点，若是我要教你自己通过这种方式一点点自己敲出来的话，你应该可以过来和我共事了__(:з」∠)_，怕你们抢我饭碗所以我们这里要借助第三方的框架来进行页面基础架构的搭建！（ 还要啥自行车╭(╯^╰)╮）。</p><p>但是我们要使用第三方插件的话 我们就得有一个nodejs的环境来执行下载的脚本</p><p>这里有个博主早期写的一个<a href="https://blog.csdn.net/Jayhodon/article/details/108308405?spm=1001.2014.3001.5501">nodeJs安装教程</a>可以参考一下。</p><h4 id="2-使用hexo框架进行个人博客搭建"><a href="#2-使用hexo框架进行个人博客搭建" class="headerlink" title="2. 使用hexo框架进行个人博客搭建"></a>2. 使用hexo框架进行个人博客搭建</h4><p>  我们可以在<a href="../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_install.png">hexo官网</a></p><p>  之前我们安装的nodejs就是为了能够执行第一条命令全局安装hexo的插件。</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/vscode_hexo.png" alt="安装Hexo插件"></p><p>按照上述步骤来的话，不出意外就是这样的。</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_init.png" alt="初始化Hexo框架"></p><p>根据提示按住Ctrl点击那个:4000的链接就可以跳转到对应页面<img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_init_page.png" alt="Hexo初始化页面"></p><p>这上面有一个简单介绍，具体的使用说明可以看<a href="https://hexo.io/zh-cn/docs/">官方文档</a></p><p>到这里你就成功的迈出了一大步了，接下来我们就可以去官网的主题Tab栏下面寻找你喜欢的博客主题。可以先在官方文档了解一下hexo的主题。这里博主采用的是 blinkfox 前辈的主题 <a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">教程开源主题介绍</a>。（前辈的使用教程写的很清楚简洁了我这里就不做多余的赘述了 【其实是现在已经快3点了 扛不住了 明晚再肝吧 晚安社会黄 <em><em>(:з」∠)</em></em> 】 ）</p><h4 id="3-挂载hexo主题框架"><a href="#3-挂载hexo主题框架" class="headerlink" title="3. 挂载hexo主题框架"></a>3. 挂载hexo主题框架</h4><p>接上文 我们通过 blinkfox 前辈的开源主题介绍 将下载并解压的hexo_theme主题文件放到blog文件夹下对应的theme文件夹下后，对_config.yml文件进行配置。</p><blockquote><p>这里博主一开始采用的这种方法，但是有些配置项比较麻烦，所以建议使用第二种方法，但是_congfig,yml的配置是一样的流程</p></blockquote><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_theme.png" alt="hexo_theme"></p><blockquote><p>但是用这种直接解压的方式可能会跑步起来 要进行一些其他的配置项 我不嫌麻烦 你们也会嫌麻烦把 （ 好吧我也嫌麻烦 x_x ）</p></blockquote><p>第二种方法就是在blog下的themes文件夹下打开终端，通过拉远程代码库的形式来部署主题文件。<img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_theme_clone.png" alt="拉取hexo主题代码"></p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo-theme-matery.png" alt="hexo-theme-matery"></p><p>成功启动后的页面就是这个样子哒~~~ ，是不是有一种刚刚还是在拧螺丝现在突然发现火箭突然起飞的感觉。</p><h4 id="4-发布个人博文"><a href="#4-发布个人博文" class="headerlink" title="4. 发布个人博文"></a>4. 发布个人博文</h4><p>既然博客的框架已经搭建好了，那么我们得用起来我们得发布文章呀。</p><blockquote><p>hexo新建文章的方式便是通过 hexo new ‘新建博文.md标题’</p></blockquote><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/new_post.png" alt="new_post"></p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_new_post.png" alt="新建的文章"></p><p>但是这样子通过VSCode自带的.md编辑器写博文是一件非常蛋疼的事情，对的没错我们又要借助第三方的工具了，博主这里使用的是 <a href="https://typoraio.cn/">Typora</a> 。我们可以使用类似的第三方Markdown编辑器来撰写我们的博文，然后将编辑排好版的.md文件直接贴到 source\posts 文件夹下再来发布博文 这样的体验会好一点。</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/typora.png" alt="typora"></p><blockquote><p> -–</p><p>title: 新建的博客标题</p><p> date: 2022-07-17 01:29:48</p><p>tags: 博客的类型标题</p><p> -– </p><p>记得将上面这一段加在博文.md文件的最前面哦 这是hexo识别文章的参数</p></blockquote><h4 id="4-博客个人配置化"><a href="#4-博客个人配置化" class="headerlink" title="4. 博客个人配置化"></a>4. 博客个人配置化</h4><p>首先是整个框架的的配置，这些在 blinkfox 前辈的 <a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">教程开源主题介绍 </a>中有一些个性化的配置没有打开 有兴趣的的可以查阅一下 写的已经很详细了 我就不一一赘述了。这里我着重讲一下如何去更改的一个 思路 / 方法 。</p><blockquote><p>我这里采用的是最笨的办法，也是最简单的办法，有更加简单的办法可以交流传阅一下 Thanks♪(･ω･)ﾉ </p></blockquote><ol><li>首先是_config.yml内的一个配置，这里可以更改hexo的一个默认配置。</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_author.png" alt="hexo_author"></p><ol start="2"><li>但是页面上的一些文案之类的要怎么处理呢，这里最简单的一个 方法/ 思路 就是将文案进行复制然后进行全局搜索进行替换。</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_style.png" alt="hexo_style"></p><p>这里我们以 【我的梦想】为例子</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/hexo_theme_config.png" alt="hexo_theme_config"></p><ol start="3"><li>如果博文内含有图片的话要记得将图片文件放到编译生成的public里的img文件夹内部 并在博文.md内修改引用的图片地址。（ 不小心又肝到了4点，这一块后面在写！）</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/change_img.png" alt="修改图片路径"></p><p>这里按照上图 将图片文件放在img文件下 并 更改文件路劲即可。 文件路径不清楚的可自行百度一下（一般按照上面这个路径也不会出错）</p><h4 id="6-部署在GitHub上"><a href="#6-部署在GitHub上" class="headerlink" title="6. 部署在GitHub上"></a>6. 部署在GitHub上</h4><p>在hexo的<a href="https://hexo.io/zh-cn/docs/github-pages">官方文档</a>上有如何部署到GitHub的讲解，有兴趣的可以前往查阅。</p><ol><li>安装Git</li></ol><p>  为了能把本地的项目上传到GitHub上去，我们就会需要使用到 Git — 【分布式版本控制工具】 <a href="https://git-scm.com/download/win">安装链接</a></p><p>  安装的时候选择好对应的位数无脑然后全部无脑默认下一步即可。</p><blockquote><p>   最后一步添加路径的时候选择 Use Git from the Windows Command 以便于我们可以直接在命令行里直接打开git</p></blockquote><p>  安装完后可以在命令行中输入<code>git --version</code> 来验证是否安装成功。</p><ol start="2"><li>登录GitHub并新建一个代码仓库</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/new_repository.png" alt="new_repository"></p><ol start="3"><li>设置github pages</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/init_github_pages.png" alt="初始化github pages"></p><p>选择好后拉到下面 点击 commit change 然后在回去刚刚那个页面就会看到有个提示</p><blockquote><p>  Your site is ready to be published at  【你的个人博客网站地址】</p></blockquote><p>打开这个地址就可以访问到你的个人博客网站啦，接下来就是把我们用hexo框架搭载的博客挂载上去了</p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/github_pages.png" alt="github_pages"></p><ol start="4"><li>连接Github与本地</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/git_bush.png" alt="git_bush"></p><p>首先右键打开git bash，然后输入下面命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"用户名"</span><span class="token function">git</span> config --global user.email <span class="token string">"邮箱"</span></code></pre><p>然后生成密钥SSH key：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"邮箱"</span></code></pre><p>打开<a href="https://link.zhihu.com/?target=http://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>然后在git bash中输入</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub</code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><blockquote><p> Hi Jayhodon! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><ol start="5"><li>将远程代码库的代码下拉至本地</li></ol><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/git_clone.png" alt="获取仓库里的远程代码链接"></p><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/git_bash_clone.png" alt="拉取仓库里的远程代码"></p><blockquote><p>输入 git clone [你复制的SSH链接] </p><p>然后桌面上会出现一个拉下来的文件夹 这时候我们就把blog直接拷贝进去 并用 VSCode 打开这个文件夹</p></blockquote><p><img src="/../images/%E5%9F%BA%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E4%BB%A5%E5%8F%8AGitHub%E6%90%AD%E8%BD%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%20%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89/blog_to_io.png" alt="文件传输"></p><ol start="6"><li>配置_config.yml 下的deploy参数</li></ol><blockquote><p>deploy:</p><p> type: ‘git’</p><p> repository: ‘github 上的 ssh链接’</p><p> branch: main</p></blockquote><ol start="7"><li>将代码部署到github上</li></ol><p>在终端输入以下指令 安装 hexo-deployer-git 插件</p><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><p><strong>此处附加上 hexo 框架常用的指令：</strong></p><table><thead><tr><th align="left">指令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>hexo clean &amp;&amp; hexo g</code></td><td align="left">清除本地项目并重新生成 （重新部署时使用）</td></tr><tr><td align="left"><code>hexo g</code></td><td align="left">重新生成</td></tr><tr><td align="left"><code>Hexo s</code></td><td align="left">开启本地预览</td></tr><tr><td align="left"><code>Hexo d</code></td><td align="left">推送到github</td></tr></tbody></table><p>安装成功后就可以输入命令： hexo g -d  来上传到对应的github地址。到了这里基本上就大功告成了。</p><blockquote><p>hexo clean 最好不要用 x_x </p><p>先用 hexo s 来本地查看 然后使用 hexo g -d 推代码 就够了</p></blockquote><p>安装成功后就可以输入命令： hexo g -d  来上传到对应的github地址。到了这里基本上就大功告成了。</p><h4 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h4><blockquote><p>​    这篇文章的是写给不懂相关计算机知识的小白的个人简易博客网站搭建的教程，通篇博主都以读者的角度出发。个人认为如果这一片文能够让一个小白能够搭建其属于自己的博客网站，那么这篇文就是有意义的。</p><p>​    现在是简单的教授了如何搭建以及发布博文，后续如果博主有时间的话会去更新一下个性化配置（诸如音乐播放器，视频播放器之类的博客小组件）以及使用上的优化（发布博文过于繁琐需要不断提交代码）之类的东西。</p><p>​    这里如果有小伙伴们是哪里卡住了 或者是不懂得都可以给我留言 工作之余我会改进一下 争取让这篇文成为有手就行的个人博客网站搭建教程搭建</p></blockquote><p>【这里着重感谢一下 blinkfox 前辈提供的hexo开源主题框架】</p><p>​    </p><h4 id="参考出处"><a href="#参考出处" class="headerlink" title="参考出处"></a>参考出处</h4><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">Hexo博客主题之hexo-theme-matery的介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用性前端代码片段【Note】</title>
      <link href="/2022/05/29/JavaScript-Codes/"/>
      <url>/2022/05/29/JavaScript-Codes/</url>
      
        <content type="html"><![CDATA[<p>。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 数组去重 * @param {*} arr */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">uniqueArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The first parameter must be an array'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><p>平常我们需要用到一个嵌套多层的对象中某些属性，会将其解构出来使用</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  part1<span class="token punctuation">:</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'零一'</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">23</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token punctuation">{</span> part1<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> age <span class="token punctuation">}</span><span class="token punctuation">,</span> part1 <span class="token punctuation">}</span> <span class="token operator">=</span> objconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>part1<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// {name: "零一", age: 23}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 零一  23</span></code></pre><h4 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> myMoney <span class="token operator">=</span> 1_000_000_000_000    <span class="token comment" spellcheck="true">// 这样写是没问题的，而且数字分割开后也更直观！！</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myMoney<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 1000000000000</span></code></pre><h4 id="英文字符串首字母大写"><a href="#英文字符串首字母大写" class="headerlink" title="英文字符串首字母大写"></a>英文字符串首字母大写</h4><p>Javascript没有内置的首字母大写函数，因此我们可以使用以下代码。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> capitalize <span class="token operator">=</span> str <span class="token operator">=</span><span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">capitalize</span><span class="token punctuation">(</span><span class="token string">"follow for more"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Result: Follow for more</span></code></pre><h4 id="校验数字是奇数还是偶数"><a href="#校验数字是奇数还是偶数" class="headerlink" title="校验数字是奇数还是偶数"></a>校验数字是奇数还是偶数</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> isEven <span class="token operator">=</span> num <span class="token operator">=</span><span class="token operator">></span> num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isEven</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Result: True</span></code></pre><h4 id="求数字的平均值"><a href="#求数字的平均值" class="headerlink" title="求数字的平均值"></a>求数字的平均值</h4><p>使用<code>reduce</code>方法找到多个数字之间的平均值。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> average <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> args<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">/</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token function">average</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: 2.5</span></code></pre><h4 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h4><p>可以使用 <code>split</code>、<code>reverse</code> 和 <code>join</code> 方法轻松反转字符串。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> reverse <span class="token operator">=</span> str <span class="token operator">=</span><span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// Result: 'dlrow olleh'</span></code></pre><h4 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h4><p>可以使用<code>sort</code> 和 <code>random</code> 方法打乱数组</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> shuffleArray <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0.5</span> <span class="token operator">-</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">shuffleArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: [ 1, 4, 3, 2 ]</span></code></pre><h4 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h4><p>使用场景：用于前端生成随机的ID,毕竟现在的Vue和React都需要绑定key</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> str <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 'w5jetivt7e'</span></code></pre><h4 id="保留到小数点以后n位"><a href="#保留到小数点以后n位" class="headerlink" title="保留到小数点以后n位"></a>保留到小数点以后n位</h4><p>使用场景：JS的浮点数超长，有时候页面显示时需要保留2位小数</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 保留小数点以后几位，默认2位</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">cutNumber</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> no <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> number <span class="token operator">!=</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        number <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">Number</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span>no<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="cleanObject-去除对象中value为空的属性"><a href="#cleanObject-去除对象中value为空的属性" class="headerlink" title="cleanObject - 去除对象中value为空的属性"></a>cleanObject - 去除对象中value为空的属性</h4><p>去除对象中value为空(null,undefined,’’)的属性,举个栗子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">const</span> isFalsy <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token punctuation">:</span> <span class="token operator">!</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> isVoid <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>  value <span class="token operator">===</span> undefined <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> cleanObject <span class="token operator">=</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Object.assign({}, object)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>object <span class="token punctuation">}</span><span class="token punctuation">;</span>  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> value <span class="token operator">=</span> result<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isVoid</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">delete</span> result<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> res<span class="token operator">=</span><span class="token function">cleanObject</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    name<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span>    pageSize<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">,</span>    page<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"res"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//输入{page:1,pageSize:10}</span></code></pre><h3 id="颜色相关"><a href="#颜色相关" class="headerlink" title="颜色相关"></a>颜色相关</h3><h4 id="颜色RGB转十六进制"><a href="#颜色RGB转十六进制" class="headerlink" title="颜色RGB转十六进制"></a>颜色RGB转十六进制</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> rgbToHex <span class="token operator">=</span> <span class="token punctuation">(</span>r<span class="token punctuation">,</span> g<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"#"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>g <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">rgbToHex</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Result: #0033ff</span></code></pre><h4 id="生成随机十六进制颜色"><a href="#生成随机十六进制颜色" class="headerlink" title="生成随机十六进制颜色"></a>生成随机十六进制颜色</h4><p>可以使用 <code>Math.random</code> 和 <code>padEnd</code> 属性生成随机的十六进制颜色。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> randomHex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token template-string"><span class="token string">`#</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0xffffff</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">randomHex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: #92b008</span></code></pre><h3 id="日期相关"><a href="#日期相关" class="headerlink" title="日期相关"></a>日期相关</h3><h4 id="检查日期是否合法"><a href="#检查日期是否合法" class="headerlink" title="检查日期是否合法"></a>检查日期是否合法</h4><p>使用以下代码段检查给定日期是否有效。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> isDateValid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">!</span>Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token operator">...</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">isDateValid</span><span class="token punctuation">(</span><span class="token string">"December 17, 1995 03:24:00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: true</span></code></pre><h4 id="查找日期位于一年中的第几天"><a href="#查找日期位于一年中的第几天" class="headerlink" title="查找日期位于一年中的第几天"></a>查找日期位于一年中的第几天</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> dayOfYear <span class="token operator">=</span> <span class="token punctuation">(</span>date<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>      Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>date <span class="token operator">-</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dayOfYear</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: 272</span></code></pre><h4 id="计算2个日期之间相差多少天"><a href="#计算2个日期之间相差多少天" class="headerlink" title="计算2个日期之间相差多少天"></a>计算2个日期之间相差多少天</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> dayDif <span class="token operator">=</span> <span class="token punctuation">(</span>date1<span class="token punctuation">,</span> date2<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>date1<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> date2<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">86400000</span><span class="token punctuation">)</span>    <span class="token function">dayDif</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">"2020-10-21"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">"2021-10-22"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Result: 366</span></code></pre><h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h4 id="从-URL-获取查询参数"><a href="#从-URL-获取查询参数" class="headerlink" title="从 URL 获取查询参数"></a>从 URL 获取查询参数</h4><p>可以通过传递 <code>window.location</code> 或原始 URL <code>goole.com?search=easy&amp;page=3</code>轻松地从 url 检索查询参数</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> getParameters <span class="token operator">=</span> <span class="token punctuation">(</span>URL<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  URL <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>    <span class="token string">'{"'</span> <span class="token operator">+</span>      <span class="token function">decodeURI</span><span class="token punctuation">(</span>URL<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"?"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token string">"/g, '\\"</span>'<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&amp;/g</span><span class="token punctuation">,</span> <span class="token string">'","'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/=/g</span><span class="token punctuation">,</span> <span class="token string">'":"'</span><span class="token punctuation">)</span> <span class="token operator">+</span>      <span class="token string">'"}'</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>URL<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">getParameters</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Result: { search : "easy", page : 3 }</span></code></pre><p>或者更为简单的：</p><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>search<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Result: { search : "easy", page : 3 }</span></code></pre><h4 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h4><p>可以使用 <code>window.scrollTo(0, 0)</code> 方法自动滚动到顶部。将 <code>x</code> 和 <code>y</code> 都设置为 0。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> goToTop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> window<span class="token punctuation">.</span><span class="token function">scrollTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">goToTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="休眠指定毫秒数"><a href="#休眠指定毫秒数" class="headerlink" title="休眠指定毫秒数"></a>休眠指定毫秒数</h4><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 休眠xxxms * @param {Number} milliseconds */</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用方式</span><span class="token keyword">const</span> fetchData<span class="token operator">=</span><span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="复制内容到剪贴板"><a href="#复制内容到剪贴板" class="headerlink" title="复制内容到剪贴板"></a>复制内容到剪贴板</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">copyToBoard</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'textarea'</span><span class="token punctuation">)</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>    element<span class="token punctuation">.</span>value <span class="token operator">=</span> value    element<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">execCommand</span><span class="token punctuation">(</span><span class="token string">'copy'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        document<span class="token punctuation">.</span><span class="token function">execCommand</span><span class="token punctuation">(</span><span class="token string">'copy'</span><span class="token punctuation">)</span>        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><blockquote><p> 原理：</p><ol><li>创建一个textare元素并调用select()方法选中</li><li>document.execCommand(‘copy’)方法，拷贝当前选中内容到剪贴板。</li></ol></blockquote><p>借助<code>navigator.clipboard.writeText</code>可以很容易的讲文本复制到剪贴板</p><blockquote><p>规范要求在写入剪贴板之前使用 Permissions API 获取“剪贴板写入”权限。但是，不同浏览器的具体要求不同，因为这是一个新的API。有关详细信息，请查看compatibility table and Clipboard availability in Clipboard。</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> copyToClipboard <span class="token operator">=</span> <span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> navigator<span class="token punctuation">.</span>clipboard<span class="token punctuation">.</span><span class="token function">writeText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">copyToClipboard</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="获取用户选择的文本"><a href="#获取用户选择的文本" class="headerlink" title="获取用户选择的文本"></a>获取用户选择的文本</h4><p>使用内置的<code>getSelection</code> 属性获取用户选择的文本。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> getSelectedText <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> window<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getSelectedText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="获取浏览器Cookie的值"><a href="#获取浏览器Cookie的值" class="headerlink" title="获取浏览器Cookie的值"></a>获取浏览器Cookie的值</h4><p>通过<code>document.cookie</code> 来查找<code>cookie</code>值</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> cookie <span class="token operator">=</span> name <span class="token operator">=</span><span class="token operator">></span> <span class="token template-string"><span class="token string">`; </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>document<span class="token punctuation">.</span>cookie<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`; </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cookie</span><span class="token punctuation">(</span><span class="token string">'_ga'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Result: "GA1.2.1929736587.1601974046"</span></code></pre><h4 id="清除全部Cookie"><a href="#清除全部Cookie" class="headerlink" title="清除全部Cookie"></a>清除全部Cookie</h4><p>通过使用<code>document.cookie</code>访问cookie并将其清除，可以轻松清除网页中存储的所有cookie。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> clearCookies <span class="token operator">=</span> document<span class="token punctuation">.</span>cookie<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cookie <span class="token operator">=</span><span class="token operator">></span> document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> cookie<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^ +/</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/=.*/</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`=;expires=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUTCString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;path=/`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><h4 id="获取文件后缀名"><a href="#获取文件后缀名" class="headerlink" title="获取文件后缀名"></a>获取文件后缀名</h4><p>使用场景：上传文件判断后缀名</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 获取文件后缀名 * @param {String} filename */</span> <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getExt</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> filename <span class="token operator">==</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> filename            <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'filename must be a string type'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="对象转化为FormData对象"><a href="#对象转化为FormData对象" class="headerlink" title="对象转化为FormData对象"></a>对象转化为FormData对象</h4><p>使用场景：上传文件时我们要新建一个FormData对象，然后有多少个参数就append多少次，使用该函数可以简化逻辑</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 对象转化为formdata * @param {Object} object */</span> <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getFormData</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> value <span class="token operator">=</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>subValue<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>                formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token template-string"><span class="token string">`[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">]`</span></span><span class="token punctuation">,</span> subValue<span class="token punctuation">)</span>            <span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> formData<span class="token punctuation">}</span></code></pre><p>使用方式：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> req<span class="token operator">=</span><span class="token punctuation">{</span>    file<span class="token punctuation">:</span>xxx<span class="token punctuation">,</span>    userId<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>    phone<span class="token punctuation">:</span><span class="token string">'15198763636'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token function">getFormData</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="下载一个excel文档"><a href="#下载一个excel文档" class="headerlink" title="下载一个excel文档"></a>下载一个excel文档</h4><p>同时适用于word,ppt等浏览器不会默认执行预览的文档,也可以用于下载后端接口返回的流数据。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//下载一个链接 </span><span class="token keyword">function</span> <span class="token function">download</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>        name<span class="token operator">=</span>link<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> eleLink <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>    eleLink<span class="token punctuation">.</span>download <span class="token operator">=</span> name    eleLink<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>    eleLink<span class="token punctuation">.</span>href <span class="token operator">=</span> link    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">)</span>    eleLink<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下载excel</span><span class="token function">download</span><span class="token punctuation">(</span><span class="token string">'http://111.229.14.189/file/1.xlsx'</span><span class="token punctuation">)</span></code></pre><h5 id="在浏览器中自定义下载一些内容"><a href="#在浏览器中自定义下载一些内容" class="headerlink" title="在浏览器中自定义下载一些内容"></a>在浏览器中自定义下载一些内容</h5><p>场景：我想下载一些DOM内容，我想下载一个JSON文件</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 浏览器下载静态文件 * @param {String} name 文件名 * @param {String} content 文件内容 */</span><span class="token keyword">function</span> <span class="token function">downloadFile</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> name <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The first parameter name is a must'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> content <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The second parameter content is a must'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>content <span class="token keyword">instanceof</span> <span class="token class-name">Blob</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        content <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>content<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> link <span class="token operator">=</span> URL<span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>    <span class="token function">download</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>使用方式：</p><pre class=" language-js"><code class="language-js"><span class="token function">downloadFile</span><span class="token punctuation">(</span><span class="token string">'1.txt'</span><span class="token punctuation">,</span><span class="token string">'lalalallalalla'</span><span class="token punctuation">)</span><span class="token function">downloadFile</span><span class="token punctuation">(</span><span class="token string">'1.json'</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'hahahha'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h5 id="下载后端返回的流"><a href="#下载后端返回的流" class="headerlink" title="下载后端返回的流"></a>下载后端返回的流</h5><pre class=" language-js"><code class="language-js"> <span class="token function">download</span><span class="token punctuation">(</span><span class="token string">'http://111.229.14.189/gk-api/util/download?file=1.jpg'</span><span class="token punctuation">)</span> <span class="token function">download</span><span class="token punctuation">(</span><span class="token string">'http://111.229.14.189/gk-api/util/download?file=1.mp4'</span><span class="token punctuation">)</span></code></pre><h5 id="提供一个图片链接，点击下载"><a href="#提供一个图片链接，点击下载" class="headerlink" title="提供一个图片链接，点击下载"></a>提供一个图片链接，点击下载</h5><p>图片、pdf等文件，浏览器会默认执行预览，不能调用download方法进行下载，需要先把图片、pdf等文件转成blob，再调用download方法进行下载，转换的方式是使用axios请求对应的链接</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//可以用来下载浏览器会默认预览的文件类型，例如mp4,jpg等</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token comment" spellcheck="true">//提供一个link，完成文件下载，link可以是  http://xxx.com/xxx.xls</span><span class="token keyword">function</span> <span class="token function">downloadByLink</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span>fileName<span class="token punctuation">)</span><span class="token punctuation">{</span>    axios<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        url<span class="token punctuation">:</span> link<span class="token punctuation">,</span>        responseType<span class="token punctuation">:</span> <span class="token string">'blob'</span> <span class="token comment" spellcheck="true">//关键代码，让axios把响应改成blob</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">const</span> link<span class="token operator">=</span>URL<span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>        <span class="token function">download</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> fileName<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：会有同源策略的限制，需要配置转发</p></blockquote><h3 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h3><h4 id="解决ios-audio无法自动播放、循环播放的问题"><a href="#解决ios-audio无法自动播放、循环播放的问题" class="headerlink" title="解决ios audio无法自动播放、循环播放的问题"></a>解决ios audio无法自动播放、循环播放的问题</h4><p><code>ios</code>手机在使用<code>audio</code>或者<code>video</code>播放的时候，个别机型无法实现自动播放，可使用下面的代码<code>hack</code>。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 解决ios audio无法自动播放、循环播放的问题</span><span class="token keyword">var</span> music <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'video'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'touchstart'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>state<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        music<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        state<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"WeixinJSBridgeReady"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    music<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//循环播放</span>music<span class="token punctuation">.</span>onended <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    music<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    music<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="检查用户的设备是否处于暗模式"><a href="#检查用户的设备是否处于暗模式" class="headerlink" title="检查用户的设备是否处于暗模式"></a>检查用户的设备是否处于暗模式</h4><p>使用以下代码检查用户的设备是否处于暗模式。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> isDarkMode <span class="token operator">=</span> window<span class="token punctuation">.</span>matchMedia <span class="token operator">&amp;&amp;</span> window<span class="token punctuation">.</span><span class="token function">matchMedia</span><span class="token punctuation">(</span><span class="token string">'(prefers-color-scheme: dark)'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>matches    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isDarkMode<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Result: True or False</span></code></pre><h2 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h2><h3 id="Css相关"><a href="#Css相关" class="headerlink" title="Css相关"></a>Css相关</h3><h4 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h4><p>这是一个<code>css</code>属性，我一般称之为<code>css</code>表达式。可以计算<code>css</code>的值。最有趣的是他可以计算不同单位的差值。很好用的一个功能，缺点是不容易阅读。接盘侠没办法一眼看出<code>20px</code>是啥。</p><pre class=" language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">25%</span> - <span class="token number">20</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="使用css写出一个三角形角标"><a href="#使用css写出一个三角形角标" class="headerlink" title="使用css写出一个三角形角标"></a>使用css写出一个三角形角标</h4><p>元素宽高设置为<code>0</code>，通过<code>border</code>属性来设置，让其它三个方向的<code>border</code>颜色为透明或者和背景色保持一致，剩余一条<code>border</code>的颜色设置为需要的颜色。</p><pre class=" language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">5</span>px solid #transparent<span class="token punctuation">;</span>    <span class="token property">border-top-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><p>我一般只使用两种方式<code>定位</code>或者<code>flex</code>，我觉得够用了。</p><pre class=" language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>父级控制子集居中</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>    <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="css一行文本超出…"><a href="#css一行文本超出…" class="headerlink" title="css一行文本超出…"></a>css一行文本超出…</h4><pre class=" language-css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span><span class="token property">text-overflow</span><span class="token punctuation">:</span>ellipsis<span class="token punctuation">;</span><span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span></code></pre><h4 id="多行文本超出显示…"><a href="#多行文本超出显示…" class="headerlink" title="多行文本超出显示…"></a>多行文本超出显示…</h4><pre class=" language-css"><code class="language-css"><span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span><span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span><span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span></code></pre><h4 id="IOS手机容器滚动条滑动不流畅"><a href="#IOS手机容器滚动条滑动不流畅" class="headerlink" title="IOS手机容器滚动条滑动不流畅"></a>IOS手机容器滚动条滑动不流畅</h4><pre class=" language-css"><code class="language-css"><span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token property">-webkit-overflow-scrolling</span><span class="token punctuation">:</span> touch<span class="token punctuation">;</span></code></pre><h4 id="修改滚动条样式"><a href="#修改滚动条样式" class="headerlink" title="修改滚动条样式"></a>修改滚动条样式</h4><p>隐藏<code>div</code>元素的滚动条</p><pre class=" language-css"><code class="language-css"><span class="token selector">div<span class="token pseudo-element">::-webkit-scrollbar</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p> div::-webkit-scrollbar 滚动条整体部分div::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）</p><p>div::-webkit-scrollbar-track 滚动条的轨道</p><p>div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。</p><p>div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分</p><p>div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</p><p>div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件</p><p><strong>注意此方案有兼容性问题</strong>，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用overflow-hidden截掉滚动条部分。暴力且直接。</p></blockquote><h4 id="隐藏页面元素"><a href="#隐藏页面元素" class="headerlink" title="隐藏页面元素"></a>隐藏页面元素</h4><blockquote><p> display-none: 元素不会占用空间，在页面中不显示，子元素也不会显示。</p><p>opacity-0: 元素透明度将为<code>0</code>，但元素仍然存在，绑定的事件仍旧有效仍可触发执行。</p><p>visibility-hidden：元素隐藏，但元素仍旧存在，占用空间，页面中无法触发该元素的事件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 个人知识库 </tag>
            
            <tag> JavaScript-Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jayhodon&#39;s Demo</title>
      <link href="/2022/03/03/Jayhodon-s-Demo/"/>
      <url>/2022/03/03/Jayhodon-s-Demo/</url>
      
        <content type="html"><![CDATA[<h3 id="将canvas所绘制的图像转成图片格式保存到本地"><a href="#将canvas所绘制的图像转成图片格式保存到本地" class="headerlink" title="将canvas所绘制的图像转成图片格式保存到本地"></a>将canvas所绘制的图像转成图片格式保存到本地</h3><ol><li><p><strong>首先base64图片格式一般都是以下形式：</strong></p><!-- ‘data:image/jpeg;base64, […base64编码]’ --></li><li><p><strong>当我们在使用canvas绘图完成后可使用 .toDataURL( )来得到所绘制图像的base64编码数据形式</strong><img src="/../images/Jayhodon-s-Demo/baseToImg_1.jpg" alt="toDataURL"></p></li><li><p><strong>当然也可以将图片格式转成base64格式</strong><img src="/../images/Jayhodon-s-Demo/baseToImg_2.jpg" alt="imgToBase"></p></li><li><p>输出指定文件夹处理<br>首先我们需要使用引入第三方工具类，即是</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span>‘fs’<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre></li></ol><p><img src="/../images/Jayhodon-s-Demo/baseToImg_3.jpg" alt="Save"></p><h3 id="Css-content-visibility属性-虚拟滚动"><a href="#Css-content-visibility属性-虚拟滚动" class="headerlink" title="Css: content-visibility属性 [虚拟滚动]"></a>Css: content-visibility属性 [虚拟滚动]</h3><blockquote><p>content-visibility是一个css属性，它控制一个元素是否呈现其内容，能让用户潜在地控制元素的呈现。用户可以使用它跳过元素的呈现(包括布局和绘制)，直到用户需要为止，让页面的初始渲染得到极大的提升。</p></blockquote><p><strong>content-visibility</strong> 属性有三个可选值:</p><blockquote><ul><li><p>visible: 默认值。对布局和呈现不会产生什么影响。</p></li><li><p>hidden: 元素跳过其内容的呈现。用户代理功能（例如，在页面中查找，按Tab键顺序导航等）不可访问已跳过的内容，也不能选择或聚焦。类似于对其内容设置了display: none属性。</p></li><li><p>auto: 对于用户可见区域的元素，浏览器会正常渲染其内容；对于不可见区域的元素，浏览器会暂时跳过其内容的呈现，等到其处于用户可见区域时，浏览器在渲染其内容。</p></li></ul></blockquote><ul><li><strong>ps</strong>: content-visibility是chrome85今年新增的特性，所以目前兼容性还不高，但是相信兼容性的问题在不久的将来会得到解决。</li></ul><p>​    当元素的部分内容如<code>&lt;img /&gt;</code>标签这种，元素的高度是有图片内容决定的，因此在这种情况下，如果使用<code>content-visibility</code>，则可见视图外的img初始未渲染，高度为0，随着滚动条向下滑动，页面高度增加，会导致滚动条的滚动有问题。</p><p>​    为了解决此问题，如果在已知元素高度的情况下，可以使用<code>contains-intrinsic-size</code>属性，为上面的card添加：<code>contains-intrinsic-size：312px;</code>，这会给内容附一个初始高度值。（如果高度不固定也可以附一个大致的初始高度值，会使滚动条问题相对减少）。</p><pre class=" language-css"><code class="language-css">    <span class="token selector">&lt;style type="text/css">      <span class="token class">.card</span> </span><span class="token punctuation">{</span>        <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>        <span class="token property">content-visibility</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>        <span class="token property">contain-intrinsic-size</span><span class="token punctuation">:</span> <span class="token number">312</span>px<span class="token punctuation">;</span> // 添加此行      <span class="token punctuation">}</span>    &lt;/style></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法相关</title>
      <link href="/2021/09/18/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/09/18/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-反抖节流："><a href="#1-反抖节流：" class="headerlink" title="1. 反抖节流："></a>1. 反抖节流：</h2><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>点击了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>次<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>debounce<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> debounce <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>throttle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> throttle <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">function</span> <span class="token function">calCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"count"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            count<span class="token operator">++</span>            ele<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count        <span class="token punctuation">}</span>        <span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token keyword">await</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>                timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                    fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">await</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token keyword">await</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> preTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">-</span>preTime<span class="token operator">>=</span><span class="token keyword">await</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span>                    preTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> btn_1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"debounce"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_1<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token function">debounce</span><span class="token punctuation">(</span>calCount<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> btn_2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"throttle"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        btn_2<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span>calCount<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><h2 id="2-深浅拷贝"><a href="#2-深浅拷贝" class="headerlink" title="2. 深浅拷贝"></a>2. 深浅拷贝</h2><blockquote><ol><li>深拷贝和浅拷贝值针对 Object 和 Array 这样的复杂类型 </li><li> a 和 b 指向了同一块内存，所以修改其中任意一个值，另外一个值也会随 之变化，这是浅拷贝 </li><li>a 和 b 指向同一块内存，但是修改其中任意一个值，另外一个调用的变量， 不会受到影响，这是深拷贝 </li><li> 浅拷贝:“Object.assign()”方法用于将所有可枚举的属性的值从一个或 多个源对象复制到目标对象，它将返回目标对象 </li><li> 深拷贝：JSON.parse( )和 JSON.stringify( )给了我们一个基本的解决办 法。但是函数不能被正确处理</li></ol></blockquote><pre class=" language-js"><code class="language-js">        <span class="token comment" spellcheck="true">//浅拷贝</span>        <span class="token keyword">function</span> <span class="token function">shallowCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">var</span> target <span class="token operator">=</span> obj<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array<span class="token operator">?</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> target        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*浅拷贝实现方式：            Object.assign()            ...(扩展运算符)            concat（数组方法）            lodash clone        */</span>        <span class="token comment" spellcheck="true">/*深拷贝实现方式：            $.extend        */</span>        <span class="token comment" spellcheck="true">//深拷贝</span>        <span class="token comment" spellcheck="true">//乞丐版</span>        <span class="token keyword">var</span> newObj <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>someObj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//面试版</span>        <span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//判断是否是简单数据类型，</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">==</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//复杂数据类型</span>                <span class="token keyword">var</span> result <span class="token operator">=</span> obj<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"object"</span> <span class="token operator">?</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//简单数据类型 直接 == 赋值</span>                <span class="token keyword">var</span> result <span class="token operator">=</span> obj<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><h2 id="3-ajax"><a href="#3-ajax" class="headerlink" title="3. ajax"></a>3. ajax</h2><p>ajax 是通过 XMLHttpRequest 对象实现的，这个对象有很多的属性和事件:</p><blockquote><p>xhr 具有一个 open 方法，这个方法的作用类似于初始化，并不会发起真正的请求<br>open 方法具有 5 个参数，但是常用的是前 3 个<br>method： 请求方式 —— get / post<br>url：请求的地址<br>async：是否异步请求，默认为 true（异步）<br>xhr.open(method, url, async)</p></blockquote><blockquote><p>send 方法发送请求，并接受一个可选参数<br>当请求方式为 post 时，可以将请求体的参数传入<br>当请求方式为 get 时，可以不传或传入 null<br>不管是 get 还是 post，参数都需要通过 encodeURIComponent 编码后拼接<br>xhr.send(data)</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>手写ajax<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'/api'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// xhr.readyState 的各个状态</span>        <span class="token comment" spellcheck="true">// 0：未初始化，还没有调用send()方法</span>        <span class="token comment" spellcheck="true">// 1：载入，已调用send()方法，正在发送请求</span>        <span class="token comment" spellcheck="true">// 2：载入完成，send()方法执行完成，已经接收到全部响应内容</span>        <span class="token comment" spellcheck="true">// 3：交互，正在解析响应内容</span>        <span class="token comment" spellcheck="true">// 4：完成，响应内容解析完成，可以再客户端调用</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span><span class="token string">'/api'</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> postData<span class="token operator">=</span><span class="token punctuation">{</span>        userName<span class="token punctuation">:</span><span class="token string">'Jayhodon'</span><span class="token punctuation">,</span>        password<span class="token punctuation">:</span><span class="token string">'Jayhodon'</span>    <span class="token punctuation">}</span>    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>postData<span class="token punctuation">)</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>通过 Promise 方式实现回调:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> ajax <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> url <span class="token operator">=</span> options<span class="token punctuation">.</span>url        <span class="token keyword">const</span> method <span class="token operator">=</span> options<span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">toLocaleLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">'get'</span>        <span class="token keyword">const</span> <span class="token keyword">async</span> <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token operator">!=</span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">// default is true</span>        <span class="token keyword">const</span> data <span class="token operator">=</span> options<span class="token punctuation">.</span>data        <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>timeout <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>timeout <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> options<span class="token punctuation">.</span>timeout        <span class="token punctuation">}</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            xhr<span class="token punctuation">.</span>ontimeout <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> reject <span class="token operator">&amp;&amp;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'请求超时'</span><span class="token punctuation">)</span>            xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        resolve <span class="token operator">&amp;&amp;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        reject <span class="token operator">&amp;&amp;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            xhr<span class="token punctuation">.</span>onerror <span class="token operator">=</span> err <span class="token operator">=</span><span class="token operator">></span> reject <span class="token operator">&amp;&amp;</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>             <span class="token keyword">let</span> paramArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">let</span> encodeData            <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 参数拼接需要通过 encodeURIComponent 进行编码</span>                    paramArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'='</span> <span class="token operator">+</span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>                <span class="token punctuation">}</span>                encodeData <span class="token operator">=</span> paramArr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">===</span> <span class="token string">'get'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// 检测 url 中是否已存在 ? 及其位置</span>                <span class="token keyword">const</span> index <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> url <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'?'</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">!==</span> url<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> url <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'&amp;'</span>                  <span class="token comment" spellcheck="true">// 拼接 url</span>                url <span class="token operator">+</span><span class="token operator">=</span> encodeData            <span class="token punctuation">}</span>             xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token keyword">async</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">===</span> <span class="token string">'get'</span><span class="token punctuation">)</span> xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// post 方式需要设置请求头</span>                xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span><span class="token string">'application/x-www-form-urlencoded;charset=UTF-8'</span><span class="token punctuation">)</span>                xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>encodeData<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><p>使用方式:</p><pre class=" language-js"><code class="language-js"><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    url<span class="token punctuation">:</span> <span class="token string">'your request url'</span><span class="token punctuation">,</span>    method<span class="token punctuation">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>    <span class="token keyword">async</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    timeout<span class="token punctuation">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        aaa<span class="token punctuation">:</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    res <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'请求成功: '</span> <span class="token operator">+</span> res<span class="token punctuation">)</span><span class="token punctuation">,</span>    err <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'请求失败: '</span> <span class="token operator">+</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>axios拦截器</p><h2 id="4-十种经典排序算法"><a href="#4-十种经典排序算法" class="headerlink" title="4. 十种经典排序算法"></a>4. 十种经典排序算法</h2><p><a href="https://juejin.cn/post/6921496910080114702">转自：你能手撕10种经典排序算法吗？</a></p><h2 id="5-图片懒加载"><a href="#5-图片懒加载" class="headerlink" title="5. 图片懒加载"></a>5. 图片懒加载</h2><p>图片懒加载理解：</p><p>​        由于商城图片过多时，就会给图片加一个懒加载的缓冲效 果。当图片进入可视化区域的时候才会加载，否则图片只是一个空标签。这样可 以优化页面渲染速度，提升用户体验。 </p><p>思路：</p><p>​        将页面中的所有 img 属性 src 用 data-src 代替，当页面滚动至此图 片出现在可视区域时，用 js 取到该图片的 data-src 值赋给 src。 </p><p>所用知识点： </p><blockquote><p>​        浏览器可视区域的宽高：</p><p>​        js :  document.body.clientWidth/clientHeight </p><p>​        jquery: var windHeight = $(window).width()/$(window).height(); </p><p>​        获取滚动条相对于顶部的高度:</p><p>​         js : document.body.scrollTop;</p><p>​         jquery : var scrollTop=$(window).scrollTop; </p><p>​        获得元素对于浏览器顶部的高度:</p><p>​         js : DOM 元素.offsetTop; </p><p>​         jquery: var imgTop=$(‘img’).offset().top </p><p>​        判断元素是否出现在浏览器的可视化区域内: </p><p>​        元素相对于顶部的高度 - 浏览器可视化区域的高度 &lt; 小于滚动条 到顶部的高度 </p><p>​        成立就代表出现 : 不成立就没出现 </p><p>​        怎样排除首屏的图片 </p><p>​        元素到顶部距离 - 浏览器的可视化高度 &gt; 0 排除已加载的图片 $(this).attr(‘src’) != $(this).attr(‘data-src’) //排除已加载 的图片</p></blockquote><p><strong>offsetWidth/offsetHeight、clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</strong></p><blockquote><p>offfsetWidth、offsetHeight 返回值包含 content+padding+border，效 果与 e.getBoundingClientRect（）相同 </p><p>clientWidth、clientHieight 返回值值包含 content+padding，如果有滚 动条，也不包含滚动条 </p><p>scrollWidth、scrollHeight 返回值包含 content+padding+溢出内容的尺 寸</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 算法相关 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识体系</title>
      <link href="/2021/07/10/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
      <url>/2021/07/10/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前端知识体系"><a href="#前端知识体系" class="headerlink" title="前端知识体系"></a>前端知识体系</h1><blockquote><p>​    这篇文章的目标主要是梳理出一个较为完整的个人前端向知识体系。文章主要是以<strong>从输入URL到页面加载</strong>这个问题所梳理的文章，由于这个问题所涵盖的面十分的广阔，可以说是非常适合个人前端知识体系的搭建了。</p></blockquote><h2 id="搭建基础架构"><a href="#搭建基础架构" class="headerlink" title="搭建基础架构"></a>搭建基础架构</h2><p>对于个人知识体系的搭建，最为重要的一点便是对基础架构的搭建，有了一个大体的架构后才方便填充细节。以下便是<strong>从输入URL到页面加载</strong>的一个基础架构：</p><blockquote><ol><li><p>从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</p></li><li><p>开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</p></li><li><p>从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</p></li><li><p>后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</p></li><li><p>单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</p></li><li><p>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</p></li><li><p>CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</p></li><li><p>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p></li><li><p>其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</p></li></ol></blockquote><h3 id="从浏览器接收url到开启网络请求线程"><a href="#从浏览器接收url到开启网络请求线程" class="headerlink" title="从浏览器接收url到开启网络请求线程"></a>从浏览器接收url到开启网络请求线程</h3><h4 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h4><p>由于浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）</p><blockquote><p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li></ul></blockquote><h4 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h4><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p><p><img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/kernel-thread.jpg" alt="内核线程"></p><p>可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的</p><h4 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h4><p>输入URL后，会进行解析（URL的本质就是统一资源定位符）</p><p>URL一般包括几大部分：</p><blockquote><p><code>protocol</code>，协议头，譬如有http，ftp等</p><p><code>host</code>，主机域名或IP地址</p><p><code>port</code>，端口号</p><p><code>path</code>，目录路径</p><p><code>query</code>，即查询参数</p><p><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</p></blockquote><h4 id="网络请求都是单独的线程"><a href="#网络请求都是单独的线程" class="headerlink" title="网络请求都是单独的线程"></a>网络请求都是单独的线程</h4><p>每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p><h3 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" class="headerlink" title="开启网络线程到发出一个完整的http请求"></a>开启网络线程到发出一个完整的http请求</h3><h4 id="DNS查询得到IP"><a href="#DNS查询得到IP" class="headerlink" title="DNS查询得到IP"></a>DNS查询得到IP</h4><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p><blockquote><ul><li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host</li><li>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP</li></ul></blockquote><p>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</p><p>而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化</p><h4 id="tcp-ip请求"><a href="#tcp-ip请求" class="headerlink" title="tcp/ip请求"></a>tcp/ip请求</h4><p>http的本质就是 tcp/ip 请求,且tcp/ip协议是传输层面向连接的一个安全可靠的连接协议。tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输，这里需要了解3次握手规则建立连接以及断开连接时的四次挥手。</p><h4 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h4><p><img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-message-format.jpg" alt="tcp报文格式"></p><blockquote><p>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p><p>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p><p>​    URG：紧急指针（urgent pointer）有效。</p><p>​    ACK：确认序号有效。</p><p>​    PSH：接收方应该尽快将这个报文交给应用层。</p><p>​    RST：重置连接。</p><p>​    SYN：发起一个新连接。</p><p>​    FIN：释放一个连接。</p></blockquote><p>需要注意的是：</p><p>（A）不要将确认序号Ack与标志位中的ACK搞混了。</p><p>（B）确认方Ack=发起方Req+1，两端配对。</p><h4 id="三次握手的步骤："><a href="#三次握手的步骤：" class="headerlink" title="三次握手的步骤："></a><strong>三次握手的步骤：</strong></h4><p>采用三次握手建立一个安全可靠的连接.</p><blockquote><p>客户端：hello，你是server么？<br>服务端：hello，我是server，你是client么<br>客户端：yes，我是client</p></blockquote><p>具体过程如下:</p><p>建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p><p><img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-handshake.jpg" alt="3次握手"></p><blockquote><p>第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； </p><p>SYN：同步序列编号(Synchronize Sequence Numbers)</p><p>第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； </p><p>第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.</p></blockquote><p><strong>为什么需要三次握手，是为了解决下列的一个问题:</strong></p><blockquote><p>​       client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了， 以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。</p><p>​    假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生</p></blockquote><p>建立连接成功后，接下来就正式传输数据</p><p>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）</p><h4 id="四次挥手的步骤："><a href="#四次挥手的步骤：" class="headerlink" title="四次挥手的步骤："></a><strong>四次挥手的步骤：</strong></h4><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</p><blockquote><p>主动方：我已经关闭了向你那边的主动通道了，只能被动接收了<br>被动方：收到通道关闭的信息，但是我的工作可能还没完成<br>被动方：ok 我的工作完成了，我这边向你的主动通道也关闭了<br>主动方：最后收到数据，之后双方无法通信</p></blockquote><p>具体过程如下:</p><p><img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-wave.jpg" alt="4次挥手"></p><p>​    由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p><blockquote><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p></blockquote><p>​    上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：<img src="/../images/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/tcp-wave-meanwhile.jpg" alt="tcp4次挥手-同时"></p><p>​    如果有大量的连接，每次在连接、关闭时都要三次握手，四次挥手，会很明显会造成性能低下，因此，HTTP有一种叫做keep connection的机制，它可以在传输数据后仍然保持连接，当客户端再次获取数据时，直接使用刚刚空闲下的连接而无需再次握手</p><p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p><blockquote><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p></blockquote><p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p><blockquote><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></blockquote><p><strong>tcp/ip的并发限制</strong></p><p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）</p><p>而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求</p><p>所以针对这个瓶颈，又出现了很多的资源优化方案</p><h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。</p><p>get会产生一个tcp数据包，post两个</p><p>具体就是：</p><ul><li>get请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li><li>post请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>，</li></ul><p>浏览器再发送<code>data</code>，服务器响应200（返回数据）。</p><p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）</p><h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><p>其实就是一个概念：</p><p><strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong></p><p>简括就是：</p><p><strong>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong></p><p>当然，服务端的接收就是反过来的步骤</p><p>五层因特网协议栈其实就是：</p><blockquote><p>1.应用层(dns,http) DNS解析成IP并发送http请求</p><p>2.传输层(tcp,udp) 建立tcp连接（三次握手）</p><p>3.网络层(IP,ARP) IP寻址</p><p>4.数据链路层(PPP) 封装成帧</p><p>5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</p></blockquote><p>当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。</p><p>OSI七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p><blockquote><p>表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</p><p>会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 个人知识库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人随笔（持续更新）</title>
      <link href="/2021/05/28/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2021/05/28/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该博文是博主本人自己归纳整合的一些面经以及一些零零散散的基础知识点，一方面方便自己以后复习查看，另一方面也是做一个简单的分享。</p></blockquote><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript:"></a>JavaScript:</h2><h3 id="Jsonp原理："><a href="#Jsonp原理：" class="headerlink" title="Jsonp原理："></a>Jsonp原理：</h3><p> Jsonp的全称为：json with padding ，意为填充式的json。</p><blockquote><p>1、Ajax直接请求普通文件存在跨域无权限访问的问题，不管是静态页面、动态页面、web服务，只要是跨域请求，一律不准。</p><p>2、不过我们发现，web页面调用js文件则不受跨域的影响（不仅如此，我们还发现凡是拥有“src”这个属性的标签都拥有跨域的能力，比如&lt;\script&gt;、&lt;\img&gt;、&lt;\iframe&gt;）。</p><p>3、于是可以判断，当前阶段如果想通过纯web端跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理。</p><p>4、恰巧我们知道有一种叫做JSON的<strong>纯字符数据格式</strong>可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据。</p><p>5、这样，解决方案就呼之欲出了，web服务端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件，显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装进去。</p><p>6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来很像ajax，但其实并不一样。</p><p>7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，简称<strong>JSONP</strong>。<u>该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名包裹在JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</u></p></blockquote><p>可以说Jsonp就是为了跨域而生的了。</p><h3 id="Jsonp的实现："><a href="#Jsonp的实现：" class="headerlink" title="Jsonp的实现："></a>Jsonp的实现：</h3><h4 id="1、远程调用其它服务器上的js文件（跨域成功）"><a href="#1、远程调用其它服务器上的js文件（跨域成功）" class="headerlink" title="1、远程调用其它服务器上的js文件（跨域成功）"></a>1、远程调用其它服务器上的js文件（跨域成功）</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://remoteserver.com/remote.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h4 id="2、远程调用js"><a href="#2、远程调用js" class="headerlink" title="2、远程调用js"></a>2、远程调用js</h4><p>在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">var</span> localHandler <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：'</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://remoteserver.com/remote.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>remote.js文件代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token function">localHandler</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"result"</span><span class="token operator">:</span><span class="token string">"我是远程js带来的数据"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行之后，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。</p><p>这样一来跨域远程获取数据的目的基本实现了，但是又一个问题出现了，怎么让远程js知道它应该调用的本地函数呢？</p><h4 id="3、动态生成js脚本"><a href="#3、动态生成js脚本" class="headerlink" title="3、动态生成js脚本"></a>3、动态生成js脚本</h4><p>只要服务端提供的js脚本是动态生成的，这样调用者就可以传一个参数过去告诉服务端，“我想要一段调用xxx函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。</p><p>看jsonp.html页面的代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 得到航班信息查询结果后的回调函数</span>    <span class="token keyword">var</span> flightHandler <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'你查询的航班结果是：票价 '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>price <span class="token operator">+</span> <span class="token string">' 元，'</span> <span class="token operator">+</span> <span class="token string">'余票 '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>tickets <span class="token operator">+</span> <span class="token string">' 张。'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）</span>    <span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建script标签，设置其属性</span>    <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把script标签加入head，此时调用开始</span>    document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'head'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>利用编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。</p><p>我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。<br>OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">flightHandler</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token string">"code"</span><span class="token punctuation">:</span> <span class="token string">"CA1998"</span><span class="token punctuation">,</span>    <span class="token string">"price"</span><span class="token punctuation">:</span> <span class="token number">1780</span><span class="token punctuation">,</span>    <span class="token string">"tickets"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="4、封装代码"><a href="#4、封装代码" class="headerlink" title="4、封装代码"></a>4、封装代码</h4><p>jQuery如何实现jsonp调用？</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span>jquery<span class="token punctuation">.</span>min<span class="token punctuation">.</span>js"<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>   <span class="token function">jQuery</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">"get"</span><span class="token punctuation">,</span>        <span class="token keyword">async</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        url<span class="token punctuation">:</span> <span class="token string">"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998"</span><span class="token punctuation">,</span>                       dataType<span class="token punctuation">:</span> <span class="token string">"jsonp"</span><span class="token punctuation">,</span>        jsonp<span class="token punctuation">:</span> <span class="token string">"callback"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)             </span>        jsonpCallback<span class="token punctuation">:</span><span class="token string">"flightHandler"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据</span>        success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'您查询到航班信息：票价： '</span> <span class="token operator">+</span> json<span class="token punctuation">.</span>price <span class="token operator">+</span> <span class="token string">' 元，余票： '</span> <span class="token operator">+</span> json<span class="token punctuation">.</span>tickets <span class="token operator">+</span> <span class="token string">' 张。'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span><span class="token punctuation">,</span>                     error<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                     <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'fail'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>jquery在处理jsonp类型的ajax时，自动帮你生成回调函数并把数据取出来供success属性方法来调用。</p><h4 id="ajax和jsonp的区别："><a href="#ajax和jsonp的区别：" class="headerlink" title="ajax和jsonp的区别："></a>ajax和jsonp的区别：</h4><p>1、ajax和jsonp这两种技术在调用方式上看起来很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jQuery把jsonp作为ajax的一种形式进行了封装。</p><p>2、但ajax和jsonp其实本质上是不同的东西，ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加。</p><h3 id="原型与原型链："><a href="#原型与原型链：" class="headerlink" title="原型与原型链："></a>原型与原型链：</h3><p>ES6之前中并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实</p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/prototype.png" alt="原型与原型链"></p><h4 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（<code>prototype</code>）</h4><ul><li><p>JS所有的函数都有prototype属性，只有函数才有</p></li><li><p>其属性和方法都能被构造函数实例化的对象所共同访问</p></li><li><p><code>constructor</code>存在于每个函数的<code>prototype</code>属性中，其指向了函数本身</p></li></ul><h4 id="原型链-proto-）"><a href="#原型链-proto-）" class="headerlink" title="原型链 (_proto_）"></a>原型链 (<code>_proto_</code>）</h4><ul><li><p>JS中的对象会有个<code>_proto_</code>属性，指向了创建他的构造函数的<code>prototype</code>,而函数比较特殊也有这个属性</p></li><li><p>当JS搜索引擎查找对象中的属性或者方法时，如果在该对象上没有该属性和方法的话，会通过原型链一层一层往上查找</p></li><li><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向下搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>run <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'running'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ➀ 每个对象都有一个__proto__属性，并且指向他的prototype原型对象。</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>__proto__<span class="token operator">===</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">// ➁ 每个构造函数都有一个prototype原型对象,prototype原型对象的constructor等于构造函数本身</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token operator">==</span>Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">//原型相关的知识考点一般就是围绕以下：</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token operator">===</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>当每创建一个Person构造函数时，在Person构造函数中，为每一个对象都添加了一个run方法，也就是说构造函数每执行一次就会创建一个新的run方法。</p><p>一个还好，如果创建了一百个实例，一千个甚至上万个呢，这时候就体现出原型的好处了，我们可以把run方法放到构造函数的prototype上，这时候只需要创建一个，而且每一个实例都可以访问到。</p><p>prototype相当于所有实例对象可以访问的一个公共容器，实例对象的<code>__prorunto__</code>指向构造函数的<code>prototype</code>，从而实现<strong>继承</strong>。</p><p><strong>经典图：</strong></p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/classic-prototype.jpg" alt="原型经典图"></p><h4 id="如何准确判断一个变量是数组类型"><a href="#如何准确判断一个变量是数组类型" class="headerlink" title="如何准确判断一个变量是数组类型?"></a>如何准确判断一个变量是数组类型?</h4><p>instanceof 用于判断引用类型属于哪个构造函数的方法 </p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true </span><span class="token keyword">typeof</span> arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//object typeof 是无法判断是否为数组的</span></code></pre><p>instanceof 是用来判断实例的_proto_和构造函数的 prototype 是否指 向一个原型对象，</p><p>但是有一个弊端，只要出现在一条原型链上的，都会返回 true（每个函数都有 prototype，每个对象都有一个内部属性__proto__，其指向它的原型对象。原 型对象也是一个对象，所以也有__proto__） </p><p>这个时候要用实例__proto__.constructor 更加严谨 </p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr instanseof Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true console.log(arr.__proto__.constructor === Array) //true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr<span class="token punctuation">.</span>construct <span class="token operator">==</span> Array<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span> arr <span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="new-操作符在创建实例的时候经历了哪几个阶段"><a href="#new-操作符在创建实例的时候经历了哪几个阶段" class="headerlink" title="new 操作符在创建实例的时候经历了哪几个阶段"></a>new 操作符在创建实例的时候经历了哪几个阶段</h4><p>new 创建了一个对象，共经历了 4 个阶段： </p><ol><li>创建一个空对象 </li><li>设置原型链 </li><li>让实例化对象中的 this 指向对象，并执行函数体 </li><li>判断实例化对象的返回值类型</li></ol><h4 id="类型的判断方法"><a href="#类型的判断方法" class="headerlink" title="类型的判断方法"></a>类型的判断方法</h4><p><strong>1、typeof</strong></p><blockquote><p>未定义、未初始化：返回 <code>&quot;undefined&quot;</code></p><p>布尔值：返回 <code>&quot;boolean&quot;</code></p><p>字符串：返回 <code>&quot;string&quot;</code></p><p>数值(包括NAN)：返回 <code>&quot;number&quot;</code></p><p>对象、null：返回 <code>&quot;object&quot;</code>， null 表示空对象指针</p><p>函数：返回 <code>&quot;function&quot;</code></p><p><strong>注意</strong>：<code>typeof</code>可以判断基本类型，无法判断对象的类型或者null</p></blockquote><p><strong>2、instanceof</strong></p><blockquote><p>如果变量是引用类型，可以使用instanceof判断，检测基本类型时，会返回false。</p><p>原理：判断变量的原型链上是否有构造函数的prototype属性</p><p><strong>注意：空对象{}的判断问题</strong>        //true</p></blockquote><p><strong>3、Object.prototype.toString</strong></p><blockquote><p>所有的数据类型都可以使用此方法进行检测，且非常精准。如：</p><p>Object.prototype.toString.call(obj) === ‘[object Object]’</p></blockquote><h4 id="了解更多相关："><a href="#了解更多相关：" class="headerlink" title="了解更多相关："></a>了解更多相关：</h4><p>ES5继承实现、ES6类实现、typeof&amp;&amp;instanceof原理：<a href="https://juejin.cn/post/6844903984335945736">https://juejin.cn/post/6844903984335945736</a></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h3 id="This"><a href="#This" class="headerlink" title="This:"></a>This:</h3><p><strong>1. 默认绑定与隐式绑定</strong></p><p>让我们看看下面这个例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token string">"bar1"</span><span class="token punctuation">;</span> <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span>bar<span class="token punctuation">:</span> <span class="token string">"bar2"</span><span class="token punctuation">,</span> foo<span class="token punctuation">:</span> foo<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">var</span> o3 <span class="token operator">=</span> <span class="token punctuation">{</span>bar<span class="token punctuation">:</span> <span class="token string">"bar3"</span><span class="token punctuation">,</span> foo<span class="token punctuation">:</span> foo<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// "bar1" – 默认绑定</span>o2<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// "bar2" – 隐式绑定</span>o3<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// "bar3" – 隐式绑定</span></code></pre><p>foo()这种调用方法，就是默认绑定。如果在非严格模式下，this就是全局对象，浏览器当中就是window。而如果在严格模式（use strict）下，this就会是undefined。</p><p>之所以这是默认绑定，因为foo的调用不属于任何人，前面没有任何限定条件。这是最简单的绑定。</p><p>o2.foo()和o3.foo()这两种调用方法，都是隐式绑定。Foo是作为o2和o3的方法而调用的，那么谁调用foo，this就指向谁。在上面的例子中，o2.foo()中的this指向o2，因此this.bar就是o2当中的bar: “bar2”；同理，o3.foo()打印出来的就是o3中的”bar3”。</p><p><strong>2. 显式绑定</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token string">"bar1"</span><span class="token punctuation">;</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>bar<span class="token punctuation">:</span> <span class="token string">"bar2"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// "bar1"   默认绑定</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// "bar2"  显式绑定，使用obj作为"this" </span></code></pre><p>如果foo是通过call、apply或者bind调用的，那么这种调用就是显式绑定。这种绑定中,this的指向就是这三个函数中传递的第一个参数。</p><p><strong>3. 关键字new绑定</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token string">"baz"</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> baz<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token string">"bar"</span><span class="token punctuation">;</span> <span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>如果把new这个关键字放在一个函数调用的前面，JS编译器会做这四件事情：</p><blockquote><ol><li>创建一个新的空的对象</li><li>把这个对象链接到原型对象上</li><li>这个对象被绑定为this</li><li>如果这个函数不返回任何东西，那么就会默认return this</li></ol></blockquote><p>上面的例子，最终会输出undefined undefined。这是因为baz这个变量并没有bar这个属性，而baz此时只被定义，没有被赋值，因此baz也是undefined。</p><p><strong>4. 箭头函数</strong></p><p>箭头函数会无视以上所有的规则，this的值就是函数创建时候所在的lexical scope中的this，而和调用方式无关。可以对比下面两个例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 输出undefined</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 输出10</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面没有使用箭头函数的例子当中，setTimeout内部的函数是被global调用的，而global没有age这个属性，因此输出undefined。</p><p>第二个例子使用了箭头函数，this就会使用lexical scope中的this，就是Person，因此输出10。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'Nicolas'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Smiley'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sayName<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sayName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">*</span><span class="token comment" spellcheck="true">// 第二次输出*</span><span class="token punctuation">}</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">*</span><span class="token comment" spellcheck="true">// 第一次输出*</span></code></pre><p>第一次输出的是Person, Smiley。第二次输出的结果是window，Nicolas。尽管setTimeout是在构造函数中定义的，但是调用的时候，是在window中调用。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Smiley"</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> sayNameCopy <span class="token operator">=</span> person<span class="token punctuation">.</span>sayName<span class="token punctuation">;</span><span class="token function">sayNameCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>答案是window和undefined。因为，这个时候符合默认绑定的规则。</p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/this.jpg" alt="this指向"></p><p><strong>5. 绑定优先级</strong></p><p>如果多重绑定规格都适用，那么绑定规则的优先级顺序是这样的：</p><blockquote><ol><li>箭头函数</li><li>关键字new调</li><li>显式绑定</li><li>隐式绑定</li><li>默认绑定</li></ol></blockquote><p>箭头函数优先级最高，会无视2-5绑定规则。而默认绑定优先级最低，只有其他绑定都不使用的时候，才会使用默认绑定。</p><h3 id="Promise："><a href="#Promise：" class="headerlink" title="Promise："></a>Promise：</h3><blockquote><p>Promise是异步编程的一种解决方案，它比传统的解决方案–回调函数和事件–更合理且更加强大，它最早是由社区提出并实现，后面ES6将其写进了语言标准，统一了用法，也提供了Promise。</p></blockquote><h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><h5 id="1-创建Promise实例："><a href="#1-创建Promise实例：" class="headerlink" title="1.创建Promise实例："></a>1.创建Promise实例：</h5><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">/*异步操作成功*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li>Promise构造函数接受一个函数作为参数，该函数接受两个参数，分别是resolve和reject，它们是两个函数，是由javascript引擎提供，不用自己部署。</li><li>resolve作用是将Promise对象状态由‘未完成’变为‘成功’，也就是Pending -&gt; Fulfilled，在异步操作成功时调用，并将异步操作的结果作为参数传递出去，而rejected函数则是将Promise对象状态由‘未完成’变为‘失败’，也就是Pending -&gt; Rejected，在异步操作失败时调用，并将异步操作的结果作为参数传递出去。</li><li>Promise 可以分为四个状态：<ul><li> Pending：初始状态，异步操作仍在进行中。</li><li> Fulfilled：操作成功，它调用<code>.then</code>回调，例如<code>.then(onSuccess)</code>。</li><li> Rejected: 操作失败，它调用<code>.catch</code>或<code>.then</code>的第二个参数（如果有）。 例如<code>.catch(onError)</code>或<code>.then(..., onError)</code>。</li><li> <strong>Settled</strong>：这是 promise 的最终状态。promise 已经死亡了，没有别的办法可以解决或拒绝了。 <code>.finally</code>方法被调用。</li></ul></li><li><strong>一旦状态改变就不会再发生变化</strong>（两种状态改变：成功或失败）</li></ul><h5 id="2-Promise的方法："><a href="#2-Promise的方法：" class="headerlink" title="2.Promise的方法："></a>2.Promise的方法：</h5><blockquote><p>then方法: 这个方法是定义在原型对象Promise.prototype上的，它的作用是为Promise实例添加状态改变时的回调函数。它返回的是一个新的Promise实例，注意，不是原来的那个Promise实例，因此可以采用链式写法，即then方法后面再调用一个then方法。<br>Promise实例生成后，可用then方法分别指定两种状态回调函数，then方法可用接受两个回调函数作为参数：<br>（1）  Promise对象状态改为Resolved时调用（必须）<br>（2） Promise对象状态改为Rejected时调用（可选）<br>（3） 基本用法：</p></blockquote><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"finished"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这段代码定义了一个函数sleep，调用后，等待了指定参数（500）毫秒后执行then中的函数。值得注意的是，Promise新建后就会立即执行。</p><blockquote><p>catch方法: 这个方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p><p>我们可以使用<code>then</code>函数的第二个参数来处理错误。 但是，请注意，<code>catch</code>将不再执行。</p></blockquote><pre class=" language-jsx"><code class="language-jsx"><span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">'/posts.json'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>posts<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'发生错误！'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数，如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误，另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p><p>如果Promise状态已经变成resolved，再抛出错误是无效的。Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止，也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数）就使用catch方法</p><blockquote><p>finally方法: <code>finally</code>方法只在 Promise 状态是 <code>settled</code> 时才会调用。</p><p>如果你希望一段代码即使出现错误始终都需要执行，那么可以在<code>.catch</code>之后使用<code>.then</code>。</p><p>或者可以使用<code>.finally</code>关键字:</p></blockquote><pre class=" language-js"><code class="language-js">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'always called'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="3-Promise-类方法："><a href="#3-Promise-类方法：" class="headerlink" title="3 Promise 类方法："></a>3 Promise 类方法：</h5><p>我们也可以直接使用 <code>Promise</code> 对象中四种静态方法。</p><ul><li>Promise.all</li><li>Promise.reject</li><li>Promise.resolve</li><li>Promise.race</li></ul><blockquote><p>Promise.resolve 和 Promise.reject这两个是帮助函数，可以让 Promise 立即解决或拒绝。可以传递一个参数，作为下次 <code>.then</code> 的接收：</p></blockquote><blockquote><p>使用 <code>Promise.all</code> 并行执行多个 Promise ,通常Promise 是一个接一个地依次执行的，但是你也可以并行使用它们。假设是从两个不同的api中轮询数据。如果它们不相关，我们可以使用<code>Promise.all()</code>同时触发这两个请求。</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'promise.all'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>results <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Done! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>results<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'promise.all'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>解决这些 Promise 要花多长时间？ 5秒？ 1秒？ 还是2秒？</p><blockquote><p>Promise.race(iterable) 方法: 返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'promise.race'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>results <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Done! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>results<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'promise.race'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出 <code>b</code>。使用 <code>Promise.race</code>，最先执行完成就会是最后的返回结果。</p><p>在某些情况下，它可以派上用场，比如计时请求或批量处理请求数组。</p><pre class=" language-js"><code class="language-js">Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://slowwly.robertomurray.co.uk/delay/3000/url/https://api.jsonbin.io/b/5d1fb4dd138da811182c69af'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'request timeout'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="关于Promise-的问题："><a href="#关于Promise-的问题：" class="headerlink" title="关于Promise 的问题："></a>关于Promise 的问题：</h4><p><strong>1.async await：</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a<span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> b<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> a  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p1 -> undefined -> end -> p2 -> p3 -> p4 -> p{pending} -> after1</span></code></pre><blockquote><p>第一个输出 p1，是因为 Promise 里的方法立即执行。接着调用 resolve，只不过 then 里的方法等下一个周期</p><p>第二个输出 undefined，是因为立即执行执行 a 内部的方法，先 console.log(a)，但此时的 a 还没赋值给左边的变量，所以只能是 undefined。然后 await b 就得等下一个周期执行了。</p><p>第三个输出 end，自然不意外。</p><p>接着输出 p2，p3，p4，是因为 await b 等待他执行完了，才轮到 a 内部继续执行。</p><p>输出 Promise { pending }，事件都进入了循环，a 肯定已经被赋值成了 Promise 对象。所以第二遍 console.log(a)，自然就输出这个了。</p><p>输出 after1 不奇怪。</p><p>await a 时，a 是必须等待 Promise 的状态从 pending 到 fullfilled 才会继续往下执行，可 a 的状态是一直得不到更改的，所以无法执行下面的逻辑。只要在 await a 上面加一行 resolve() 就能让后面的 after 2 得到输出</p></blockquote><p><strong>2..如何限制并行 Promise？</strong></p><p>要做到这一点，我们需要以某种方式限制<code>Promise.all</code>。假设你有许多并发请求要执行。 如果使用 <code>Promise.all</code> 是不好的（特别是在API受到速率限制时）。 因此，我们需要一个方法来限制 Promise 个数， 我们称其为<code>promiseAllThrottled</code>。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// simulate 10 async tasks that takes 5 seconds to complete.</span><span class="token keyword">const</span> requests <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`exec'ing task #</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`task #</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">promiseAllThrottled</span><span class="token punctuation">(</span>requests<span class="token punctuation">,</span> <span class="token punctuation">{</span> concurrency<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Oops something went wrong'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以上代码将并发限制为并行执行的<code>3</code>个任务。</p><p>实现<code>promiseAllThrottled </code>一种方法是使用<code>Promise.race</code>来限制给定时间的活动任务数量。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * Similar to Promise.all but a concurrency limit * * @param {Array} iterable Array of functions that returns a promise * @param {Object} concurrency max number of parallel promises running */</span><span class="token keyword">function</span> <span class="token function">promiseAllThrottled</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> <span class="token punctuation">{</span> concurrency <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> promises <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>current <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// return if done</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> iterable<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// take one promise from collection</span>    <span class="token keyword">const</span> promise <span class="token operator">=</span> iterable<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> activatedPromise <span class="token operator">=</span> <span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// add promise to the final result array</span>    promises<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>activatedPromise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// add current activated promise to queue and remove it when done</span>    <span class="token keyword">const</span> autoRemovePromise <span class="token operator">=</span> activatedPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// remove promise from the queue when done</span>      <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>autoRemovePromise<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// add promise to the queue</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>autoRemovePromise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// if queue length >= concurrency, wait for one promise to finish before adding more.</span>    <span class="token keyword">const</span> readyForMore <span class="token operator">=</span> queue<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> concurrency <span class="token operator">?</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> readyForMore<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">enqueue</span><span class="token punctuation">(</span>current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>promiseAllThrottled</code>一对一地处理 Promises 。 它执行<code>Promises</code>并将其添加到队列中。 如果队列小于并发限制，它将继续添加到队列中。 达到限制后，我们使用<code>Promise.race</code>等待一个承诺完成，因此可以将其替换为新的承诺。 这里的技巧是，promise 自动完成后会自动从队列中删除。 另外，<strong>我们使用 <code>race</code> 来检测promise 何时完成，并添加新的 promise 。</strong></p><p>3.Promise 解决的痛点是什么？</p><p>1）回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象，是为解决异步操作函数里的嵌套回调（callback hell）问题，代码臃肿，可读性差，只能在回调里处理异常</p><p>2）<u>promise可以支持多个并发的请求，获取并发请求中的数据</u></p><p>3）<u>promise可以解决可读性的问题，异步的嵌套带来的可读性的问题，它是由异步的运行机制引起的，这样的代码读起来会非常吃力</u></p><p>4）promise可以解决信任问题，对于回调过早、回调过晚或没有调用和回调次数太少或太多，由于promise只能决议一次，决议值只能有一个，决议之后无法改变，任何then中的回调也只会被调用一次，所以这就保证了Promise可以解决信任问题</p><p>4.Promise 在事件循环中的执行过程是怎样的？</p><p>1）事件循环</p><blockquote><p>从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。由于主线程不断的重复获得消息、执行消息、再取消息、再执行</p></blockquote><p>2）promise的事件循环</p><blockquote><p>Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环</p></blockquote><h3 id="事件模型："><a href="#事件模型：" class="headerlink" title="事件模型："></a>事件模型：</h3><p>事件模型可以分为三种：</p><p><strong>原始事件模型（DOM0级）</strong></p><p>事件绑定监听函数比较简单, 有两种方式：</p><ol><li>HTML代码中直接绑定</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fun()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ol start="2"><li>通过JS代码绑定</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'.btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> fun<span class="token punctuation">;</span></code></pre><p>DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行。<strong>只支持冒泡，不支持捕获</strong>。同一个类型的事件只能绑定一次，当希望为同一个元素绑定多个同类型事件的时候是不被允许的，后绑定的事件会覆盖之前的事件。</p><p>删除 DOM0 级事件处理程序只要将对应事件属性置为null即可</p><p><strong>标准事件模型（DOM2级）</strong></p><p>在该事件模型中，一次事件共有三个过程:</p><blockquote><p>事件捕获阶段：事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</p><p>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</p><p>事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</p></blockquote><ol><li>事件绑定监听函数的方式如下:</li></ol><pre class=" language-js"><code class="language-js"><span class="token function">addEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> useCapture<span class="token punctuation">)</span></code></pre><ol start="2"><li>事件移除监听函数的方式如下:</li></ol><pre class=" language-js"><code class="language-js"><span class="token function">removeEventListener</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> useCapture<span class="token punctuation">)</span></code></pre><p>可以在一个<code>DOM</code>元素上绑定多个事件处理器，各自并不会冲突</p><p><strong>IE事件模型（基本不用）</strong></p><p>IE事件模型共有两个过程:</p><blockquote><p>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</p><p>事件冒泡阶段：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</p></blockquote><p>事件绑定监听函数的方式如下:</p><pre class=" language-js"><code class="language-js"><span class="token function">attachEvent</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> handler<span class="token punctuation">)</span></code></pre><p>事件移除监听函数的方式如下:</p><pre class=" language-js"><code class="language-js"><span class="token function">detachEvent</span><span class="token punctuation">(</span>eventType<span class="token punctuation">,</span> handler<span class="token punctuation">)</span></code></pre><h3 id="事件循环："><a href="#事件循环：" class="headerlink" title="事件循环："></a>事件循环：</h3><h4 id="浏览器中的事件循环："><a href="#浏览器中的事件循环：" class="headerlink" title="浏览器中的事件循环："></a>浏览器中的事件循环：</h4><blockquote><p>JavaScript 是单线程的语言，所谓单线程无非就是同步队列和异步队列，js代码是自上向下执行的，在主线程中立即执行的就是同步任务，比如简单的逻辑操作及函数，而异步任务不会立马立马执行，会挪步放到到异步队列中，而不同的异步操作添加到任务队列的时机也不同，比如onclick（事件）, setTimeout（计时器）, ajax ，promise处理的方式都不同，总的说就是<strong>等待主线程中任务全部完成后，再回来把异步队列中任务放到主程序中运行，这样反复的循环，就是事件循环。</strong></p><p>这些异步操作是由浏览器内核来执行的,浏览器内核上包含 3 种 webAPI,分别是 DOM Binding(DOM绑定)、network(网络请求)、timer(定时器)模块</p></blockquote><p>按照这种分类方式:JS 的执行机制是</p><blockquote><p>首先判断 js 代码是同步还是异步,不停的检查调用栈中是否有任务需要执行,如果没有,就检查任务队列,从中弹出一个任务,放入栈中,如此往复循环,要是同步就进入主进程,异步就进入事件表</p><p>异步任务在事件表中注册函数,当满足触发条件后,被推入事件队列</p><p>同步任务进入主线程后一直执行,直到主线程空闲时,才会去事件队列中查看是否有可执行的异步任务,如果有就推入主进程中</p><p>以上三步循环执行,这就是事件循环(event loop),它是连接任务队列和控制调用栈的</p></blockquote><p>在一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务）。</p><p><strong>macro-task大概包括：</strong></p><blockquote><p>script(整体代码)、setTimeout、setInterval、setImmediate、I/O、UI render</p></blockquote><p><strong>micro-task大概包括:</strong></p><blockquote><p>process.nextTick、Promise、Async/Await(实际就是promise)、MutationObserver(html5新特性)</p></blockquote><p><img src="https://pic4.zhimg.com/v2-0d7af3f483aa991d41dd1f3ba7bac36f_b.webp" alt="img"></p><p>总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动</span><span class="token comment" spellcheck="true">// script start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout</span></code></pre><p>代码分析：</p><blockquote><p>执行代码，输出script start。</p><p>执行async1(),会调用async2(),然后输出async2 end,<u>此时将会保留async1函数的上下文，然后跳出async1函数。</u></p><p>遇到setTimeout，产生一个宏任务</p><p>执行Promise，输出Promise。遇到then，产生第一个微任务</p><p>继续执行代码，输出script end</p><p>代码逻辑执行完毕(当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出promise1，该微任务遇到then，产生一个新的微任务</p><p>执行产生的微任务，输出promise2,当前微任务队列执行完毕。执行权回到async1</p><p>执行await,实际上会产生一个promise返回，即</p><p>let promise_ = new Promise((resolve,reject){ resolve(undefined)})<br>执行完成，执行await后面的语句，输出async1 end</p><p>最后，执行下一个宏任务，即执行setTimeout，输出setTimeout</p><p>注意<br><strong>新版的chrome浏览器中不是如上打印的，因为chrome优化了,await变得更快了,输出为:</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout</span></code></pre></blockquote><p>如果await后面跟的是一个异步函数的调用，比如上面的代码，将代码改成这样：</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end1'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>输出为：<span class="token comment" spellcheck="true">// script start => async2 end => Promise => script end => async2 end1 => promise1 => promise2 => async1 end => setTimeout</span></code></pre><p>此时执行完awit并不先把await后面的代码注册到微任务队列中去，而是执行完await之后，直接跳出async1函数，执行其他代码。然后遇到promise的时候，把promise.then注册为微任务。其他代码执行完毕后，需要回到async1函数去执行剩下的代码，然后把await后面的代码注册到微任务队列当中，<strong>注意此时微任务队列中是有之前注册的微任务的</strong>。所以这种情况会先执行async1函数之外的微任务(promise1,promise2)，然后才执行async1内注册的微任务(async1 end). 可以理解为，这种情况下，await 后面的代码会在本轮循环的最后被执行。</p><h4 id="node-中的事件循环："><a href="#node-中的事件循环：" class="headerlink" title="node 中的事件循环："></a>node 中的事件循环：</h4><pre class=" language-js"><code class="language-js">┌───────────────────────┐┌─<span class="token operator">></span>│        timers         ││  └──────────┬────────────┘│  ┌──────────┴────────────┐│  │     I<span class="token operator">/</span>O callbacks     ││  └──────────┬────────────┘│  ┌──────────┴────────────┐│  │     idle<span class="token punctuation">,</span> prepare     ││  └──────────┬────────────┘      ┌───────────────┐│  ┌──────────┴────────────┐      │   incoming<span class="token punctuation">:</span>   ││  │         poll          │<span class="token operator">&lt;</span>──connections───     ││  └──────────┬────────────┘      │   data<span class="token punctuation">,</span> etc<span class="token punctuation">.</span>  ││  ┌──────────┴────────────┐      └───────────────┘│  │        check          ││  └──────────┬────────────┘│  ┌──────────┴────────────┐└──┤    close callbacks    │   └───────────────────────┘</code></pre><ol><li><p>node 的事件循环的阶段顺序为：</p><blockquote><p>输入数据阶段(incoming data)-&gt;轮询阶段(poll)-&gt;检查阶段(check)-&gt;关闭事件回调阶段(close callback)-&gt;定时器检测阶段(timers)-&gt;I/O事件回调阶段(I/O callbacks)-&gt;闲置阶段(idle, prepare)-&gt;轮询阶段…<br>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。</p></blockquote></li><li><p>阶段概述：</p></li></ol><blockquote><p>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。</p><p>I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。</p><p>闲置阶段(idle, prepare)：仅系统内部使用。</p><p>轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</p><p>检查阶段(check)：setImmediate() 回调函数在这里执行</p><p>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)。</p></blockquote><p>日常开发中的绝大部分异步任务都是在 poll、check、timers 这3个阶段处理的。</p><p><strong>timers:</strong></p><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</p><p><strong>poll:</strong></p><p>poll 是一个至关重要的阶段，poll 阶段的执行逻辑流程图如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X2pwZy8yd1Y3TGljTDc2Mll4VmlhR3NFbmhSOUtpYmJHNnlRcXBjRWo0VlBGcE9PdnpOYW51S1NnMURvNWVKQlV2SVNvQnNpYVNPN3hTM2liZWpkSGJ6NDhseGRXN3hnLzY0MA?x-oss-process=image/format,png" alt="img"></p><blockquote><p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。</p><p>如果没有定时器, 会去看回调函数队列。</p><p>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</p><p>如果 poll 队列为空时，会有两件事发生</p><p>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</p><p>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。</p></blockquote><p><strong>check:</strong></p><p>check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</p><p><strong>process.nextTick:</strong></p><p>process.nextTick 是一个独立于 eventLoop 的任务队列。</p><p>在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。</p><h4 id="node-版本差异说明"><a href="#node-版本差异说明" class="headerlink" title="node 版本差异说明:"></a>node 版本差异说明:</h4><p><u><em>总的变化一句话来说就是，如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就会立刻执行对应的微任务队列。</em></u></p><p><strong>timers 阶段的执行时机变化:</strong></p><pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span>    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span>    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre><p>如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为timer1=&gt;promise1=&gt;timer2=&gt;promise2</p><p>如果是 node10 及其之前版本要看第一个定时器执行完，第二个定时器是否在完成队列中.</p><p>如果是第二个定时器还未在完成队列中，最后的结果为timer1=&gt;promise1=&gt;timer2=&gt;promise2</p><p>如果是第二个定时器已经在完成队列中，则最后的结果为timer1=&gt;timer2=&gt;promise1=&gt;promise2</p><p><strong>check 阶段的执行时机变化：</strong></p><pre class=" language-js"><code class="language-js"><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate2'</span><span class="token punctuation">)</span>    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise resolve'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>js<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果是 node11 后的版本，会输出immediate1=&gt;immediate2=&gt;promise resolve=&gt;immediate3=&gt;immediate4</p><p>如果是 node11 前的版本，会输出immediate1=&gt;immediate2=&gt;immediate3=&gt;immediate4=&gt;promise resolve</p><p><strong>nextTick 队列的执行时机变化：</strong></p><pre class=" language-js"><code class="language-js"><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout2'</span><span class="token punctuation">)</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next tick'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果是 node11 后的版本，会输出timeout1=&gt;timeout2=&gt;next tick=&gt;timeout3=&gt;timeout4</p><p>如果是 node11 前的版本，会输出timeout1=&gt;timeout2=&gt;timeout3=&gt;timeout4=&gt;next tick</p><h4 id="node-和-浏览器-eventLoop的主要区别："><a href="#node-和-浏览器-eventLoop的主要区别：" class="headerlink" title="node 和 浏览器 eventLoop的主要区别："></a>node 和 浏览器 eventLoop的主要区别：</h4><p>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。</p><h4 id="了解更多："><a href="#了解更多：" class="headerlink" title="了解更多："></a>了解更多：</h4><p><a href="https://juejin.cn/post/6844903955286196237">彻底吃透 JavaScript 执行机制</a></p><h3 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h3><p>官方的各种定义引用:</p><blockquote><p>MDN: 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p></blockquote><blockquote><p>红宝书: 闭包是指有权访问另外一个函数作用域中的变量的函数。</p></blockquote><blockquote><p>现代JavaScript教程: 闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。</p></blockquote><p><strong>简单来说就是我在写代码时候我们决定了这些变量的访问权限也就是<a href="https://juejin.im/post/6889538437783748621">词法作用域</a>。然而我们可以用些手段(闭包)如<code>return</code> 一个函数。这样即使这个function在当前词法作用域外执行，也能访问原来定义时词法作用域内的变量，（间接地访问了这些变量）。</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> bar<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2       这就是闭包的效果。</span></code></pre><p>按照词法作用域来说：<code>baz</code>的词法作用域是全局的，外部不能访问foo内部作用域的变量 <code>a</code>，但是 <code>a</code>确实被正常打印了。而函数 <code>bar()</code> 的词法作用域能够访问 <code>foo()</code> 的内部作用域。将 <code>bar</code> 所引用的函数对象本身当作返回值。 在 <code>foo()</code> 执行后， 其返回值(也就是内部的 <code>bar()</code>函数) 赋值给变量 <code>baz</code> 并调用 <code>baz()</code>， 实际上只是通过不同的标识符引用调用了内部的函数 <code>bar()</code>。bar() 显然可以被正常执行。</p><p>但是在这个例子中，它在自己<strong>定义的词法作用域以外</strong> 的地方执行了。</p><p>在 <code>foo()</code> 执行后，通常会期待 <code>foo()</code> 的整个内部作用域都被销毁，因为我们知道引擎有<strong>垃圾回收机制</strong>用来释放不再使用的内存空间。由于看上去 <code>foo()</code> 的内容不会再被使用，所以很自然地会考虑对其进行回收。</p><p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域?原来是 <code>bar()</code> 本身在使用。拜 <code>bar()</code> 所声明的位置所赐，它拥有涵盖 <code>foo()</code> 内部作用域的闭包，使得该作用域能够一直存活，以供 <code>bar()</code> 在之后任何时间进行引用。bar() 依然持有对该作用域的引用。</p><p>这样做的话一是<strong>可以读取函数内部的变量</strong>，二是<strong>可以让这些变量的值始终保存在内存中</strong>。</p><p><strong>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>正常情况下， 这段代码预期是分别输出数字 1~5， 每秒一次， 每次一个。</p><p>但实际上， 这段代码在运行时会以每秒一次的频率输出五次 6。</p><p>我们可以利用闭包来解决这个问题。 首先这种IIFE(立即执行函数表达式) 是一個定义完馬上就執行的 JavaScript function，可以创建闭包。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>不熟IIFE用<code>let</code>也成，本质上这是将一个块转换成一个可以被关闭的作用域。也就是块级作用域。</p><p>总的来说闭包就是：</p><blockquote><p>当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量,其特点便是：</p><p>1、让外部访问函数内部变量成为可能</p><p>2、局部变量会常驻在内存中</p><p>3、可以避免使用全局变量，防止全局变量污染</p><p>4、会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p></blockquote><h3 id="JS模块化开发规范："><a href="#JS模块化开发规范：" class="headerlink" title="JS模块化开发规范："></a><a href="https://blog.csdn.net/qq_27575925/article/details/113758050">JS模块化</a>开发规范：</h3><p><strong>CommonJS</strong></p><ul><li>一个文件一个模块；</li><li>使用 exports.xx = … 或者 module.exports ={} 暴露模块；</li><li>使用 require() 方法引入一个模块；</li><li>require()是同步执行的；</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span><span class="token keyword">let</span> fn<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>exports<span class="token punctuation">.</span>outMsg<span class="token operator">=</span>fn<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//b.js</span><span class="token keyword">const</span> a<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">outMsg</span><span class="token punctuation">(</span><span class="token string">'hello Commonjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hello Commonjs</span></code></pre><blockquote><p>CommonJS 在NodeJS 环境用，不适用于浏览器；<br>一个文件一个模块；如果有多个导出，则去最后一个导出；</p></blockquote><p><strong>AMD</strong></p><p>全称 Asynchronous module definition（异步模块定义）</p><ul><li>使用 define(…) 定义一个模块；</li><li>使用require(…) 加载一个模块；</li><li>依赖前置，提前执行；</li></ul><p>RequireJS 是AMD 的一种实现</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 模块的定义</span><span class="token comment" spellcheck="true">/***@param id 模块名称，如果为空，模块的名字默认为模块加载器请求的制定脚本名*@param dependencies 模块依赖*@param factory 工厂函数，模块初始化执行函数或对象*/</span><span class="token function">define</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>dependencies<span class="token punctuation">,</span>factory<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 模块的使用，使用 require 加载模块</span>require（<span class="token punctuation">[</span>module<span class="token punctuation">]</span><span class="token punctuation">,</span>callback）<span class="token punctuation">;</span></code></pre><p><strong>CMD</strong></p><p>全称 Common Module Definition（通用模块定义）</p><ul><li>一个文件为一个模块</li><li>使用 define(…) 定义一个模块 （和AMD相似）</li><li>使用require(…) 加载一个模块（和AMD 相似）</li></ul><p>SeaJS 是CMD 的一种实现</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// CMD </span><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>require<span class="token punctuation">,</span>exports<span class="token punctuation">,</span>module<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> a<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> b<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 依赖就近书写；</span>  b<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>CMD和AMD 的最显著的区别 AMD 是提前执行，CMD 是延迟执行，依赖就近；<br>AMD： 执行过程中会将所有的依赖模块前置执行，也就是自己的代码逻辑开始前全部执行；<br>CMD ：如果require 但整个逻辑未使用这个依赖 或者为执行到逻辑使用它的地方前，不会执行。</p></blockquote><p><strong>UMD</strong></p><p>全称 Universal Module Definition（万能模块定义），从名字就可以看出 UMD 做的是大一统的工作。Webpack 打包代码就有 UMD 这个选项。</p><p>这个万能模块，可以在服务端使用，也可以在浏览器端使用；</p><p>它主要做了三件事：</p><ul><li>判断是否支持AMD</li><li>判断是否支持CommonJS</li><li>如果都不支持，使用全局变量</li></ul><pre class=" language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>root<span class="token punctuation">,</span> factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对应上述的三个步骤</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>amd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.判断是否支持 AMD</span>        <span class="token comment" spellcheck="true">// 如果 define 这个方法是被定义 并且 define 这个方法是 AMD 的规范，那就把 factory 这个模块实体用 define 方法以 AMD 的规范 定义</span>        <span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [] 是依赖，factory 是模块实体</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> exports <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2. 判断是否支持 CommonJS</span>        <span class="token comment" spellcheck="true">// 如果 exports 是等于一个对象，则表明是在 Node 环境中运行，则支持 CommonJS，那就用 module.exports 暴露整个模块实体</span>        module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 3. 如果都不支持，使用全局变量</span>        <span class="token comment" spellcheck="true">// Browser globals (root 即是 window)</span>        root<span class="token punctuation">.</span>returnExports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Module Defination</span>    <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token punctuation">{</span>        findSum<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        findSub<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">sub</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> math<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>ES Module (ES6 模块)</strong></p><p>全称 ECMAScript Module</p><ul><li>使用 import 导入模块；</li><li>使用 export 导出模块；</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 导出模块</span><span class="token keyword">export</span> <span class="token keyword">var</span> a<span class="token operator">=</span><span class="token string">'123'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//导出变量</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 导出函数</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'p'</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 导出对象； export 不能直接导出对象必须加上default；</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Myclass</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 导出类；</span></code></pre><h4 id="ES6-模块和Common-js-模块的差异："><a href="#ES6-模块和Common-js-模块的差异：" class="headerlink" title="ES6 模块和Common js 模块的差异："></a>ES6 模块和Common js 模块的差异：</h4><p>1、CommonJS 输出的是一个值的拷贝；ES6 模块输出的是值的引用；</p><p>2、CommonJS 模块是运行时加载；ES6模块是编译时输出接口；</p><p>由于ES6 模块是编译时输出接口，所以可以做到 tree shaking；</p><h4 id="import-和-require-导入的区别"><a href="#import-和-require-导入的区别" class="headerlink" title="import 和 require 导入的区别"></a><strong>import 和 require 导入的区别</strong></h4><p>import 的ES6 标准模块：是编译时调用，所以必须放在文件开头，是解构过程。</p><p>require 是 AMD规范引入方式：是运行时调用，所以require理论上可以运用在代码的任何地方，是赋值过程。</p><p>其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量。</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h4 id="CSS-优先规则"><a href="#CSS-优先规则" class="headerlink" title="CSS 优先规则"></a>CSS 优先规则</h4><p><strong>选择器:</strong></p><p>ID 选择器 (#ID)  Class 选择器 (.class 名)  标签选择器 (标签)  通配符 (*)</p><p>相邻选择器 (div+p)   子选择器 (div&gt;p)  后代选择器 (div p)   多个选择器 (div,p,a,ul)</p><p>伪类选择器 (a:hover) </p><p><strong>伪类选择器和伪元素的区别:</strong> </p><p>伪类用于向某些选择器添加特殊效果 (单冒号)</p><p>伪元素用于将某个特殊的东西添加到某些元素的前后 (双冒号)</p><blockquote><p>优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器</p></blockquote><p><strong>::after/:after 与::before/:before 的区别</strong> </p><p>:before 在元素之前添加效果/:after 是在元素之后添加效果;</p><p>:after/:before 是 CSS2 提出的,兼容 IE8;</p><p>::after/::before 是 CSS3 为了区分伪类和伪元素的做出的差 别,为了避免兼容性问题,习惯性的还是写:after/:before; </p><p>可继承样式: font-size/fon-family/color </p><p>不可继承样式:width/height/margin/padding/border</p><h4 id="CSS定义的权重"><a href="#CSS定义的权重" class="headerlink" title="CSS定义的权重"></a>CSS定义的权重</h4><blockquote><p>1就近原则,后加样式优于前面的样式 </p><p>2内嵌样式&gt;内联样式&gt;外联样式 </p><p>3 !Important 大于一切样式</p></blockquote><pre class=" language-css"><code class="language-css">// 以下是权重的规则：继承的样式没有权值,标签类型选择器和伪元素 <span class="token punctuation">:</span>div/p的权重为<span class="token number">1</span>，class/伪类/属性选择器的权重为<span class="token number">10</span>，id的权重为<span class="token number">100</span>，内联样式<span class="token punctuation">:</span>style=””为<span class="token number">1000</span>,以下/// 例子是演示各种定义的权重值：<span class="token comment" spellcheck="true">/*权重为1*/</span><span class="token selector">div</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为10*/</span><span class="token selector"><span class="token class">.class1</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为100*/</span><span class="token selector"><span class="token id">#id1</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为100+1=101*/</span><span class="token selector"><span class="token id">#id1</span> div</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为10+1=11*/</span><span class="token selector"><span class="token class">.class1</span> div</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*权重为10+10+1=21*/</span><span class="token selector"><span class="token class">.class1</span> <span class="token class">.class2</span> div</span><span class="token punctuation">{</span><span class="token punctuation">}</span>// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</code></pre><h4 id="CSS-单位-px、em、rem、rpx、vh、vw-的解释比较"><a href="#CSS-单位-px、em、rem、rpx、vh、vw-的解释比较" class="headerlink" title="CSS 单位 px、em、rem、rpx、vh、vw 的解释比较"></a>CSS 单位 px、em、rem、rpx、vh、vw 的解释比较</h4><blockquote><ol><li>px也就是像素，第一印象它是绝对长度，是定死的，所以想要响应式布局和自适应布局不要用它。但其实”绝对“，”定死“这些并不准确，它的大小也是会随着屏幕变化的。</li><li>rem使用更方便且用途更普遍，所以我们先来看rem。非常简单，设定根元素<html>的font-size属性，默认为16px，那么1rem = 16px。设置为20px，那么1rem = 20px。为了简化计算，我们想令1rem = 10px，就设定根元素font-size为10px或者62.5%（16*62.5%=10）。用 rem 有什么好处？可以实现响应式布局了！响应式布局指的是元素大小能根据屏幕大小随时变化，因为 rem 布局里所有大小跟着根元素变化，所以只要在屏幕大小变化的时候改变根元素font-size就行了。</li><li>rpx是微信小程序为了解决自适应屏幕尺寸设计的单位，它规定任何屏幕的宽都是750rpx。vw是css3新出的单位，规定任何屏幕宽都是100vw，高100vh，就是是将窗口大小平分为 100 份;这里的屏幕指的是视口，即浏览器窗口，不受分辨率和dpr影响，还是很方便的。</li></ol></blockquote><h4 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex布局</a></h4><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/flex-container.jpg" alt="flex-容器属性"></p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/flex-project.jpg" alt="flex-项目属性"></p><h4 id="盒子水平垂直居中的五种方法："><a href="#盒子水平垂直居中的五种方法：" class="headerlink" title="盒子水平垂直居中的五种方法："></a>盒子水平垂直居中的五种方法：</h4><p>相对定位： 先让子盒子的左上角居中然后在向左和向上移动子盒子的宽和高的一半。缺点是需要知道子盒子具体的宽和高</p><pre class=" language-css"><code class="language-css"><span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">25</span>px<span class="token punctuation">;</span><span class="token property">margin-top</span><span class="token punctuation">:</span> - <span class="token number">25</span>px<span class="token punctuation">;</span></code></pre><p>绝对定位：设置子盒子的上、下、左、右都为0，然后再用margin: auto;来设置居中。不需要知道盒子具体的宽和高，但必须要有固定的宽和高。</p><pre class=" language-css"><code class="language-css"><span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span></code></pre><p>相对定位+CSS3的translate：同一，先让盒子的左上角居中（left，top 50%），然后再借助translate让子盒子分别向左和向上移动盒子的一半。不需要知道盒子具体的宽和高，但不是所有浏览器都兼容。</p><pre class=" language-css"><code class="language-css"><span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-<span class="token number">50%</span> -<span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>display: flex：利用flex布局让子盒子居中，同样也存在兼容性问题</p><pre class=" language-css"><code class="language-css"> <span class="token selector"><span class="token id">#box</span></span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span><span class="token hexcode">#eee</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span>flex<span class="token punctuation">;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>利用JavaScript，获取分别获取大盒子和子盒子的宽和高，然后再通过计算让子盒子居中</p><h4 id="两边固定-中间自适应-（圣杯布局和双飞翼布局）"><a href="#两边固定-中间自适应-（圣杯布局和双飞翼布局）" class="headerlink" title="两边固定 中间自适应 （圣杯布局和双飞翼布局）"></a>两边固定 中间自适应 （圣杯布局和双飞翼布局）</h4><p><strong>圣杯布局结构</strong>： </p><blockquote><p>main是中间部分 必须放在文档流的最起前边 优先渲染</p><p>好处：重要的内容放在文档流前面可以优先渲染</p><p>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</p></blockquote><ul><li></li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>contaer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>.contaer {    /*3， 给父盒子添加padding  把main挤过来 */    padding: 0 200px;}        .left,.right {    width: 200px;    height: 200px;    background-color: red;    /*1， 给左右盒子添加左浮动 */    float: left;    /* 4，给左右盒子添加相对于自己的定位 */    position: relative;}        .left {    /*2， 让盒子上去 */    margin-left: -100%;    /* 让盒子定位在左边 */    left: -200px;}.right {    /* 2，让盒子上去 */    margin-left: -200px;    /*4. 让盒子定位在右边 */    right: -200px;}        .main {    width: 100%;    height: 200px;    background-color: blueviolet;    float: left;    text-align: center;}</code></pre><blockquote><p>1，给左中右设置左浮动 但是 mian部分的宽度为100% 所以左右元素不会上去</p><p>2，给left 一个margin-left = -100% right 的margin-left : -200px (这里是right盒子的宽度)</p><p>3，这时由于main的左右部分被挡住 只好给contaer padding值把main挤出来</p><p>4，这样做之后左右盒子也被挤过来了 所以需要给两个盒子添加定位 相对于自己 把盒子定在左右两边</p></blockquote><p>也可以通过flex布局：</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.contaer</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 给父盒子设置flex */</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.main</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 中间部分  丰乐乡：1  让盒子占据剩下的所有剩余空间 */</span>    <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span>,<span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 让左侧盒子放在前边  但不是最先渲染 */</span>css    <span class="token property">order</span><span class="token punctuation">:</span> -<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>双飞翼布局</strong>：</p><blockquote><p>去掉了圣杯布局中的定位和padding 但是需要在main加入一个p标签 后给p标签margin。对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局</p><p>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</p></blockquote><p>结构：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>contaer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>样式：</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.left</span>,<span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 给左右盒子添加左浮动 */</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 让盒子上去 */</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 让盒子上去 */</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token selector"><span class="token class">.main</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 给p添加margin*/</span><span class="token selector">p </span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">200</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>双飞翼布局和圣杯布局的区别</strong>：</p><blockquote><p>除了结构上的差别 圣杯布局中 当页面很小的时候 main 会被挤下来 但是双飞翼布局不会 flex布局也不会</p></blockquote><h4 id="创建一个三角形的原理"><a href="#创建一个三角形的原理" class="headerlink" title="创建一个三角形的原理"></a>创建一个三角形的原理</h4><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token id">#demo</span> </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">border-width</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent red transparent<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h4><p>1.在子元素并级后面添加一个新元素，添加 clear：both 属性 </p><p>优点：通俗易懂，容易掌握   缺点：添加无意义空标签，不方便后期维护 </p><p>2.给父元素添加 overflow:hidden </p><p>优点：代码较少，简单方便   缺点：不能配合定位使用 </p><p>3.：after 方法（作用于浮动元素的父元素）</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.clearfix</span><span class="token pseudo-element">:after</span></span><span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">""</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span>  <span class="token property">visibility</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 为兼容 IE6,IE7，因为 ie6,ie7 不能用 after 伪类 */</span><span class="token selector"><span class="token class">.clearfix</span></span><span class="token punctuation">{</span>  <span class="token property">zoom</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>优点：结构和语义化完全正确   缺点：复用方式不当，会造成代码量增加</p><p><strong>CSS 实现单行文本溢出显示</strong> </p><pre class=" language-css"><code class="language-css"><span class="token property">overflow</span> <span class="token punctuation">:</span> hidden <span class="token punctuation">;</span> <span class="token property">text-overflow</span> <span class="token punctuation">:</span> ellipsis <span class="token punctuation">;</span> <span class="token property">white-space</span> <span class="token punctuation">:</span> nowrap <span class="token punctuation">;</span></code></pre><p>还需要加宽度 width 属性来兼容部分浏览器 </p><p><strong>实现多行文本溢出显示</strong></p><pre class=" language-css"><code class="language-css"><span class="token property">display</span> <span class="token punctuation">:</span> -wedkit-box <span class="token punctuation">;</span> <span class="token property">-webkit-box-orient</span> <span class="token punctuation">:</span> vertical <span class="token punctuation">;</span> <span class="token property">-webkit-line-clamp</span> <span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">;</span> <span class="token property">overflow</span> <span class="token punctuation">:</span> hidden <span class="token punctuation">;</span></code></pre><p>适用范围 : 因使用了 Webkit 的 CSS 扩展属性,该方法适用于 Webkit 浏览器 以及移动端 注: </p><p> -webkit-line-clamp 用来限制在一个块元素显示的文本的行数,为了实现 该效果,它需要组合其它的 webkit 属性。 </p><p> 常见结合属性： </p><p> display：-webkit-box； 必须结合的属性，将对象作为弹性伸缩盒 子模式显示。 </p><p> -webkit-box-orient 必须结合的属性，设置或减缩伸缩盒对象的子 元素排列方式。 <strong>溢出显示的另外一种显示方式</strong> </p><p>实现方式：</p><pre class=" language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>   position：relative；   line-height：<span class="token number">20</span>px；   max-height：<span class="token number">40</span>px；   overflow：hidden； <span class="token punctuation">}</span> <span class="token selector">div：after</span><span class="token punctuation">{</span>   <span class="token property">content</span> <span class="token punctuation">:</span> “<span class="token number">...</span>”<span class="token punctuation">;</span>   <span class="token property">position</span> <span class="token punctuation">:</span> absolute <span class="token punctuation">;</span>   <span class="token property">bottom</span> <span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">;</span>   <span class="token property">right</span> <span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">;</span>   <span class="token property">padding-left</span> <span class="token punctuation">:</span> <span class="token number">40</span>px <span class="token punctuation">;</span>    <span class="token property">background</span> <span class="token punctuation">:</span> <span class="token function">-webkit-linear-gradient</span><span class="token punctuation">(</span>left , transparent , <span class="token hexcode">#fff</span> <span class="token number">55%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token property">background</span> <span class="token punctuation">:</span> <span class="token function">-o-linear-gradient</span><span class="token punctuation">(</span>left , transparent , <span class="token hexcode">#fff</span> <span class="token number">55%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token property">background</span> <span class="token punctuation">:</span> <span class="token function">-moz-linear-gradient</span><span class="token punctuation">(</span>left , transparent , <span class="token hexcode">#fff</span> <span class="token number">55%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">background</span> <span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>left , transparent , <span class="token hexcode">#fff</span> <span class="token number">55%</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> </code></pre><p>此方法也有弊端：就是未超出行的情况下也会出现省略号 </p><p>注:</p><ol><li>将 height 设置为 line-height 的整数倍,防止超出的文字露出。</li><li>给 p::after 添加渐变背景可避免文字只显示一半。 </li><li>由于 ie6-7 不显示 content 内容，所以要添加标签兼容 ie6-7，兼容 ie8 需要将 ：：after 替换成 ：after</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><blockquote><p>类组件可以使用其他特性，如状态 state 和生命周期钩子。</p><p>当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。</p><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。</p></blockquote><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><blockquote><p>Typescript是强类型的Javascript超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</p></blockquote><h3 id="Typescript的优缺点："><a href="#Typescript的优缺点：" class="headerlink" title="Typescript的优缺点："></a>Typescript的优缺点：</h3><blockquote><p><strong>优点：</strong></p><p>1：快速简单，易于学习。</p><p>2：编译时提供错误检查， 在代码运行前就会进行错误提示。</p><p>3：支持所有的JS库。</p><p>4：支持ES6，提供了ES6所有优点和更高的生产力。</p><p>5：使用继承提供可重用性。</p><p>6：有助于代码结构。</p><p>7：通过定义模块来定义命名空间。</p><p><strong>缺点：</strong></p><p>1：需要长时间的来编译代码。</p><p>2：在使用第三方库时，需要有三方库的定义文件，并不是所有三方库都提供了定义文件，提供的定义文件是否准确也值得商榷。</p></blockquote><h3 id="泛型及其作用作用是什么："><a href="#泛型及其作用作用是什么：" class="headerlink" title="泛型及其作用作用是什么："></a><a href="https://typescript.bootcss.com/generics.html">泛型</a>及其作用作用是什么：</h3><blockquote><p>泛型代表的是泛指某一类型，更像是一个类型变量。由尖括号包裹<T>。主要作用是创建逻辑可复用的组件。泛型可以作用在函数、类、接口上。</p></blockquote><p> 函数：</p><pre class=" language-tsx"><code class="language-tsx">function greet<T>(name: T) {}</code></pre><p>类：</p><pre class=" language-tsx"><code class="language-tsx">class createObj<T> {  name: T}</code></pre><p>接口：</p><pre class=" language-tsx"><code class="language-tsx">interface IF<T> {  name: T}</code></pre><p>相关<a href="https://www.jianshu.com/p/c8aaba6e8ce0">试题</a></p><h2 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h2><h3 id="Http缓存："><a href="#Http缓存：" class="headerlink" title="Http缓存："></a>Http缓存：</h3><blockquote><p>http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。</p><p>http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。</p></blockquote><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-cache-2.jpg" alt="http-cache-2"></p><h4 id="1、http缓存的分类："><a href="#1、http缓存的分类：" class="headerlink" title="1、http缓存的分类："></a>1、http缓存的分类：</h4><p> 根据是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存) 根据是否可以被单个或者多个用户使用来分类，可分为(私有缓存，共享缓存) 强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。</p><p><strong>强制缓存</strong><br>强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。</p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-force-cache.jpg" alt="http缓存-强制"></p><p><strong>协商缓存</strong><br>当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现</p><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-negotiation-cache.jpg" alt="http缓存-协商"></p><h4 id="2、如何使用HTTP缓存-？"><a href="#2、如何使用HTTP缓存-？" class="headerlink" title="2、如何使用HTTP缓存 ？"></a>2、如何使用HTTP缓存 ？</h4><p>一般需要缓存的资源有html页面和其他静态资源：<br><strong>html页面缓存的设置主要是在标签中嵌入标签，这种方式只对页面有效，对页面上的资源无效,静态资源的缓存一般是在web服务器上配置的</strong></p><ol><li>html页面禁用缓存的设置如下：</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pragma<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>no-cache<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>// 仅有IE浏览器才识别的标签，不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cache-control<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>no-cache<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>// 其他主流浏览器识别的标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>expires<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>// 仅有IE浏览器才识别的标签，该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段</code></pre><ol start="2"><li>html设置缓存如下：</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Cache-Control<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>max-age<span class="token punctuation">=</span>7200<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>// 其他主流浏览器识别的标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Expires<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Mon, 20  Aug 2018 23:00:00 GMT<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>// 仅有IE浏览器才识别的标签</code></pre><h4 id="3、缓存控制"><a href="#3、缓存控制" class="headerlink" title="3、缓存控制"></a>3、缓存控制</h4><p><strong>HTTP/1.1</strong>定义的 <a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control"><code>Cache-Control</code></a> 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p><p><strong>没有缓存</strong></p><pre class=" language-js"><code class="language-js">Cache<span class="token operator">-</span>Control<span class="token punctuation">:</span> no<span class="token operator">-</span>store</code></pre><p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p><p><strong>缓存但重新验证</strong></p><pre class=" language-undefined"><code class="language-undefined">Cache-Control: no-cache</code></pre><p>此方式下，每次有请求发出时缓存会将此请求发到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期（返回304），则缓存才使用本地缓存副本</p><p><strong>私有和公共缓存</strong></p><pre class=" language-cpp"><code class="language-cpp">Cache<span class="token operator">-</span>Control<span class="token operator">:</span> <span class="token keyword">private</span>Cache<span class="token operator">-</span>Control<span class="token operator">:</span> <span class="token keyword">public</span></code></pre><p>“public” 指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了”public”，则一些通常不被中间人缓存的页面（因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。</p><p>而 “private” 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</p><p><strong>过期</strong></p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">Cache</span><span class="token operator">-</span><span class="token builtin">Control</span><span class="token punctuation">:</span> <span class="token builtin">max</span><span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">31536000</span></code></pre><p>过期机制中，最重要的指令是 “<code>max-age=</code>“，表示资源能够被缓存（保持新鲜）的最大时间。</p><p><strong>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？</strong></p><blockquote><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载 相应的资源并进行离线存储。如果已经访问过 app，并且资源已经离线存储了， 如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资 源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如 果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文 件中的资源并进行离线存储 离线的情况下，浏览器就直接使用离线存储的资源</p></blockquote><h4 id="4、http报头-amp-amp-状态码"><a href="#4、http报头-amp-amp-状态码" class="headerlink" title="4、http报头&amp;&amp;状态码"></a>4、http报头&amp;&amp;状态码</h4><blockquote><p>HTTP请求报文由请求行、请求头部、空行和请求数据4个部分组成，下图是请求报文的一般格式。</p><p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。</p></blockquote><p><img src="/../images/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/http-cache-3.jpg" alt="http缓存-3"></p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>提示信息，请求被成功接收</td></tr><tr><td>2xx</td><td>成功，请求被成功处理 200</td></tr><tr><td>3xx</td><td>重定向相关 304</td></tr><tr><td>4xx</td><td>客户端错误 404</td></tr><tr><td>5xx</td><td>服务端错误 500</td></tr></tbody></table><blockquote><p>200 成功处理了请求，一般情况下都是返回此状态码；<br>201 请求成功并且服务器创建了新的资源。<br>202 接受请求但没创建资源；<br>203 返回另一资源的请求；</p></blockquote><blockquote><p>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置。<br>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p></blockquote><blockquote><p>400 服务器不理解请求的语法。<br>401 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 服务器拒绝请求。<br>404 服务器找不到请求的网页。<br>408 服务器等候请求时发生超时。<br>410 如果请求的资源已永久删除，服务器就会返回此响应。<br>413 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 请求的 URI（通常为网址）过长，服务器无法处理。</p></blockquote><blockquote><p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p></blockquote><h4 id="5、HTTP与HTTPS有什么区别？"><a href="#5、HTTP与HTTPS有什么区别？" class="headerlink" title="5、HTTP与HTTPS有什么区别？"></a>5、HTTP与HTTPS有什么区别？</h4><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</p><p>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><blockquote><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></blockquote><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><blockquote><p>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET产生的URL地址可以被Bookmark，而POST不可以。<br>GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中。</p></blockquote><p>首先从安全性讲，get和post都一样，没啥所谓的哪个更安全<br>get请求参数在url地址上，直接暴露，post请求的参数放body部分，按F12也直接暴露了，所以没啥安全性可言。</p><p>GET参数通过URL传递，POST放在Request body中”这个其实也不准，post请求也可以没body，也可以在url传递呢？</p><p><strong>GET和POST有一个重大区别</strong><br>GET产生一个TCP数据包；POST产生两个TCP数据包。也就是说：<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><h3 id="WebStorage："><a href="#WebStorage：" class="headerlink" title="WebStorage："></a>WebStorage：</h3><p>Web Storage的目的是为了克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage的两个主要目标是：</p><ul><li>提供一种在cookie之外存储会话数据的途径。</li><li>提供一种存储大量可以跨会话存在的数据的机制。</li></ul><p>Web Storage又分为两种： sessionStorage 和localStorage ，即这两个是Storage的一个实例。从字面意思就可以很清楚的看出来，sessionStorage将数据保存在session中，浏览器关闭也就没了；而localStorage则一直将数据保存在客户端本地。其API提供的方法有以下几种：</p><pre class=" language-csharp"><code class="language-csharp">    <span class="token operator">-</span> <span class="token function">setItem</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span> ——  保存数据，以键值对的方式储存信息。    <span class="token operator">-</span> <span class="token function">getItem</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> ——  获取数据，将键值传入，即可获取到对应的<span class="token keyword">value</span>值。    <span class="token operator">-</span> <span class="token function">removeItem</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> ——  删除单个数据，根据键值移除对应的信息。    <span class="token operator">-</span> <span class="token function">clear</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> ——  删除所有的数据    <span class="token operator">-</span> <span class="token function">key</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> —— 获取某个索引的key</code></pre><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。localStorage有length属性，可以查看其有多少条记录的数据。使用方法如下：</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">var</span> storage <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>localStorage<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//判断浏览器是否支持localStorage</span>     storage <span class="token operator">=</span> window<span class="token punctuation">.</span>localStorage<span class="token punctuation">;</span>          storage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Rick"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用setItem方法，存储数据</span>     <span class="token function">alert</span><span class="token punctuation">(</span>storage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//调用getItem方法，弹框显示 name 为 Rick</span>     storage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//调用removeItem方法，移除数据</span>     <span class="token function">alert</span><span class="token punctuation">(</span>storage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//调用getItem方法，弹框显示 name 为 null</span><span class="token punctuation">}</span></code></pre><p>localStorage 相对sessionStorage简单一点，需要注意的地方不是很多。</p><h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。需要注意的有以下几点：</p><ul><li>页面刷新不会消除数据;</li><li>只有在当前页面打开的链接，才可以访sessionStorage的数据；</li><li>使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据;</li></ul><h4 id="WebStorage与cookie的区别："><a href="#WebStorage与cookie的区别：" class="headerlink" title="WebStorage与cookie的区别："></a>WebStorage与cookie的区别：</h4><blockquote><p>cookie是在HTML4中使用的给客户端保存数据的，也可以和session配合实现跟踪浏览器用户身份；</p></blockquote><p><strong>相同点：</strong></p><p> cookie，localStorage，sessionStorage都是在客户端保存数据的，存储数据的类型：都是字符串。</p><p><strong>不同点：</strong></p><ol><li>生命周期：</li></ol><blockquote><p>1）、cookie如果不设置有效期，那么就是临时存储（存储在内存中），是会话级别的，会话结束后，cookie也就失效了，如果设置了有效期，那么cookie存储在硬盘里，有效期到了，就自动消失了。</p><p>2）、localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。</p><p>3）、sessionStorage仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。</p><p>可以简单的理解为：sessionStorage，没有设置有效期的cookie。</p><p>如果说把cookie的有效期设置为永远永远，永久，那么就是localStorage。</p><p>cookie没有设置有效期，那么就是sessionStorage                  </p></blockquote><ol start="2"><li><p>网络流量：cookie的数据每次都会发给服务器端，而localstorage和sessionStorage不会与服务器端通信，纯粹为了保存数据，所以，webstorage更加节约网络流量。</p></li><li><p>大小限制：cookie大小限制在4KB，非常小；localstorage和sessionStorage在5M</p></li><li><p>安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获。</p></li></ol><h4 id="cookie的配置："><a href="#cookie的配置：" class="headerlink" title="cookie的配置："></a>cookie的配置：</h4><p>通常我们有两种方式给浏览器设置或获取Cookie：</p><ul><li><p>第一种 通过 HTTP 方式对 Cookie 进行赋值，又分为 Request 和 Response：</p></li><li><ul><li>HTTP Response Headers 中的 Set-Cookie Header</li><li>HTTP Request Headers 中的 Cookie Header</li></ul></li><li><p>第二种 通过JavaScript对document.cookie进行赋值或取值。</p></li></ul><p><strong>1. HTTP Cookie</strong></p><p>Set-Cookie Header，除了必须包含Cookie正文，还可以选择性包含6个属性：</p><pre class=" language-text"><code class="language-text">path、domain、max-age、expires、secure、httponly</code></pre><p>它们之间用英文分号和空格（”; “）连接，示例：</p><pre class=" language-http"><code class="language-http">Set-Cookie:  key=value;   path=path;    domain=domain;    max-age=max-age-in-seconds;    expires=date-in-GMTString-format;    secure; httponly</code></pre><p><strong>JS Cookie</strong></p><p>在浏览器端，通过 document.cookie 也可以设置Cookie，JS Cookie 的内容除了必须包含正文之外，还可选5个属性：</p><pre class=" language-text"><code class="language-text">path、domain、max-age、expires、secure</code></pre><p>下面是简单的示例：</p><pre class=" language-js"><code class="language-js">document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">"key=value; path=path; domain=domain; max-age=max-age-in-seconds; expires=date-in-GMTString-format; secure"</span><span class="token punctuation">;</span></code></pre><p>JS 中设置 Cookie 和 HTTP 方式相比较，少了对 <strong>HttpOnly</strong> 的控制，是因为 JS 不能读写HttpOnly Cookie。</p><h2 id="浏览器安全相关"><a href="#浏览器安全相关" class="headerlink" title="浏览器安全相关"></a>浏览器安全相关</h2><h3 id="盗用cookie的手段"><a href="#盗用cookie的手段" class="headerlink" title="盗用cookie的手段"></a>盗用cookie的手段</h3><p>在别的浏览器中来冒用合法用户访问系统；黑客自然不能手动拿你浏览器中的cookie值，除非黑客就是你身边的人，那他就不是黑客了，是盗贼；</p><p>黑客都是靠技术手段获取别人的东西，例如：利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页中，然后自动从用户浏览器中获取cookie的值，此技术手段被称为<a href="https://blog.csdn.net/zemprogram/article/details/109451863"><strong>XSS攻击</strong></a>；</p><p><strong>如果cookie中设置了HttpOnly属性，且为true，那么通过js脚本将无法读取到cookie信息，这样就能有效的防止XSS攻击，防止cookie内容被盗窃。</strong></p><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>　　 在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.<br>    Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。<br>    Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://juejin.cn/post/6844903955286196237">【THE LAST TIME】彻底吃透 JavaScript 执行机制</a></p><p><a href="https://juejin.cn/post/6844903984335945736">【THE LAST TIME】一文吃透所有JS原型相关知识点</a></p><p><a href="https://imququ.com/post/host-only-cookie.html">你所不知道的HostOnly Cookie</a></p><p><a href="https://blog.csdn.net/zemprogram/article/details/109451863">计算机网络–网络攻击XSS与CSRF</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">CSS Flex 弹性布局（一） - 阮一峰</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">CSS Flex 弹性布局（二） - 阮一峰</a></p><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局 - 阮一峰</a></p><p><a href="https://typescript.bootcss.com/">TypeScript 中文手册</a></p><p><a href="https://www.jianshu.com/p/c8aaba6e8ce0">TypeScript-相关试题</a></p><p><a href="https://blog.csdn.net/qq_27575925/article/details/113758050">深度剖析JavaScript ES5/ AMD/ CMD/ COMMONJS/ ES6模块化</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 个人知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 个人知识库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
