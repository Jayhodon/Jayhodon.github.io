<!DOCTYPE HTML>
<html lang="zh-HK">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Vue.js设计与实现, Jayhodon&#39;s Blog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Vue.js设计与实现 | Jayhodon&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.2"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <!-- <img src="/medias/logo.png" class="logo-img" alt="LOGO"> -->
                    
                    <span class="logo-span">Jayhodon&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Jayhodon&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Jayhodon" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #695075 ;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Jayhodon" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Vue.js设计与实现</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #8f3a81 ;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #8f3a81 ;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                <span class="chip bg-color">前端</span>
                            </a>
                        
                            <a href="/tags/Vue/">
                                <span class="chip bg-color">Vue</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                前端
                            </a>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF/Vue/" class="post-category">
                                Vue
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>發布日期:&nbsp;&nbsp;
                    2023-06-12
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="Vue的设计模式"><a href="#Vue的设计模式" class="headerlink" title="Vue的设计模式"></a>Vue的设计模式</h3><h4 id="MVC-和-MVVM-区别"><a href="#MVC-和-MVVM-区别" class="headerlink" title="MVC 和 MVVM 区别"></a>MVC 和 MVVM 区别</h4><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范</p>
<ul>
<li>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li>
<li>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</li>
<li>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据</li>
</ul>
<p>MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。</p>
<h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><p>MVVM 新增了 VM 类</p>
<blockquote>
<p>ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</p>
</blockquote>
<p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</p>
<p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p>
<blockquote>
<p>注意：Vue 并没有完全遵循 MVVM 的思想 这一点官网自己也有说明。严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</p>
</blockquote>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/../images/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/vue-life.jpg" alt="Vue生命周期"></p>
<blockquote>
<p><strong>beforeCreate</strong> 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问</p>
<p><strong>created</strong> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom</p>
<p><strong>beforeMount</strong> 在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p><strong>mounted</strong> 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点</p>
<p><strong>beforeUpdate</strong> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p>
<p><strong>updated</strong> 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。</p>
<p><strong>beforeDestroy</strong> 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。</p>
<p><strong>destroyed</strong> Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p>
<p><strong>activated</strong> keep-alive 专属，组件被激活时调用</p>
<p><strong>deactivated</strong> keep-alive 专属，组件被销毁时调用</p>
</blockquote>
<h4 id="keep-alive-中的生命周期有哪些"><a href="#keep-alive-中的生命周期有哪些" class="headerlink" title="keep-alive 中的生命周期有哪些"></a>keep-alive 中的生命周期有哪些</h4><blockquote>
<p>​    keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存，在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。 如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。</p>
<p>​    同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。 当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期； 当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。</p>
</blockquote>
<h4 id="异步请求在哪一步发起？"><a href="#异步请求在哪一步发起？" class="headerlink" title="异步请求在哪一步发起？"></a>异步请求在哪一步发起？</h4><blockquote>
<p>可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p>
<p>如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面  loading 时间；</li>
<li>ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
</blockquote>
<h4 id="Vue-的父子组件生命周期钩子函数执行顺序"><a href="#Vue-的父子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父子组件生命周期钩子函数执行顺序"></a>Vue 的父子组件生命周期钩子函数执行顺序</h4><blockquote>
<p><strong>加载渲染过程:</strong></p>
<p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p>
<p><strong>子组件更新过程:</strong></p>
<p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p>
<p><strong>父组件更新过程:</strong></p>
<p>父 beforeUpdate-&gt;父 updated</p>
<p><strong>销毁过程:</strong></p>
<p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p>
</blockquote>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><h4 id="组件中为什么-data-是一个函数？"><a href="#组件中为什么-data-是一个函数？" class="headerlink" title="组件中为什么 data 是一个函数？"></a>组件中为什么 <code>data</code> 是一个函数？</h4><blockquote>
<p>在 Vue 组件中，为什么 <code>data</code> 是一个函数而不是一个对象的原因是为了确保每个组件实例都有其自己的数据副本。当组件被定义时，<code>data</code> 必须是一个函数。每次创建组件实例时，Vue 都会调用该函数来返回一个全新的数据对象。</p>
<p>这是因为 Vue 组件可以在应用中存在多个实例，每个实例都应该具有独立的状态和数据。如果 <code>data</code> 是一个对象，那么所有组件实例将共享相同的数据对象，这将导致一个实例的数据变化会影响到其他实例。</p>
<p>通过将 <code>data</code> 定义为函数，Vue 在创建组件实例时会为每个实例调用该函数，从而返回一个新的数据对象。这样，每个组件实例都有自己的数据副本，它们之间相互独立，可以独立地修改和维护各自的状态。</p>
</blockquote>
<h4 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h4><p>v-model 其实就是语法糖，v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<blockquote>
<p>text 和 textarea 元素使用 value property 和 input 事件；</p>
<p>checkbox 和 radio 使用 checked property 和 change 事件；</p>
<p>select 字段将 value 作为 prop 并将 change 作为事件。</p>
</blockquote>
<p>在普通标签上:</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  //这一行等于下一行
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth <span class="token punctuation">=</span> $event.target.value<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
</code></pre>
<p>在组件上:</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>currency-input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>price<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>currentcy-input</span><span class="token punctuation">></span></span>
<span class="token comment" spellcheck="true">&lt;!--上行代码是下行的语法糖
 &lt;currency-input :value="price" @input="price = arguments[0]">&lt;/currency-input>
--></span>

<span class="token comment" spellcheck="true">&lt;!-- 子组件定义 --></span>
Vue.component('currency-input', {
 template: `
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
    <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>input<span class="token punctuation">"</span></span>
    <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span>
    <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>input<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>
   <span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
 `,
 props: ['value'],
})
</code></pre>
<h4 id="Vue数据双向绑定原理"><a href="#Vue数据双向绑定原理" class="headerlink" title="Vue数据双向绑定原理"></a>Vue数据双向绑定原理</h4><h5 id="vue的响应式基本原理："><a href="#vue的响应式基本原理：" class="headerlink" title="vue的响应式基本原理："></a>vue的响应式基本原理：</h5><blockquote>
<p>1、vue会遍历此data中对象所有的属性，</p>
<p>2、并使用Object.defineProperty进行数据劫持，把这些属性全部转为getter/setter，</p>
<p>3、而每个组件实例都有watcher对象，</p>
<p>4、它会在组件渲染的过程中把属性记录为依赖，</p>
<p>5、之后当依赖项的 setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p>
</blockquote>
<p>eg：</p>
<p>Object.defineProperty( ):</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"My name is "</span> <span class="token operator">+</span> name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
 
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jayhodon'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// My name is Jayhodon</span>
</code></pre>
<h5 id="vue的响应式原理设计三个重要对象："><a href="#vue的响应式原理设计三个重要对象：" class="headerlink" title="vue的响应式原理设计三个重要对象："></a>vue的响应式原理设计三个重要对象：</h5><blockquote>
<p>Observer对象：vue中的数据对象在初始化过程中转换为Observer对象。</p>
<p>Watcher对象：将模板和Observer对象结合在一起生成Watcher实例，Watcher是订阅者中的订阅者。</p>
<p>Dep对象：Watcher对象和Observer对象之间纽带，每一个Observer都有一个Dep实例，用来存储订阅者Watcher。</p>
</blockquote>
<p>当属性变化会执行主题对象Observer的dep.notify方法， 这个方法会遍历订阅者Watcher列表向其发送消息， Watcher会执行run方法去更新视图。模板编译过程中的指令和数据绑定都会生成Watcher实例，实例中的watch属性也会生成Watcher实例。</p>
<p>总的来说就是：</p>
<blockquote>
<p>1、在生命周期的initState方法中将data，prop，method，computed，watch中的数据劫持， 通过observe方法与Object.defineProperty方法将相关对象转为换Observer对象。</p>
<p>2、然后在initRender方法中解析模板，通过Watcher对象，Dep对象与观察者模式将模板中的 指令与对象的数据建立依赖关系，使用全局对象Dep.target实现依赖收集。</p>
<p>3、当数据变化时，setter被调用，触发Object.defineProperty方法中的dep.notify方法， 遍历该数据依赖列表，执行器update方法通知Watcher进行视图更新。</p>
</blockquote>
<h5 id="使用Object-defineProperty实现监听变量"><a href="#使用Object-defineProperty实现监听变量" class="headerlink" title="使用Object.defineProperty实现监听变量:"></a>使用Object.defineProperty实现监听变量:</h5><p>实现步骤：</p>
<p>Observer：</p>
<p> 用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Observer<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    walk<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            self<span class="token punctuation">.</span><span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    defineReactive<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> childObj <span class="token operator">=</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 递归遍历所有子属性</span>
        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
            enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> getter <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断是否需要添加订阅者，并添加订阅者</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> val<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> setter <span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
                dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果数据发生了变化，则通知所有的订阅者</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>value <span class="token operator">||</span> <span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数</span>
<span class="token keyword">function</span> Dep <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Dep<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    addSub<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    notify<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
<p>Watcher：</p>
<p> 可以收到属性的变化通知并执行相应的函数，从而更新视图。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> exp<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>exp <span class="token operator">=</span> exp<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将自己添加到订阅器的操作</span>
<span class="token punctuation">}</span>

Watcher<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    run<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>exp<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> oldVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!==</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>cb<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 缓存自己</span>
        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>exp<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">// 强制执行监听器里的get函数</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 释放自己</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>这时只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> SelfVue <span class="token punctuation">(</span>data<span class="token punctuation">,</span> el<span class="token punctuation">,</span> exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>exp<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化模板数据的值</span>
    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> exp<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>完整版参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/libin-1/p/6893712.html">vue的双向绑定原理及实现</a>    <a target="_blank" rel="noopener" href="https://github.com/canfoo/self-vue/tree/master/v3">源 码</a></p>
<h5 id="使用ES6的proxy简单实现监听变量"><a href="#使用ES6的proxy简单实现监听变量" class="headerlink" title="使用ES6的proxy简单实现监听变量:"></a>使用ES6的proxy简单实现监听变量:</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
 msg<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">10</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//懒监听，去获取的时候才监听对象里面的对象，而不是直接递归循环监听</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//数组新增会执行两次，一次是修改length，一次是添加值</span>
  <span class="token keyword">let</span> oldValue <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>oldValue<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">//找不到老值，新增</span>
  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>oldValue <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">//老值和新值不相等，修改</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
proxy<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span>
</code></pre>
<p>区别：</p>
<blockquote>
<p>1、语法层面上</p>
<p>defineProperty只能响应首次渲染时候的属性，</p>
<p>defineProperty无法一次性监听所有属性，必须通过遍历或者递归的方式来实现且无法监听新增的属性，对于数组defineProperty则需要劫持数组方法。</p>
<p>Proxy需要的是整体监听，不需要关心里面有什么属性，而且Proxy的配置项有13种，可以做更细致的事情，这是之前的defineProperty无法达到的。</p>
<p>2、兼容层面上</p>
<p>vue2.x之所以只能兼容到IE8就是因为defineProperty无法兼容IE8,其他浏览器也会存在轻微兼容问题。</p>
<p>proxy的话除了IE，其他浏览器都兼容，这次vue3还是使用了它，说明vue3直接放弃了IE的兼容考虑。</p>
</blockquote>
<p> 为什么Vue 3 使用 Proxy 替代了 Vue 2 中的 Object.defineProperty：</p>
<blockquote>
<ol>
<li>更好的性能：Vue 3 使用 Proxy 可以提供比 Object.defineProperty 更高的性能。Proxy 可以拦截更多的操作，包括属性访问、属性设置、删除属性等，而 Object.defineProperty 只能拦截属性的读取和设置。</li>
<li>更好的扩展性：Proxy 提供了更多的拦截方法，可以针对更多的操作进行定制。这使得 Vue 3 在响应式系统的实现上更加灵活和可扩展。</li>
<li>更好的支持嵌套对象：Proxy 对于嵌套对象的响应式支持更加完善。Vue 3 的响应式系统可以追踪到嵌套对象的变化，并在需要时触发更新。</li>
<li>更好的 TypeScript 支持：Proxy 的类型推断更准确，可以提供更好的 TypeScript 支持，让开发者在编码过程中能够获得更准确的类型提示和错误检查。</li>
</ol>
</blockquote>
<p>​    总体来说，Vue 3 使用 Proxy 替代了 Vue 2 中的 Object.defineProperty，主要是为了提供更好的性能、更好的扩展性、更好的嵌套对象支持和更好的 TypeScript 支持。这些改进使得 Vue 3 在响应式系统的实现上更加先进和灵活，提供了更好的开发体验和性能优化。</p>
<h4 id="Vue-中的数据为什么频繁变化时只会更新一次-？"><a href="#Vue-中的数据为什么频繁变化时只会更新一次-？" class="headerlink" title="Vue 中的数据为什么频繁变化时只会更新一次 ？"></a>Vue 中的数据为什么频繁变化时只会更新一次 ？</h4><p>​    在 Vue 中，当数据频繁变化时，Vue 会对数据变化进行优化处理，以减少不必要的更新操作，从而提高性能。    </p>
<blockquote>
<p>Vue 使用了异步更新队列的机制，即将数据变化的通知放入队列中，然后在下一个事件循环周期中统一进行更新操作。这样做的好处是，当数据频繁变化时，不会立即触发更新，而是等待下一个事件循环周期进行批量更新，从而避免了频繁的更新操作。</p>
<p>具体来说，当多次修改数据时，Vue 会将这些修改操作合并为一个更新操作。例如，连续对同一个数据进行多次修改，只会触发一次更新操作，以最终的修改结果为准。</p>
<p>这种优化机制可以有效减少不必要的 DOM 操作和重新渲染，提升性能和效率。同时，也避免了频繁的更新导致的性能问题和不必要的资源消耗。</p>
</blockquote>
<p>​    然而，需要注意的是，由于异步更新机制，Vue 在某些特定场景下可能无法立即获取到最新的数据。如果需要在数据更新后立即执行某些操作，可以利用 Vue 提供的 <code>$nextTick</code> 方法或使用 Vue 的生命周期钩子函数来确保在更新完成后执行相应的操作。</p>
<p>​    总之，Vue 的更新机制保证了数据变化的高效处理，并通过合并操作减少了不必要的更新，提升了应用的性能和响应速度。</p>
<p>​    </p>
<h5 id="this-nextTick-作用及实现原理"><a href="#this-nextTick-作用及实现原理" class="headerlink" title="this.$nextTick() 作用及实现原理"></a>this.$nextTick() 作用及实现原理</h5><p>​    <code>this.$nextTick()</code> 是 Vue 实例提供的一个方法，用于在 DOM 更新完成后执行回调函数。它的作用是确保在下次 DOM 更新循环结束后执行回调函数，以获取到最新的 DOM 状态。</p>
<blockquote>
<p>实现原理：</p>
<ol>
<li>当调用 <code>this.$nextTick()</code> 方法时，Vue 会将传入的回调函数添加到一个队列中，该队列用于存储待执行的回调函数。</li>
<li>Vue 会检测当前是否存在微任务（Promise 或 MutationObserver）或宏任务（setTimeout 或 setImmediate）队列。</li>
<li>如果存在微任务或宏任务队列，则将回调函数添加到微任务或宏任务队列中，确保在下一个事件循环周期中执行。</li>
<li>如果当前不存在微任务或宏任务队列，则创建一个微任务队列，并将回调函数添加到其中。</li>
<li>在下一个事件循环周期中，Vue 会执行微任务队列中的所有回调函数，并将其从队列中移除。</li>
</ol>
</blockquote>
<p>​    通过这种机制，<code>this.$nextTick()</code> 方法可以保证在 DOM 更新完成后执行回调函数，以便获取到最新的 DOM 状态。这在某些场景下非常有用，比如在修改数据后立即获取更新后的 DOM 元素，或在更新后对某些 DOM 操作进行后续处理。</p>
<p>​    需要注意的是，由于 <code>this.$nextTick()</code> 方法使用了异步更新机制，因此回调函数的执行时机不是立即的，而是在下一个事件循环周期中。如果需要在回调函数执行完成后执行一些操作，可以在回调函数中进行处理，或者使用 <code>Promise</code> 或 <code>async/await</code> 来等待回调函数执行完成。</p>
<h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><h4 id="Vue-组件通讯有哪几种方式"><a href="#Vue-组件通讯有哪几种方式" class="headerlink" title="Vue 组件通讯有哪几种方式"></a>Vue 组件通讯有哪几种方式</h4><blockquote>
<ol>
<li><p>props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的</p>
</li>
<li><p>$parent,$children 获取当前组件的父组件和当前组件的子组件</p>
</li>
<li><p>父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用，用于跨级通讯)</p>
</li>
<li><p>$refs 获取组件实例</p>
</li>
<li><p>envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式</p>
</li>
<li><p>vuex 状态管理</p>
</li>
</ol>
</blockquote>
<p><strong>props &amp; $emit:</strong></p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>Son @changeData<span class="token operator">=</span><span class="token string">"changeData"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
 <span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'@/components/son'</span>
 <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
   name<span class="token punctuation">:</span><span class="token string">'Father'</span><span class="token punctuation">,</span>
   components<span class="token punctuation">:</span><span class="token punctuation">{</span>Son<span class="token punctuation">}</span><span class="token punctuation">,</span>
   methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
     <span class="token function">changeData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//来自子组件的数据</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span>el<span class="token operator">-</span>button @click<span class="token operator">=</span><span class="token string">"handleEmit"</span><span class="token operator">></span>通知父组件需要更改数据了<span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>button<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
 <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
   name<span class="token punctuation">:</span><span class="token string">'Son'</span><span class="token punctuation">,</span>
   methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
     <span class="token function">handleEmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'changeData'</span><span class="token punctuation">,</span><span class="token string">'这是来自子组件的数据'</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p><strong>$parent &amp; $children：</strong></p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>子组件<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span><span class="token string">"Son"</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
      sonData<span class="token punctuation">:</span> <span class="token string">'子组件的数据'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token function">sonHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'子组件的方法'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>fatherData<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//父组件的数据</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span><span class="token function">fantherHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//父组件的方法</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>Son<span class="token operator">></span>父组件<span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'./son.vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'father'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span><span class="token punctuation">{</span>
    Son
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
      fatherData<span class="token punctuation">:</span> <span class="token string">'父组件的数据'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token function">fantherHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'父组件的方法'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sonTitle<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//子组件的数据</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sonHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//子组件的方法</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>这里要注意父组件要在mounted（）这个生命周期对子组件进行取值因为在这时候子组件才完成了 created 与 mounted，并且获取到的数据是一个数组的形式。</p>
<p><strong>provide $ inject：</strong></p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*父组件*/</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
 provide<span class="token punctuation">:</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span><span class="token punctuation">{</span>
     provideData<span class="token punctuation">:</span> <span class="token string">'父组件的数据'</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*子组件*/</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  inject<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'provideData'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  created <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>provideName<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//"父组件的数据"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>$refs：</strong></p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>Son ref<span class="token operator">=</span><span class="token string">"son"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'./son.vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'father'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span><span class="token punctuation">{</span>
    Son
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>son<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*组件实例*/</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p><strong>envetBus：</strong></p>
<p>需要先创建一个公共的eventBus.js，并将Vue实例暴露出去</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p> 在需要组件通信的组件A中引入eventBus.js，并通过$emit发布回调事件</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>div<span class="token operator">></span>组件A<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>el<span class="token operator">-</span>button @click<span class="token operator">=</span><span class="token string">"changeData"</span><span class="token operator">></span>修改数据A<span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>button<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../bus.js"</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token function">changeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"editData"</span><span class="token punctuation">,</span> <span class="token string">'这是修改后的数据'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>组件B中同样引入eventBus.js文件，并通过$on监听事件回调</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>组件B<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../bus.js"</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mounted<span class="token punctuation">:</span><span class="token punctuation">{</span>
    EventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'editData'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> 
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<h4 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h4><p>在 Vue 中，父子组件之间可以通过 props 和事件来进行通信。</p>
<ol>
<li><p>父组件向子组件传递数据：通过在父组件中使用 props 将数据传递给子组件。子组件可以在其模板中通过使用 props 来接收父组件传递的数据。</p>
<p>父组件：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>ChildComponent <span class="token punctuation">:</span>message<span class="token operator">=</span><span class="token string">"parentMessage"</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">'./ChildComponent.vue'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      parentMessage<span class="token punctuation">:</span> <span class="token string">'Hello from parent'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    ChildComponent<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>子组件：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
</li>
<li><p>子组件通过触发事件改变父组件的值：子组件可以通过 $emit 方法触发自定义事件，从而通知父组件进行相应的操作。</p>
<p>父组件：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>ChildComponent <span class="token punctuation">:</span>counter<span class="token operator">=</span><span class="token string">"counter"</span> @increment<span class="token operator">=</span><span class="token string">"handleIncrement"</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>p<span class="token operator">></span>Counter<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> counter <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">'./ChildComponent.vue'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      counter<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    ChildComponent<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">handleIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>子组件：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"handleClick"</span><span class="token operator">></span>Increment<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'counter'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
</li>
</ol>
<p>​    通过上述方式，父子组件可以进行数据的传递和通信。子组件可以通过触发事件的方式来改变父组件的值。需要注意的是，子组件不能直接修改父组件的 props 数据，而是通过事件向父组件发送请求，由父组件进行相应的操作来修改数据。</p>
<p>​    如果子组件需要修改父组件的数据，父组件可以将需要修改的数据作为 props 传递给子组件，然后子组件通过触发事件来请求父组件进行数据的修改。这样可以保持数据流的单向性，提高组件的可维护性和可预测性。</p>
<h4 id="平行组件通信"><a href="#平行组件通信" class="headerlink" title="平行组件通信"></a>平行组件通信</h4><p>在 Vue 中，平行组件之间的通信可以通过以下几种方式实现：</p>
<blockquote>
<ol>
<li>使用共享状态（Shared State）：可以创建一个共享的数据源，例如 Vuex 状态管理库或者一个全局的事件总线。所有的平行组件都可以访问和修改这个共享的状态，从而实现通信。</li>
<li>使用父组件作为中介：如果平行组件位于同一个父组件下，可以通过父组件作为中介来进行通信。平行组件通过将需要共享的数据或者方法传递给父组件，再由父组件将数据或者方法传递给其他平行组件。</li>
<li>使用事件总线：可以创建一个全局的事件总线，利用 Vue 的实例作为事件中心，平行组件通过订阅和触发事件来进行通信。</li>
<li>使用浏览器的事件系统：平行组件可以通过浏览器的事件系统（如 <code>window.dispatchEvent</code> 和 <code>window.addEventListener</code>）来进行通信。组件可以通过触发自定义事件，然后在其他组件中通过监听这些事件来实现通信。</li>
<li>使用非父子组件通信插件：可以使用一些 Vue 的插件来实现非父子组件之间的通信，例如 Vue Bus、mitt 等。</li>
</ol>
</blockquote>
<p>​    需要根据具体的场景和需求选择合适的通信方式。在选择通信方式时，可以考虑组件之间的关系、数据的复杂度以及通信的频率等因素。</p>
<h3 id="状态管理-Vuex"><a href="#状态管理-Vuex" class="headerlink" title="状态管理 - Vuex"></a>状态管理 - Vuex</h3><p>​    Vuex是Vue.js官方提供的状态管理模式和库。它被设计用于解决Vue应用中的状态管理问题。Vuex基于Flux架构和Redux模式，提供了一种集中管理和共享状态的机制。</p>
<p>Vuex的核心概念包括：</p>
<blockquote>
<ol>
<li>State（状态）：用于存储应用的状态数据，类似于组件中的data。它是响应式的，可以通过getter获取和修改。</li>
<li>Mutation（变更）：用于修改状态的方法，类似于组件中的methods。只能进行同步操作，且只能在mutation中修改状态。</li>
<li>Action（动作）：用于处理异步操作或复杂的业务逻辑，可以包含多个mutation的组合。可以触发mutation来修改状态。</li>
<li>Getter（获取器）：用于派生状态，类似于组件中的computed。可以对状态进行计算和包装，提供派生的数据。</li>
<li>Module（模块）：将大型应用的状态拆分为多个模块，每个模块有自己的state、mutation、action和getter。</li>
</ol>
</blockquote>
<p>​    通过使用Vuex，我们可以集中管理和共享应用的状态，使得状态的变化和处理逻辑更可控和可维护。它适用于大型的、状态复杂的应用，可以简化组件之间的通信，提高代码的可读性和可测试性。同时，Vuex也提供了开发工具和插件，方便调试和扩展。</p>
<p>​    在Vue应用中使用Vuex需要先安装和配置，然后在组件中引入和使用。通过定义state、mutations、actions和getters，我们可以在组件中访问和修改共享状态。Vuex还提供了一些辅助函数和工具，用于简化使用和处理异步操作。</p>
<h4 id="mutations-能不能做异步"><a href="#mutations-能不能做异步" class="headerlink" title="mutations 能不能做异步"></a>mutations 能不能做异步</h4><p>​    在Vuex中，mutations默认是同步操作，只能用于修改状态的同步变更。这是为了确保状态的变更是可追踪和可预测的。</p>
<p>​    在某些情况下，我们可能需要在mutations中进行异步操作，比如在异步请求数据后再修改状态。然而，直接在mutations中执行异步操作是不被推荐的做法，因为它会破坏状态变更的可追踪性。</p>
<p>​    如果需要进行异步操作，可以使用actions来处理。Actions可以包含异步操作，并且可以触发mutations来修改状态。这样可以保持状态变更的可追踪性，同时也可以方便地进行异步处理。</p>
<p>示例代码：</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Vuex store</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    count<span class="token punctuation">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">decrement</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">asyncIncrement</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 在组件中使用</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'decrement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">asyncIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'asyncIncrement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    在上述示例中，通过<code>context.commit</code>来触发mutation的执行，<code>this.$store.dispatch</code>来触发action的执行。这样就可以实现异步操作并且保持状态变更的可追踪性。</p>
<p>​    虽然mutations默认是同步操作，但可以通过actions来处理异步操作，并在actions中触发mutations来修改状态。这样可以更好地控制和管理状态的变更过程。</p>
<h4 id="Vuex-页面刷新数据丢失怎么解决"><a href="#Vuex-页面刷新数据丢失怎么解决" class="headerlink" title="Vuex 页面刷新数据丢失怎么解决"></a>Vuex 页面刷新数据丢失怎么解决</h4><p>​    当刷新页面时，由于Vuex中的数据存储在内存中，数据会丢失。这是因为Vuex是基于客户端的状态管理库，数据不会被持久化保存。每次刷新页面都会重新初始化Vuex的状态。</p>
<p>​    为了解决刷新页面导致Vuex数据丢失的问题，可以考虑以下几种方法：</p>
<blockquote>
<ol>
<li>使用持久化方案：可以将Vuex的状态持久化保存到本地存储（如localStorage或sessionStorage）中。在应用初始化时，从本地存储中读取状态并还原到Vuex中。这样可以在刷新页面后重新加载保存的状态，避免数据丢失。</li>
<li>利用路由参数或URL查询参数传递数据：将需要持久化的数据通过路由参数或URL查询参数传递给其他页面。这样在刷新页面时，可以通过获取路由参数或URL查询参数来恢复数据。</li>
<li>使用后端存储方案：如果应用需要长期保存状态数据，并且在不同设备或浏览器中共享状态，可以考虑将状态数据存储在后端服务器或数据库中。在刷新页面时，可以通过请求后端获取保存的状态数据并还原到Vuex中。</li>
</ol>
</blockquote>
<p>​    vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件。推荐使用 <code>vuex-persist</code> 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中</p>
<blockquote>
<p>​    ps: 需要根据具体的应用场景和需求选择适合的方法。持久化方案和后端存储方案可能需要进行数据序列化和反序列化操作，以确保数据的正确保存和恢复。同时，需要注意数据的安全性和隐私保护，避免敏感数据泄露。</p>
</blockquote>
<h4 id="Vuex-和-localStorage-的区别"><a href="#Vuex-和-localStorage-的区别" class="headerlink" title="Vuex 和 localStorage 的区别"></a>Vuex 和 localStorage 的区别</h4><p>Vuex和localStorage是两种不同的概念和用途：</p>
<blockquote>
<ol>
<li>Vuex：Vuex是Vue.js官方提供的状态管理库。它用于在Vue应用中集中管理和共享状态。Vuex的目的是解决组件之间共享数据、状态管理和数据流的问题。Vuex提供了一种集中式的数据存储机制，可以在多个组件中访问和修改共享的状态，以实现组件之间的通信和数据同步。Vuex的数据存储在内存中，它是基于内存的状态管理解决方案，适用于应用内部的数据共享和状态管理。</li>
<li>localStorage：localStorage是Web浏览器提供的一种本地存储机制。它允许将数据以键值对的形式存储在浏览器的本地存储空间中，并且数据在页面刷新或关闭后仍然保持有效。localStorage提供了持久化的存储能力，可以在不同的页面和会话中共享数据。localStorage中的数据以字符串形式存储，需要进行数据的序列化和反序列化。</li>
</ol>
</blockquote>
<p>区别：</p>
<blockquote>
<ul>
<li>Vuex是专门为Vue应用设计的状态管理库，用于管理应用内的状态和数据流，解决组件之间的数据共享和状态管理问题。而localStorage是Web浏览器提供的一种本地存储机制，用于持久化地存储数据，并且在不同的浏览器会话中共享数据。</li>
<li>Vuex的数据存储在内存中，适用于应用内部的数据共享和状态管理，而localStorage的数据存储在浏览器的本地存储空间中，可以在不同的页面和会话中共享数据。</li>
<li>Vuex提供了一套API和机制用于管理和修改状态，包括使用mutation修改状态、使用action处理异步操作等。而localStorage是基于键值对的简单存储机制，只能通过setItem和getItem等方法进行基本的数据存储和读取，没有提供数据管理和状态变更的机制。</li>
</ul>
</blockquote>
<p>​    Vuex适用于Vue应用内部的状态管理和数据共享，而localStorage适用于持久化地存储和共享数据。在具体使用时，可以根据应用需求选择合适的方案或结合两者使用。</p>
<h3 id="虚拟-dom-和-diff-算法"><a href="#虚拟-dom-和-diff-算法" class="headerlink" title="虚拟 dom 和 diff 算法"></a>虚拟 dom 和 diff 算法</h3><p>​    虚拟DOM（Virtual DOM）和差异算法（Diff Algorithm）是前端领域中常用的概念，它们在优化页面渲染性能和提升开发效率方面发挥了重要作用。</p>
<blockquote>
<p>​    虚拟DOM是一种以JavaScript对象形式表示的轻量级的内存中的DOM表示。它是对真实DOM的一种抽象和模拟，在内存中进行操作和计算，然后再将结果批量更新到真实的DOM上。虚拟DOM的目的是在保持视图和状态同步的同时，减少对真实DOM的直接操作，从而提升性能和响应速度。</p>
<p>​    差异算法（Diff Algorithm）是虚拟DOM的核心算法之一，用于比较两个虚拟DOM树之间的差异，并将差异应用到真实的DOM上。通过比较新旧虚拟DOM树的差异，可以准确地找出需要更新的部分，避免全量更新整个DOM树，从而减少不必要的操作和性能损耗。</p>
</blockquote>
<p>​    Diff算法的基本原理是对比新旧虚拟DOM树的节点，找出发生变化的节点，然后根据变化类型（插入、更新、移除等）对真实DOM进行相应的操作。Diff算法通常采用深度优先遍历的方式，通过递归遍历虚拟DOM树的节点，对比节点之间的差异，生成更新操作的指令。</p>
<p>常用的Diff算法有两种实现方式：基于递归的Diff算法和基于循环的Diff算法。</p>
<blockquote>
<p>​    基于递归的Diff算法简单直观，但在处理大型虚拟DOM树时可能存在性能问题。</p>
<p>​    基于循环的Diff算法采用迭代的方式，通过循环遍历虚拟DOM树的节点，以较低的时间复杂度找出差异。</p>
</blockquote>
<p>​    虚拟DOM和差异算法是前端开发中用于优化页面渲染性能的重要技术。虚拟DOM提供了一种高效的内存中的DOM表示，而差异算法则能够准确地比较两个虚拟DOM树之间的差异，最小化对真实DOM的操作，从而提高页面的性能和响应速度。</p>
<h4 id="什么是虚拟-dom-？有什么用？"><a href="#什么是虚拟-dom-？有什么用？" class="headerlink" title="什么是虚拟 dom ？有什么用？"></a>什么是虚拟 dom ？有什么用？</h4><p>​    虚拟DOM（Virtual DOM）是一种在内存中构建和操作的虚拟的DOM树。它是对真实DOM的一种抽象和模拟，用JavaScript对象表示整个DOM结构及其属性。</p>
<p>​    虚拟DOM的基本思想是将页面的状态（数据）和视图（DOM）分离，通过对虚拟DOM的操作来更新视图，而不是直接操作真实的DOM。当数据发生变化时，会通过比较新旧虚拟DOM的差异（Diff算法），找出需要更新的部分，然后将更新应用到真实DOM上，从而保持页面和数据的同步。</p>
<p>虚拟DOM的主要优点包括：</p>
<blockquote>
<ol>
<li>性能优化：通过将DOM操作集中在虚拟DOM上，减少了直接操作真实DOM的次数，从而提高了性能。虚拟DOM可以批量更新真实DOM，避免了频繁的重绘和回流。</li>
<li>跨平台能力：虚拟DOM可以在不同的平台上运行，例如浏览器、移动端、服务器端等。这样可以实现一次编写，多平台复用。</li>
<li>方便的UI组件化：虚拟DOM可以将整个页面划分为组件，每个组件都有自己的虚拟DOM。这样可以实现组件的高度复用和模块化开发。</li>
<li>简化复杂的UI更新逻辑：通过比较新旧虚拟DOM的差异，可以精确地找出需要更新的部分，避免全量更新整个DOM树，从而简化了复杂的UI更新逻辑。</li>
</ol>
</blockquote>
<p>​    虚拟DOM通过在内存中构建和操作DOM的抽象表示，提供了一种高效、跨平台、组件化的方式来管理和更新页面的视图。它是现代前端框架（如React、Vue等）中的重要概念，能够提升开发效率和页面性能。</p>
<h5 id="虚拟DOM的解析过程"><a href="#虚拟DOM的解析过程" class="headerlink" title="虚拟DOM的解析过程:"></a>虚拟DOM的解析过程:</h5><p>虚拟DOM的解析过程可以简单分为三个步骤：<strong>创建</strong>、<strong>更新</strong>和<strong>渲染</strong>。</p>
<blockquote>
<ol>
<li>创建虚拟DOM（Virtual DOM）：在应用程序初始化时，通过使用特定的语法或调用相关API创建虚拟DOM。虚拟DOM是使用JavaScript对象表示整个DOM结构及其属性，它包括节点类型、标签名、属性、子节点等信息。</li>
<li>更新虚拟DOM：当应用程序的状态（数据）发生变化时，需要更新虚拟DOM以反映这些变化。这个过程通常由框架或库内部的更新机制自动处理，它会根据新的数据生成新的虚拟DOM，并与旧的虚拟DOM进行比较，找出差异（Diff算法）。</li>
<li>渲染虚拟DOM：在更新虚拟DOM后，需要将最新的虚拟DOM渲染到真实的DOM上，以更新页面的显示。这个过程通常由框架或库提供的渲染引擎负责处理，它会根据虚拟DOM的变化，将变化部分应用到真实DOM上，从而更新页面的内容。</li>
</ol>
</blockquote>
<p>具体来说，虚拟DOM的解析过程如下：</p>
<blockquote>
<ol>
<li>创建虚拟DOM：根据应用程序的需求，通过特定的语法或调用相关API创建虚拟DOM。这可以是手动创建的，也可以是由框架或库自动生成的。</li>
<li>更新虚拟DOM：当应用程序的状态发生变化时，生成新的虚拟DOM，并与旧的虚拟DOM进行比较，找出差异（Diff算法）。差异通常包括节点的增、删、改、移等操作。</li>
<li>应用差异：将差异应用到真实DOM上，更新页面的显示。这个过程可以通过操作真实DOM进行，也可以通过一些优化技术（例如批量更新、异步渲染等）来提高性能。</li>
<li>渲染页面：根据最新的虚拟DOM，将其渲染到真实DOM上，更新页面的内容。这可以是整个虚拟DOM的渲染，也可以是部分虚拟DOM的渲染，具体取决于差异的范围。</li>
</ol>
</blockquote>
<p>​    虚拟DOM的解析过程是一个通过创建、更新和渲染虚拟DOM来实现页面更新的过程。它通过比较差异，减少了对真实DOM的频繁操作，提高了性能和用户体验。</p>
<h4 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h4><p>​    Diff算法是虚拟DOM更新的核心算法，它用于比较新旧虚拟DOM之间的差异，并根据差异进行最小化的DOM操作，以提高更新效率。</p>
<p>​    Diff算法的基本原理是通过逐层比较新旧虚拟DOM的节点，找出节点之间的差异，并记录下来。它遵循以下几个基本规则：</p>
<blockquote>
<ol>
<li>同层比较：Diff算法会逐层比较新旧虚拟DOM的节点，并将它们进行一一对比。如果节点类型不同，直接替换节点；如果节点类型相同但属性不同，更新节点的属性；如果节点类型和属性都相同，继续比较其子节点。</li>
<li>列表比较：当比较的节点是列表（数组）类型时，Diff算法会使用特定的算法进行列表比较，例如使用唯一的key来标识列表项，以避免整个列表重新渲染。</li>
<li>唯一标识：Diff算法会使用唯一的标识（通常是key属性）来识别节点，以便在比较过程中准确定位节点的位置，从而进行精确的差异对比和操作。</li>
<li>递归比较：Diff算法会递归地比较节点的子节点，以确保所有层级的差异都能被发现和处理。</li>
</ol>
</blockquote>
<p>​    通过以上规则，Diff算法能够在比较的过程中找出两个虚拟DOM之间的差异，并生成一个差异对象（或称为补丁），记录下需要进行的DOM操作，例如插入、删除、更新等。然后，这个差异对象可以被应用到真实的DOM上，进行最小化的DOM操作，以实现页面的更新。</p>
<p>​    Diff算法的优点是能够准确地识别差异，并最小化DOM操作，提高页面更新的效率。然而，它也有一些限制和性能方面的考虑，例如当比较的虚拟DOM结构非常复杂时，Diff算法的性能可能会下降，需要合理地设计虚拟DOM结构和优化更新策略来提升性能。</p>
<p>​    Diff算法是虚拟DOM实现高效更新的核心，它通过比较新旧虚拟DOM之间的差异，实现最小化的DOM操作，从而提高页面更新的效率。</p>
<h4 id="Vue-中-key-的作用"><a href="#Vue-中-key-的作用" class="headerlink" title="Vue 中 key 的作用"></a>Vue 中 key 的作用</h4><p>在Vue中，key是用于识别VNode（虚拟DOM节点）的特殊属性。它的作用主要有以下几个方面：</p>
<blockquote>
<ol>
<li>提供唯一标识：每个VNode都应该具有唯一的key值，用于在diff算法中准确地识别VNode节点的变化。通过key，Vue可以精确地判断哪些VNode是新增的、哪些是删除的，从而最小化DOM操作，提高页面更新的效率。</li>
<li>优化列表渲染：当使用v-for指令进行列表渲染时，每个列表项都应该提供一个唯一的key值。这样，Vue可以基于key的变化来确定列表项的新增、删除、移动等操作，从而避免重新渲染整个列表，提高列表渲染的性能。</li>
<li>维持组件状态：当使用key在动态组件或条件渲染中切换组件时，key的变化可以强制Vue销毁旧组件并创建新组件。这样做可以保持组件的状态和避免重用旧组件的状态，确保组件能够正确地更新和重新渲染。</li>
</ol>
</blockquote>
<p>​    需要注意的是，key的值应该是稳定且唯一的。在使用v-for渲染列表时，推荐使用具有唯一性的属性值作为key，如ID或其他唯一标识符。避免使用索引作为key，因为索引在列表发生变化时可能会导致错误的渲染结果。</p>
<p>​    Vue中的key属性用于唯一标识VNode，它在diff算法中起着重要的作用，能够提高页面更新的效率、优化列表渲染，并维持组件的状态。合理使用key可以确保Vue能够准确地识别和处理VNode的变化，提供更好的性能和用户体验。</p>
<h3 id="Vue2-与-Vue3的区别"><a href="#Vue2-与-Vue3的区别" class="headerlink" title="Vue2 与 Vue3的区别"></a>Vue2 与 Vue3的区别</h3><h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><blockquote>
<ul>
<li>Vue2：Vue2的生命周期包括beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed等钩子函数。这些钩子函数允许我们在组件的不同生命周期阶段执行特定的操作，例如在created钩子函数中进行数据初始化，在mounted钩子函数中操作DOM元素等。</li>
<li>Vue3：Vue3保留了大部分Vue2的生命周期钩子函数，但也引入了新的钩子函数如setup。setup钩子函数用于代替Vue2中的beforeCreate和created钩子函数，它提供了更灵活的组合式函数编程方式，可以更好地封装组件逻辑和复用代码。</li>
</ul>
</blockquote>
<h4 id="Diff算法："><a href="#Diff算法：" class="headerlink" title="Diff算法："></a>Diff算法：</h4><blockquote>
<ul>
<li>Vue2：Vue2使用基于虚拟DOM的Diff算法来计算需要更新的最小操作，然后将这些操作应用于真实的DOM树。Vue2的Diff算法会比较新旧虚拟DOM树的差异，然后只对差异部分进行更新，以减少不必要的DOM操作，提高性能和渲染效率。</li>
<li>Vue3：Vue3在Diff算法方面进行了优化。首先，Vue3使用了基于Proxy的响应式系统，通过代理对象来监听数据的变化，从而减少了对getter和setter的劫持，提升了性能。其次，Vue3引入了静态标记，即在编译阶段对模板进行静态分析，标记出静态节点，从而避免在Diff算法中对这些静态节点进行比较，进一步提高了性能和渲染效率。</li>
</ul>
</blockquote>
<h4 id="数据响应式原理："><a href="#数据响应式原理：" class="headerlink" title="数据响应式原理："></a>数据响应式原理：</h4><blockquote>
<ul>
<li>Vue2：Vue2使用Object.defineProperty实现数据的响应式。当数据被访问或修改时，Vue2通过劫持数据的get和set方法来追踪数据的变化。这样一来，当数据发生变化时，Vue2能够检测到变化并通知相关的组件进行更新。</li>
<li>Vue3：Vue3使用Proxy对象实现数据的响应式。Proxy对象可以代理目标对象并拦截对目标对象的访问和修改操作。通过代理对象的监听和触发机制，Vue3能够实时地追踪数据的变化，并触发相应的更新操作，从而实现数据响应式。</li>
</ul>
</blockquote>
<h4 id="组件通讯："><a href="#组件通讯：" class="headerlink" title="组件通讯："></a>组件通讯：</h4><blockquote>
<ul>
<li>Vue2：Vue2中组件通讯主要通过props和$emit进行父子组件之间的通讯。父组件通过props将数据传递给子组件，子组件通过$emit触发自定义事件来通知父组件。此外，Vue2还提供了事件总线、Vuex等方式来实现非父子组件之间的通讯。</li>
<li>Vue3：Vue3保留了Vue2的组件通讯方式，即父子组件之间通过props和emit进行通讯。而与Vue2不同的是，Vue3引入了Composition API，提供了更灵活的组合式函数编程方式来处理组件之间的通讯。通过使用Composition API中的响应式函数、上下文传递等特性，我们可以更方便地在组件之间共享状态和方法。</li>
</ul>
</blockquote>
<h4 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h4><p>​    Composition API 是 Vue 3 中引入的一种新的 API 风格，用于编写组件的逻辑和复用代码。它是一种基于函数的 API，与 Vue 2 中的选项式 API（Options API）相比，Composition API 更加灵活、组合性更强，能够更好地组织和管理组件的代码。</p>
<p>​    使用 Composition API，我们可以将一个组件的相关逻辑聚合在一起，而不是按照选项的顺序分散在不同的生命周期钩子函数中。这使得组件的逻辑更加清晰、可读性更高，同时也方便代码的复用和测试。</p>
<p>​    Composition API 提供了一系列的函数和响应式的 API，例如 <code>setup</code> 函数、<code>ref</code>、<code>reactive</code>、<code>watch</code> 等，用于定义组件的状态和行为。下面是 Composition API 的一些特点和用法：</p>
<blockquote>
<ol>
<li><code>setup</code> 函数：在组件中使用 <code>setup</code> 函数来定义组件的状态和行为。<code>setup</code> 函数在组件创建之前执行，可以访问组件的 props 和 context，并返回一个对象，这个对象中的属性和方法将被暴露给组件的模板部分使用。</li>
<li><code>ref</code> 和 <code>reactive</code>：<code>ref</code> 和 <code>reactive</code> 是用于创建响应式数据的 API。<code>ref</code> 用于创建一个单一的响应式数据，而 <code>reactive</code> 用于创建一个包含多个属性的响应式对象。</li>
<li><code>watch</code>：<code>watch</code> 函数用于监听响应式数据的变化，并在数据变化时执行相应的操作。它可以监听单个数据或多个数据，还可以设置深度监听、异步监听等。</li>
<li>生命周期钩子函数：在 Composition API 中，生命周期钩子函数的命名发生了变化，例如 <code>beforeCreate</code> 和 <code>created</code> 改为了 <code>onBeforeMount</code> 和 <code>onMounted</code>。这些钩子函数可以在 <code>setup</code> 函数中使用，与其他逻辑代码一起组合。</li>
<li>自定义函数：在 Composition API 中，我们可以自定义函数来封装和复用一些逻辑代码，而不必依赖于特定的生命周期钩子函数。</li>
</ol>
</blockquote>
<p>​    使用 Composition API，我们能够更好地组织组件的代码，提高代码的可读性和维护性。它适用于编写中小型到大型复杂组件，并且提供了更好的代码复用和测试能力。</p>
<p>​    Vue3在许多其他方面也进行了改进和优化，如编译优化、TypeScript支持、组合式API等。开发者在选择Vue版本时，需要根据项目需求和实际情况综合考虑，以及考虑迁移成本和团队熟悉度等因素。</p>
<h4 id="vue2以及vue3的diff算法有了解吗-他们之间的不同是什么"><a href="#vue2以及vue3的diff算法有了解吗-他们之间的不同是什么" class="headerlink" title="vue2以及vue3的diff算法有了解吗 他们之间的不同是什么"></a>vue2以及vue3的diff算法有了解吗 他们之间的不同是什么</h4><p>Vue.js的diff算法是其用于比较新旧虚拟DOM树并确定最小更新集的核心机制。Vue 2和Vue 3的diff算法在设计和实现上有一些重要的不同。</p>
<p><strong>Vue 2的diff算法</strong></p>
<p>Vue 2的diff算法主要关注于组件级别的更新，而不是细粒度的DOM节点级别的比较。以下是Vue 2 diff算法的一些关键点：</p>
<ol>
<li><strong>同级比较</strong>：Vue 2的diff算法只比较同一层级的节点，不跨层级比较。</li>
<li><strong>双端比较</strong>：当列表更新时，Vue 2会采用双端比较的策略，从列表的头部和尾部开始比较，然后逐渐向中心逼近，以尽量减少节点的移动次数。</li>
<li><strong>更新策略</strong>：当无法通过头尾比较找到匹配的节点时，Vue 2会尝试复用旧节点，通过更新节点的属性或子节点来匹配新的虚拟节点，并将其移动到正确的位置。</li>
</ol>
<p>然而，Vue 2的diff算法也存在一些限制，例如它不会进行跨层级的节点比较，这可能导致一些不必要的DOM操作。</p>
<p><strong>Vue 3的diff算法</strong></p>
<p>Vue 3对diff算法进行了重大改进，以进一步提高性能并减少不必要的DOM操作。以下是Vue 3 diff算法的一些主要变化：</p>
<ol>
<li><strong>基于Proxy的响应式系统</strong>：Vue 3使用了基于Proxy的响应式系统，能够更精确地追踪数据变化，从而减少了不必要的计算和渲染。这使得diff算法在比较新旧虚拟DOM树时能够更准确地确定需要更新的部分。</li>
<li><strong>静态提升</strong>：Vue 3在编译阶段会对模板进行静态分析，将不会改变的静态节点提升到渲染函数之外。这样，在每次渲染时，这些静态节点就不会被重新创建和比较，从而减少了不必要的计算和DOM操作。</li>
<li><strong>块级更新</strong>：Vue 3引入了块级更新的概念，将组件树拆分为多个块，每个块都拥有自己的渲染函数和依赖关系。当某个块的数据发生变化时，只有该块及其子块会被重新渲染和比较，而不是整个组件树。这进一步减少了不必要的计算和DOM操作。</li>
<li><strong>事件监听器的优化</strong>：Vue 3对事件监听器进行了优化，使用了一种称为“事件委托”的技术来减少事件监听器的数量。这样，当事件触发时，Vue 3可以更快地找到并处理相应的事件监听器，从而提高了性能。</li>
</ol>
<p>总的来说，Vue 3的diff算法通过更精确的追踪数据变化、静态提升、块级更新和事件监听器的优化等手段，进一步提高了Vue应用的渲染性能和用户体验。</p>
<h4 id="Vue3相对于Vue2进行了哪些优化？"><a href="#Vue3相对于Vue2进行了哪些优化？" class="headerlink" title="Vue3相对于Vue2进行了哪些优化？"></a>Vue3相对于Vue2进行了哪些优化？</h4><ol>
<li><strong>更灵活的响应式系统</strong>：Vue 2.x 中响应式系统的核心是 <strong>Object.defineProperty</strong>，劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式。Vue 3.x 中使用 <strong>Proxy</strong>对象重写响应式系统。</li>
<li><strong>更快的渲染速度</strong>：Vue3 的编译器生成的渲染函数比 Vue2 生成的更高效。</li>
<li><strong>编译阶段</strong>：Vue 2.x 通过标记静态节点，优化 diff 的过程。Vue 3.x中<strong>标记和提升</strong>所有的静态节点，diff的时候<strong>只需要对比动态节点</strong>内容。</li>
<li><strong>更小的体积</strong>：Vue3 将源码拆分为多个独立的模块，这样就可以按需导入所需的模块，从而减小了整个库的体积。</li>
<li><strong>更好的 TypeScript 支持</strong>：Vue3 对 TypeScript 的支持更加友好，内部使用了更先进的 TypeScript 特性，并为其提供了更好的声明文件。</li>
<li><strong>更好的组件系统</strong>：比如，Vue3中引入了一个新的 <code>Fragment</code> 组件，它可以替代原来的 <code>template</code> 标签作为根节点</li>
<li><strong>新增了setup组合式API</strong></li>
</ol>
<h3 id="路由-vue-router"><a href="#路由-vue-router" class="headerlink" title="路由 - vue-router"></a>路由 - vue-router</h3><h4 id="vue-router-中常用的路由模式实现原理吗"><a href="#vue-router-中常用的路由模式实现原理吗" class="headerlink" title="vue-router 中常用的路由模式实现原理吗"></a>vue-router 中常用的路由模式实现原理吗</h4><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a><strong>hash 模式</strong></h5><ol>
<li>location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li>
<li>可以为 hash 的改变添加监听事件</li>
</ol>
<pre class=" language-javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"hashchange"</span><span class="token punctuation">,</span> funcRef<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了</p>
<blockquote>
<p>特点：兼容性好但是不美观</p>
</blockquote>
<h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a><strong>history 模式</strong></h5><p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p>
<p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p>
<blockquote>
<p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p>
</blockquote>
<h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><p>路由守卫是在路由导航过程中进行拦截和控制的功能。</p>
<p>Vue Router 提供了以下几种类型的路由守卫：</p>
<blockquote>
<ol>
<li>全局前置守卫（Global Before Guards）：<ul>
<li><code>beforeEach(to, from, next)</code>：在每个路由跳转之前调用，可以用来进行全局的前置验证或处理逻辑。</li>
</ul>
</li>
<li>路由独享的守卫（Per-Route Guards）：<ul>
<li><code>beforeEnter(to, from, next)</code>：在某个特定路由配置中定义的守卫，只会对该路由生效。</li>
</ul>
</li>
<li>组件内的守卫（In-Component Guards）：<ul>
<li><code>beforeRouteEnter(to, from, next)</code>：在进入路由对应的组件之前调用，可以访问组件实例，但此时组件实例还没有被创建。</li>
<li><code>beforeRouteUpdate(to, from, next)</code>：在当前路由组件复用时调用，例如在同一路由下切换不同的参数。</li>
<li><code>beforeRouteLeave(to, from, next)</code>：在离开当前路由组件时调用，可以阻止离开或在离开前进行一些处理。</li>
</ul>
</li>
</ol>
</blockquote>
<p>这些守卫函数接收三个参数：</p>
<ul>
<li><code>to</code>：即将进入的目标路由对象</li>
<li><code>from</code>：当前导航正要离开的路由对象</li>
<li><code>next</code>：函数，用于进入下一个守卫或确认导航</li>
</ul>
<p>在守卫函数中，可以通过调用 <code>next()</code> 方法来进行导航控制：</p>
<ul>
<li>调用 <code>next()</code> 进行正常导航</li>
<li>调用 <code>next(false)</code> 中止当前导航</li>
<li>调用 <code>next(&#39;/path&#39;)</code> 或 <code>next(&#123; path: &#39;/path&#39; &#125;)</code> 进行重定向导航</li>
</ul>
<p>使用路由守卫可以实现诸如登录验证、权限控制、页面访问限制等功能，提供了灵活且强大的路由导航控制机制。 <a target="_blank" rel="noopener" href="https://router.vuejs.org/guide/advanced/navigation-guards.html">Vue Router 的官方文档</a></p>
<h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><h4 id="Vue3中组合式Api对比选项式Api的区别与优势"><a href="#Vue3中组合式Api对比选项式Api的区别与优势" class="headerlink" title="Vue3中组合式Api对比选项式Api的区别与优势"></a>Vue3中组合式Api对比选项式Api的区别与优势</h4><p>Vue 3中引入的组合式API（Composition API）与Vue 2中的选项式API（Options API）在设计和使用上有一些明显的区别与优势。</p>
<p><strong>区别</strong>：</p>
<ol>
<li><strong>结构组织</strong>：选项式API基于对象的设计方式，将Vue实例的各个部分（如data、methods、computed、watch等）拆分成不同的选项，并在创建Vue实例时将它们作为选项传入。而组合式API允许将数据和方法组合在一起，以提供更灵活和可复用的逻辑代码。</li>
<li><strong>代码复用</strong>：随着应用规模的扩大和复杂度的增加，选项式API可能导致代码难以维护和理解。数据和逻辑被分散在多个选项中，很难一眼看出它们之间的关系。而组合式API通过将逻辑封装为自定义函数，可以更好地复用逻辑代码。</li>
<li><strong>类型推断</strong>：Vue 3的组合式API更适用于TypeScript等类型检查工具。使用组合式API，TypeScript可以更准确地推断和捕获类型信息，提供更好的代码补全和错误检测。</li>
</ol>
<p><strong>优势</strong>：</p>
<ol>
<li><strong>代码组织</strong>：组合式API可以更好地组织代码，将相关逻辑代码封装在函数中，按照功能和关注点进行组织。这使得代码更清晰、模块化，并且易于理解和维护。</li>
<li><strong>复用性</strong>：组合式API通过封装逻辑为可复用的函数，提高了代码的复用性。可以根据需要选择性地调用这些函数，并在多个组件之间共享它们。</li>
<li><strong>直观性</strong>：在Vue 3的组合式API中，生命周期钩子函数（如created、mounted、updated、destroyed等）被替代为更直观和一致的函数调用，这使得代码更易于理解和维护。</li>
</ol>
<p>总的来说，组合式API通过提供更好的代码组织、复用性和直观性，解决了选项式API在大型和复杂应用中可能遇到的问题。然而，这并不意味着选项式API已经完全被取代。在Vue 3中，对两种API都提供了支持，开发者可以根据项目的具体需求和自己的偏好来选择使用哪种API。对于简单的场景，使用选项式API可能更加简单方便；而对于需要强烈支持TypeScript或大量逻辑复用的场景，组合式API可能是更好的选择。</p>
<h4 id="Vue3中watch-和-watchEffect-的区别"><a href="#Vue3中watch-和-watchEffect-的区别" class="headerlink" title="Vue3中watch 和 watchEffect 的区别"></a>Vue3中watch 和 watchEffect 的区别</h4><p>在 Vue 3 中，<code>watch</code> 和 <code>watchEffect</code> 都是用于响应式地观察和响应 Vue 组件中的数据变化的方法，但它们之间有一些重要的区别。</p>
<p><strong>watch</strong></p>
<p><code>watch</code> 是 Vue 2.x 和 Vue 3 中都存在的一个功能，它用于侦听特定的数据源，并在其变化时执行回调函数。<code>watch</code> 需要明确指定要侦听的数据源和回调函数。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>明确指定</strong>：你需要明确指定要侦听的数据源，以及当该数据源变化时要执行的回调函数。</li>
<li><strong>获取新旧值</strong>：在回调函数中，你可以获取到数据源变化前后的值（新值和旧值）。</li>
<li><strong>选项丰富</strong>：<code>watch</code> 提供了一些选项，如 <code>immediate</code>（是否在初始化时立即调用一次回调函数）和 <code>deep</code>（是否深度侦听对象内部值的变化）。</li>
</ol>
<p><strong>使用场景：</strong></p>
<ul>
<li>当你需要侦听某个特定的 prop 或 data 属性时。</li>
<li>当你需要在数据源变化时执行一些异步操作或开销较大的操作时。</li>
</ul>
<p><strong>watchEffect</strong></p>
<p><code>watchEffect</code> 是 Vue 3 中新增的一个功能，它用于自动追踪其回调函数中的响应式依赖，并在依赖变化时重新执行该函数。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>自动追踪</strong>：<code>watchEffect</code> 会自动追踪其回调函数中所依赖的响应式数据。</li>
<li><strong>立即执行</strong>：默认情况下，<code>watchEffect</code> 在组件挂载后会立即执行一次回调函数，以捕获初始状态。</li>
<li><strong>无需明确指定依赖</strong>：与 <code>watch</code> 不同，你不需要明确指定要侦听哪些数据源，<code>watchEffect</code> 会自动帮你做这件事。</li>
</ol>
<p><strong>使用场景</strong>：</p>
<ul>
<li>当你需要自动追踪多个响应式依赖时。</li>
<li>当你需要在组件挂载后立即执行一些逻辑时（例如，获取初始数据）。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><code>watch</code> 适用于需要明确指定数据源和回调函数的情况，以及需要获取数据源变化前后值的情况。</li>
<li><code>watchEffect</code> 适用于自动追踪多个响应式依赖，并在依赖变化时重新执行回调函数的情况。它更加灵活和简洁，但可能不如 <code>watch</code> 那么精确。</li>
</ul>
<p>在选择使用 <code>watch</code> 还是 <code>watchEffect</code> 时，你应该根据你的具体需求和场景来决定。</p>
<h4 id="Vue3中render函数的作用"><a href="#Vue3中render函数的作用" class="headerlink" title="Vue3中render函数的作用"></a>Vue3中render函数的作用</h4><p>在 Vue 3 中，<code>render</code> 函数是一个高级特性，它允许你手动编写 JavaScript 来生成虚拟 DOM（Virtual DOM）节点，而不是使用模板语法。<code>render</code> 函数在 Vue 的运行时环境中扮演着将组件的逻辑转换为实际 DOM 结构的关键角色。</p>
<p><code>render</code> 函数接收一个名为 <code>createElement</code> 的函数作为参数，这个函数用于创建虚拟 DOM 节点。<code>createElement</code> 函数接受三个参数：</p>
<blockquote>
<ol>
<li><strong>标签名或组件对象</strong>：可以是原生 HTML 标签名（如 <code>&#39;div&#39;</code>、<code>&#39;span&#39;</code> 等），也可以是 Vue 组件对象。</li>
<li><strong>包含组件的 props/attributes 的数据对象</strong>：这个对象用于定义元素的属性、props、DOM 属性、类名、样式等。</li>
<li><strong>子虚拟节点数组</strong>：一个由 <code>createElement</code> 创建的虚拟节点数组，作为当前元素的子节点。</li>
</ol>
</blockquote>
<p><code>render</code> 函数通常用于以下场景：</p>
<blockquote>
<ol>
<li><strong>高级用法和自定义渲染</strong>：当你需要更细粒度的控制渲染逻辑时，可以使用 <code>render</code> 函数。例如，你可以动态地根据组件的状态和属性来渲染不同的 DOM 结构。</li>
<li><strong>与 JSX 或 TSX 配合使用</strong>：虽然 Vue 本身不直接支持 JSX（JavaScript XML），但你可以通过 Babel 插件（如 <code>@vue/babel-plugin-jsx</code>）将 JSX 转换为 Vue 的 <code>render</code> 函数。这样，你就可以在 Vue 组件中使用类似于 React 的 JSX 语法来编写渲染逻辑。</li>
<li><strong>渲染函数式组件</strong>：函数式组件（Functional Components）是那些没有状态（即没有响应式数据）和实例（即没有 <code>this</code> 上下文）的组件。这些组件只根据传入的 props 来渲染 DOM 结构，因此非常适合使用 <code>render</code> 函数来实现。</li>
</ol>
</blockquote>
<p>需要注意的是，尽管 <code>render</code> 函数提供了更大的灵活性，但在大多数情况下，使用 Vue 的模板语法已经足够满足需求。模板语法更加直观和易于理解，尤其是对于非专业前端开发者来说。因此，在不需要特殊渲染逻辑的情况下，建议使用模板语法来编写 Vue 组件。</p>
<h4 id="Vue3中的setup语法糖"><a href="#Vue3中的setup语法糖" class="headerlink" title="Vue3中的setup语法糖"></a>Vue3中的setup语法糖</h4><p>在 Vue 3 中，<code>setup</code> 函数是 Composition API 的入口点，它使得我们可以在组件中使用响应式数据、生命周期钩子、方法等，而不必依赖于传统的选项式 API（Options API）。然而，Vue 3 还引入了一种称为“语法糖”（Syntactic Sugar）的简化方式，以更简洁的方式使用 Composition API。</p>
<p>这种语法糖主要体现在两个方面：<code>&lt;script setup&gt;</code> 和 <code>ref</code>/<code>reactive</code> 的自动解构。</p>
<p><strong><code>&lt;script setup&gt;</code></strong></p>
<script setup> 是 Vue 3 单文件组件（SFC）中的一个新语法，允许你在 <script> 标签中使用 setup 函数，而无需显式地定义 setup 函数。这种语法会自动将 setup 函数的返回值暴露给模板。


示例：

```vue
<template>  
  <button @click="increment"></button>  
</template>  
  
<script setup>  
import { ref } from 'vue'  
  
const count = ref(0)  
const increment = () => {  
  count.value++  
}  
</script>
<pre><code>
在这个示例中，我们使用了 `&lt;script setup&gt;` 语法，并在其中定义了响应式引用 `count` 和一个方法 `increment`。这些都被自动暴露给模板，使得我们可以在模板中直接使用它们。

**`ref`/`reactive` 的自动解构**

在 `&lt;script setup&gt;` 中，你还可以直接使用 `ref` 或 `reactive` 创建的响应式数据，而无需通过 `.value` 来访问它（在模板中除外）。这是因为 Vue 编译器会自动对 `ref` 进行解构。

示例：

```vue
&lt;template&gt;  
  &lt;input v-model=&quot;message&quot; /&gt;  
  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;  
&lt;/template&gt;  
  
&lt;script setup&gt;  
import &#123; ref &#125; from &#39;vue&#39;  
  
const message = ref(&#39;&#39;)  
&lt;/script&gt;
</code></pre>
<p>在这个示例中，我们直接在 <code>&lt;script setup&gt;</code> 中定义了一个 <code>ref</code> 类型的响应式数据 <code>message</code>。在模板中，我们可以直接使用 <code>v-model=&quot;message&quot;</code> 而不是 <code>v-model=&quot;message.value&quot;</code>。在 <code>&lt;script setup&gt;</code> 的作用域内，我们可以直接通过 <code>message</code> 访问其值，但在模板中仍然需要使用 <code>message</code>（而不是 <code>message.value</code>）作为变量名。</p>
<p><strong>总结</strong></p>
<script setup> 和 ref/reactive 的自动解构是 Vue 3 中引入的两种语法糖，它们使得使用 Composition API 变得更加简洁和直观。这些特性允许我们更专注于组件的逻辑和功能，而不必花费太多精力在语法和结构上。




#### Vue3中的ref、toRef、toRefs

在 Vue 3 中，`ref`、`toRef` 和 `toRefs` 是与响应式引用（reactive references）紧密相关的 API，它们主要用于处理响应式数据。这些 API 允许你创建和管理响应式引用，以便在组件的模板和逻辑中使用。以下是这些 API 的简要说明：

**1. `ref`**

`ref` 函数用于创建一个响应式的引用（reference）。它接受一个初始值作为参数，并返回一个响应式的对象，该对象具有一个 `.value` 属性，用于访问或修改其值。

```javascript
import { ref } from 'vue';  
  
const count = ref(0);  
  
console.log(count.value); // 输出: 0  
  
count.value++;  
console.log(count.value); // 输出: 1
```

在模板中，你可以直接使用 `count`（不需要 `.value`），Vue 会自动为你处理。

**2. `toRef`**

`toRef` 函数用于为一个响应式对象的属性创建一个引用。与 `ref` 不同，`toRef` 创建的引用与原始对象保持连接，当原始对象的属性值发生变化时，引用也会更新。

```javascript
import { reactive, toRef } from 'vue';  
  
const state = reactive({  
  count: 0  
});  
  
const countRef = toRef(state, 'count');  
  
console.log(countRef.value); // 输出: 0  
  
state.count++;  
console.log(countRef.value); // 输出: 1
```

注意，如果你尝试通过 `countRef.value` 修改值，它只会影响 `state.count`，而不是创建一个新的响应式引用。

**3. `toRefs`**

`toRefs` 函数用于将一个响应式对象的所有属性转换为单独的响应式引用，并将它们收集到一个普通对象中。这在你需要将多个响应式属性传递给组件的 props 或在模板中大量使用它们时非常有用。

```javascript
import { reactive, toRefs } from 'vue';  
  
const state = reactive({  
  count: 0,  
  name: 'Vue'  
});  
  
const refs = toRefs(state);  
  
console.log(refs.count.value); // 输出: 0  
console.log(refs.name.value); // 输出: 'Vue'  
  
state.count++;  
console.log(refs.count.value); // 输出: 1
```

在模板中，你可以通过解构（destructuring）`toRefs` 的结果来直接使用这些引用，而无需每次都写 `.value`。

```vue
<template>  
  <div>  
    <p></p> <!-- 直接使用 count，而不是 count.value -->  
    <p></p> <!-- 直接使用 name，而不是 name.value -->  
  </div>  
</template>  
  
<script>  
import { reactive, toRefs } from 'vue';  
  
export default {  
  setup() {  
    const state = reactive({  
      count: 0,  
      name: 'Vue'  
    });  
  
    return {  
      ...toRefs(state)  
    };  
  }  
}  
</script>
<pre><code>


#### Vue3中的 reactive、 shallowReactive 函数

在 Vue 3 的 Composition API 中，`reactive` 和 `shallowReactive` 是两个用于创建响应式对象的函数。它们之间的主要区别在于它们如何处理嵌套对象的响应性。

**reactive**

`reactive` 函数用于创建一个响应式对象，该对象的所有嵌套属性（包括子对象）都是响应式的。当这些属性的值发生变化时，视图将自动更新。

```javascript
import &#123; reactive &#125; from &#39;vue&#39;;  
  
const state = reactive(&#123;  
  count: 0,  
  nested: &#123;  
    name: &#39;Vue&#39;,  
    version: 3  
  &#125;  
&#125;);  
  
// 改变顶级属性的值  
state.count++;  
  
// 改变嵌套对象的属性  
state.nested.name = &#39;Vue.js&#39;;  
  
// 这两个更改都会触发视图的更新
</code></pre>
<p>在上面的例子中，<code>state</code> 是一个响应式对象，它的 <code>count</code> 属性和 <code>nested</code> 对象（包括其 <code>name</code> 和 <code>version</code> 属性）都是响应式的。</p>
<p><strong>shallowReactive</strong></p>
<p><code>shallowReactive</code> 函数也用于创建一个响应式对象，但与 <code>reactive</code> 不同的是，它只使对象的顶层属性变为响应式。对象的嵌套属性（即子对象）不会变为响应式，除非它们本身也是响应式的。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> shallowReactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>  
  
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  
  nested<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
    name<span class="token punctuation">:</span> <span class="token string">'Vue'</span><span class="token punctuation">,</span>  
    version<span class="token punctuation">:</span> <span class="token number">3</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 改变顶级属性的值  </span>
state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 改变嵌套对象的属性（这里不会触发视图的更新，因为 nested 不是响应式的）  </span>
state<span class="token punctuation">.</span>nested<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Vue.js'</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 只有 count 的更改会触发视图的更新</span>
</code></pre>
<p>在上面的例子中，<code>state</code> 是一个响应式对象，但只有它的 <code>count</code> 属性是响应式的。<code>nested</code> 对象和其内部的 <code>name</code>、<code>version</code> 属性都不是响应式的。因此，只有对 <code>count</code> 的更改会触发视图的更新。</p>
<p><strong>何时使用 shallowReactive？</strong></p>
<p>在某些情况下，你可能不希望 Vue 追踪对象内部的所有嵌套属性变化，因为这可能会带来不必要的性能开销。例如，当你有一个大型对象，并且你只对它的顶层属性感兴趣时，<code>shallowReactive</code> 可能是一个更好的选择。但是，请注意，如果你试图修改嵌套对象的属性并期望视图更新，那么你需要确保这些嵌套对象也是响应式的，或者使用其他方法（如 Vuex）来管理你的状态。</p>
<h4 id="Vue3中setup语法下怎么设置name属性？"><a href="#Vue3中setup语法下怎么设置name属性？" class="headerlink" title="Vue3中setup语法下怎么设置name属性？"></a>Vue3中setup语法下怎么设置name属性？</h4><p>在 Vue 3 中，由于 <code>setup()</code> 函数是 Composition API 的一部分，并且它不直接绑定到组件实例上，因此你不能直接在 <code>setup()</code> 函数中设置组件的 <code>name</code> 属性，如同你在 Vue 2 的 <code>options</code> API 中所做的那样。</p>
<p>然而，<code>name</code> 属性主要用于开发工具中的调试和警告，它并不是组件功能所必需的。尽管如此，如果你确实需要在 Vue 3 中为组件设置一个 <code>name</code>，你仍然可以在组件的 <code>options</code> 部分（如果你同时使用 Composition API 和 Options API）或在 Vue 文件的 <code>&lt;script&gt;</code> 标签外（使用单文件组件）进行设置。</p>
<p><strong>使用 Options API 和 Composition API 混合</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>  
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>  
  
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  
  name<span class="token punctuation">:</span> <span class="token string">'MyComponentName'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 设置组件名  </span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment" spellcheck="true">// ... 其他逻辑  </span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>  
      count  
    <span class="token punctuation">}</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token comment" spellcheck="true">// ... 其他选项，如 methods、computed 等  </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p><strong>仅使用 Composition API</strong></p>
<p>如果你完全使用 Composition API，并且希望保持单文件组件的整洁，你可以在 <code>&lt;script&gt;</code> 标签的外部设置 <code>name</code> 属性：</p>
<pre class=" language-vue"><code class="language-vue"><template>  
  <!-- 组件模板 -->  
</template>  
  
<script>  
import { ref } from 'vue';  
  
export default {  
  setup() {  
    const count = ref(0);  
    // ... 其他逻辑  
    return {  
      count  
    };  
  },  
  // 注意：这里不设置 name，因为我们在外部设置  
};  
</script>  
  
<script setup>  
// 这个 script setup 是 Vue 3 的单文件组件语法糖  
// 由于它不支持直接设置 name，我们通常在外部设置  
</script>  
  
<style scoped>  
/* 组件样式 */  
</style>  
  
<!-- 在单文件组件的外部设置 name -->  
<script>  
export default {  
  name: 'MyComponentName'  
}  
</script>
</code></pre>
<p>但请注意，在 <code>&lt;script setup&gt;</code> 外部再包裹一个 <code>&lt;script&gt;</code> 来设置 <code>name</code> 并不是官方推荐的做法，因为这可能会引入一些混淆。在实际开发中，大多数开发者会选择在 <code>export default</code> 对象中直接设置 <code>name</code>，即使他们主要使用 Composition API。</p>
<p>如果你只使用 <code>&lt;script setup&gt;</code> 并且确实需要 <code>name</code>（尽管通常不需要），你可能需要依赖于外部工具或配置来设置它，或者接受默认的行为（即不设置 <code>name</code>）。</p>
<h4 id="Vue3中的自定义指令"><a href="#Vue3中的自定义指令" class="headerlink" title="Vue3中的自定义指令"></a>Vue3中的自定义指令</h4><p>在 Vue 3 中，自定义指令是一种强大而灵活的功能，允许你创建可复用的 DOM 行为。与 Vue 2 类似，Vue 3 提供了自定义指令的 API，但有一些细微的差别。</p>
<p>在 Vue 3 中，你可以通过 <code>app.directive()</code> 方法在 Vue 应用实例上注册全局自定义指令，或者在组件的 <code>directives</code> 选项上注册局部自定义指令。</p>
<p>自定义指令接收两个参数：指令名和指令定义对象。指令定义对象可以包含以下几个钩子函数（都是可选的）：</p>
<blockquote>
<ul>
<li><code>bind(el, binding, vnode, prevVnode)</code>: 当被绑定的元素挂载到 DOM 中时……调用。只调用一次。</li>
<li><code>inserted(el, binding, vnode, prevVnode)</code>: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li><code>update(el, binding, vnode, prevVnode)</code>: 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</li>
<li><code>componentUpdated(el, binding, vnode, prevVnode)</code>: 指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li><code>unmount(el, binding, vnode, prevVnode)</code>: 指令与元素解绑（只调用一次）。</li>
</ul>
</blockquote>
<p>下面是一个全局自定义指令的示例，它用于将元素的颜色设置为指令的值：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  
  
app<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-color'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  
  <span class="token comment" spellcheck="true">// 当被绑定的元素挂载到 DOM 中时……  </span>
  <span class="token function">bind</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// el 是指令所绑定的元素  </span>
    <span class="token comment" spellcheck="true">// binding 是一个对象，包含以下属性：  </span>
    <span class="token comment" spellcheck="true">//   - name: 指令名，不包括 v- 前缀。  </span>
    <span class="token comment" spellcheck="true">//   - value: 指令的绑定值，例如：v-my-color="123" 中，绑定值为 123。  </span>
    <span class="token comment" spellcheck="true">//   - oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。  </span>
    <span class="token comment" spellcheck="true">//   - expression: 字符串形式的指令表达式。例如 v-my-color="1 + 1" 中，表达式为 "1 + 1"。  </span>
    <span class="token comment" spellcheck="true">//   - arg: 传给指令的参数，可选。例如 v-my-color:red 中，参数为 "red"。  </span>
    <span class="token comment" spellcheck="true">//   - modifiers: 一个包含修饰符的对象。例如：v-my-color.foo.bar 中，修饰符对象为 { foo: true, bar: true }。  </span>
    <span class="token comment" spellcheck="true">// vnode 是 Vue 编译生成的虚拟节点  </span>
    el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> binding<span class="token punctuation">.</span>value  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token comment" spellcheck="true">// ... 其他钩子函数  </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
  
app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre>
<p>然后你可以在模板中这样使用自定义指令：</p>
<pre class=" language-html"><code class="language-html">html复制代码

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-my-color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>red<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello World!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
</code></pre>
<p>这将会把文本 “Hello World!” 的颜色设置为红色。注意，我们在 <code>v-my-color</code> 中使用了单引号，这是因为我们实际上是在传递一个字符串字面量给指令。如果 <code>binding.value</code> 是一个变量或表达式，你可以直接写 <code>v-my-color=&quot;myColorVariable&quot;</code>。</p>
<h4 id="pinia：Vue3中的状态管理库"><a href="#pinia：Vue3中的状态管理库" class="headerlink" title="pinia：Vue3中的状态管理库"></a>pinia：Vue3中的状态管理库</h4><p>Pinia是一个专为Vue 3设计的状态管理库，它基于Vue 3的Composition API，并以Vuex的下一代构想为基础，设计了新的Vue存储状态管理库。Pinia的主要特点和优势包括：</p>
<blockquote>
<ol>
<li><strong>简洁和轻量级</strong>：Pinia的设计理念和API都非常直观和简洁，使得开发者可以快速上手。它的大小只有约1KB，是一个轻量级的状态管理工具。</li>
<li><strong>基于响应式系统</strong>：Pinia的状态管理是基于Vue 3的响应式系统的，这意味着当状态发生改变时，相关的组件会自动更新。</li>
<li><strong>模块化设计</strong>：Pinia支持多个store，这使得你可以将应用程序的状态按照功能或模块进行划分，提高了代码的可维护性和可读性。</li>
<li><strong>支持同步和异步操作</strong>：Pinia中的action支持同步和异步操作，这使得你可以更方便地处理异步逻辑，比如从服务器获取数据等。</li>
<li><strong>支持服务端渲染（SSR）</strong>：Pinia可以很好地与Vue的服务端渲染功能配合使用，使得你可以在服务器端就预先渲染出应用程序的状态。</li>
<li><strong>支持Vue Devtools</strong>：Pinia与Vue Devtools完美集成，使得你可以更方便地调试和查看应用程序的状态。</li>
</ol>
</blockquote>
<p>在Pinia中，核心概念是Store，它类似于Vuex中的Store，但是更加轻便和灵活。在Store中，你可以使用Vue 3的响应式系统来定义状态，并通过actions来定义修改状态的方法。</p>
<p>总的来说，Pinia是一个强大而灵活的状态管理库，它可以帮助你更好地管理Vue 3应用程序的状态，提高代码的可维护性和可读性。如果你正在使用Vue 3开发应用程序，那么Pinia是一个值得考虑的状态管理库。</p>
<h4 id="Vue3中怎么封装自定义插件并使用？"><a href="#Vue3中怎么封装自定义插件并使用？" class="headerlink" title="Vue3中怎么封装自定义插件并使用？"></a>Vue3中怎么封装自定义插件并使用？</h4><p>在Vue 3中，你可以通过创建一个包含<code>install</code>方法的对象来封装自定义插件，并使用<code>app.use()</code>方法来安装和使用这个插件。以下是一个简单的步骤说明和示例：</p>
<p><strong>步骤</strong></p>
<ol>
<li><p>定义插件</p>
<p>：</p>
<ul>
<li>创建一个对象，该对象至少应该有一个<code>install</code>方法。</li>
<li><code>install</code>方法接收两个参数：<code>app</code>（Vue应用实例）和<code>options</code>（传递给插件的选项）。</li>
</ul>
</li>
<li><p>编写插件功能</p>
<p>：</p>
<ul>
<li>在<code>install</code>方法中，你可以添加全局方法或属性、添加全局资源、添加组件选项等等。</li>
</ul>
</li>
<li><p>使用插件</p>
<p>：</p>
<ul>
<li>在你的Vue应用中，使用<code>app.use(你的插件)</code>来安装插件。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong></p>
<p>假设我们要创建一个简单的全局提示插件：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// my-plugin.js  </span>
<span class="token keyword">const</span> MyPlugin <span class="token operator">=</span> <span class="token punctuation">{</span>  
  <span class="token comment" spellcheck="true">// install 方法是插件的核心  </span>
  <span class="token function">install</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// 确保插件只被安装一次  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>app<span class="token punctuation">.</span>_installedPlugins<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token keyword">return</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token comment" spellcheck="true">// 添加全局方法  </span>
    app<span class="token punctuation">.</span>config<span class="token punctuation">.</span>globalProperties<span class="token punctuation">.</span>$alert <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token function">alert</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">;</span>  
  
    <span class="token comment" spellcheck="true">// 添加全局指令（如果需要）  </span>
    app<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  
      <span class="token comment" spellcheck="true">// 指令定义  </span>
      <span class="token function">mounted</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment" spellcheck="true">// 指令挂载时的逻辑  </span>
        el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'这是一个自定义指令'</span><span class="token punctuation">;</span>  
      <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
    <span class="token comment" spellcheck="true">// 你可以在这里使用传入的options进行其他操作  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>someOption<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用了某个选项:'</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>someOption<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token comment" spellcheck="true">// 添加到已安装插件列表  </span>
    app<span class="token punctuation">.</span>_installedPlugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 在你的main.js或main.ts中使用插件  </span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>  
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token punctuation">;</span>  
<span class="token keyword">import</span> MyPlugin <span class="token keyword">from</span> <span class="token string">'./my-plugin'</span><span class="token punctuation">;</span>  
  
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span>  
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">,</span> <span class="token punctuation">{</span> someOption<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传入选项（如果需要）  </span>
app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>在上面的示例中，我们创建了一个名为<code>MyPlugin</code>的插件，它添加了一个全局方法<code>$alert</code>和一个全局指令<code>v-my-directive</code>。然后，在<code>main.js</code>或<code>main.ts</code>中，我们导入了这个插件并使用<code>app.use()</code>方法进行了安装。</p>
<p>注意：在Vue 3中，Vue实例不再暴露<code>Vue.prototype</code>，因此我们使用<code>app.config.globalProperties</code>来添加全局方法或属性。同时，<code>app._installedPlugins</code>是一个内部属性，用于追踪已安装的插件，以确保插件只被安装一次。虽然这不是必需的，但在某些情况下可能很有用。</p>
<h4 id="Vue3中createApp-App-创建应用实例过程中都发生了什么？"><a href="#Vue3中createApp-App-创建应用实例过程中都发生了什么？" class="headerlink" title="Vue3中createApp(App)创建应用实例过程中都发生了什么？"></a>Vue3中createApp(App)创建应用实例过程中都发生了什么？</h4><p>在Vue 3中，<code>createApp(App)</code>方法用于创建一个新的Vue应用实例。当你调用这个方法时，Vue内部会执行一系列的操作来设置和初始化这个应用实例。以下是<code>createApp(App)</code>创建应用实例过程中大致发生的一些步骤：</p>
<blockquote>
<ol>
<li><strong>参数处理</strong>：<code>createApp</code>方法接收一个根组件对象（在你的例子中是<code>App</code>）作为参数。这个对象通常是一个Vue组件，包含了模板、数据、方法等。</li>
<li><strong>创建应用实例</strong>：Vue内部会基于提供的根组件对象创建一个新的应用实例。这个实例包含了Vue应用所需的所有核心功能和状态。</li>
<li><strong>初始化响应式系统</strong>：Vue的响应式系统是其核心特性之一，允许数据和DOM之间保持同步。在创建应用实例时，Vue会初始化响应式系统，将根组件的数据转换为响应式数据。</li>
<li><strong>设置渲染上下文</strong>：Vue需要知道如何将组件渲染到DOM中。在创建应用实例时，Vue会设置渲染上下文，包括挂载点（即DOM元素）和渲染器（用于将虚拟DOM转换为真实DOM）。</li>
<li><strong>注册组件和指令</strong>：如果你在应用实例中注册了全局组件或指令，Vue会在此时将它们添加到全局注册表中。这样，你就可以在应用中的任何地方使用这些组件和指令了。</li>
<li><strong>启动挂载过程</strong>：最后，当你调用<code>app.mount(&#39;#app&#39;)</code>时（其中<code>#app</code>是挂载点的选择器），Vue会开始挂载过程。这个过程包括创建组件的虚拟DOM树、比较虚拟DOM和真实DOM的差异、以及将差异应用到真实DOM上。</li>
</ol>
</blockquote>
<p>需要注意的是，这个过程是一个简化的概述，Vue内部的实际实现可能会更加复杂和详细。此外，Vue 3还引入了许多新特性和优化，如Composition API、Teleport、Suspense等，这些特性在创建和挂载应用实例时也可能会有所体现。</p>
<p>如果你对Vue 3的源码感兴趣，可以查阅Vue的官方文档或源码来了解更多关于<code>createApp</code>方法和应用实例创建过程的细节。</p>
<h4 id="Vue3中有哪些新的组件？"><a href="#Vue3中有哪些新的组件？" class="headerlink" title="Vue3中有哪些新的组件？"></a>Vue3中有哪些新的组件？</h4><p>在Vue 3中，引入了一些新的内置组件，这些组件为开发者提供了更多的灵活性和功能。以下是Vue 3中的一些新组件：</p>
<ol>
<li><p>Teleport</p>
<p>：</p>
<ul>
<li>Teleport 是一种能够将组件的 HTML 结构“传送”到 DOM 树中指定位置的技术。这在处理如模态框、弹出窗口等需要脱离正常文档流的组件时非常有用。</li>
<li>你可以使用 <code>Teleport</code> 组件来指定子组件应该被渲染到哪个 DOM 节点中，而不是在其父组件的模板中。</li>
</ul>
</li>
<li><p>Suspense</p>
<p>：</p>
<ul>
<li>Suspense 组件用于处理异步组件的加载状态。当组件在等待异步组件加载时，你可以指定一个 fallback 组件来显示加载中的状态。</li>
<li>这对于在加载异步数据或组件时提供用户反馈非常有用，尤其是在需要保持 UI 流畅性的情况下。</li>
</ul>
</li>
<li><p>Fragment</p>
<p>：</p>
<ul>
<li>在 Vue 2 中，组件的根节点只能有一个。但在 Vue 3 中，你可以使用 <code>&lt;Fragment&gt;</code> 或简单地不使用根节点来渲染多个根节点。</li>
<li>这使得组件的模板更加灵活，特别是在需要将多个元素作为根元素渲染到 DOM 中的情况下。</li>
</ul>
</li>
<li><p>Transition 和 TransitionGroup</p>
<p>：</p>
<ul>
<li>这些组件在 Vue 2 中已经存在，但在 Vue 3 中得到了改进。它们用于在元素或组件进入、离开或列表更新时应用过渡效果。</li>
<li>通过使用这些组件，你可以更轻松地创建复杂的动画和过渡效果。</li>
</ul>
</li>
</ol>
<p>需要注意的是，虽然这些组件是 Vue 3 的新特性，但它们并不是必须使用的。你可以根据自己的项目需求来选择是否使用这些组件。同时，Vue 社区也提供了许多第三方组件库和插件，这些库和插件也可以为你的项目提供额外的功能和灵活性。</p>
<h4 id="Vue3中Composition-API-和-React-Hook的区别"><a href="#Vue3中Composition-API-和-React-Hook的区别" class="headerlink" title="Vue3中Composition API 和 React Hook的区别"></a>Vue3中Composition API 和 React Hook的区别</h4><p>Vue3中的Composition API和React Hook在多个方面存在区别，这些区别主要体现在语法、概念、数据响应性等方面。</p>
<ol>
<li>语法和概念：</li>
</ol>
<ul>
<li>Vue 3的Composition API使用函数方式组织逻辑，引入了如<code>ref</code>、<code>reactive</code>、<code>computed</code>等新概念。这些函数和概念允许开发者将逻辑和状态管理逻辑分离，使代码更加清晰和可维护。</li>
<li>React Hooks则使用函数调用，主要包括<code>useState</code>、<code>useEffect</code>、<code>useContext</code>等。Hooks允许你在不编写class的情况下使用state以及其他的React特性，从而在不改变组件结构的情况下复用状态逻辑。</li>
</ul>
<ol>
<li>数据响应性：</li>
</ol>
<ul>
<li>Vue 3使用了响应性系统来管理数据的变化。通过使用<code>reactive</code>函数，你可以创建响应式对象，其属性会随着对象属性的改变而自动更新。这在状态管理和数据传递上非常有用。</li>
<li>React则没有内置的响应性系统。在React中，你需要使用<code>useState</code>来管理组件状态，并使用<code>useEffect</code>来处理副作用。然而，这些工具并不提供像Vue那样的自动数据响应性。</li>
</ul>
<ol>
<li>组件逻辑组织：</li>
</ol>
<ul>
<li>使用Composition API，你可以将组件的逻辑按照功能进行组织，而不是按照选项进行组织。这提高了代码的可读性和可维护性。</li>
<li>在React中，Hooks允许你在函数组件中“钩入”React state及生命周期等特性。这意味着你可以在无需编写class组件的情况下使用React的许多高级功能。</li>
</ul>
<p>总的来说，Vue3的Composition API和React Hook都是各自框架中用于提高代码复用性和组织性的重要工具。然而，它们在语法、概念和数据响应性等方面存在差异，这些差异可能会影响开发者在不同框架下的编码习惯和策略。在选择使用哪种技术时，需要根据具体项目的需求和个人偏好来做出决策。</p>
<h3 id="Vue相关"><a href="#Vue相关" class="headerlink" title="Vue相关"></a>Vue相关</h3><h4 id="vue-内置指令"><a href="#vue-内置指令" class="headerlink" title="vue 内置指令"></a>vue 内置指令</h4><p><img src="/../images/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/vue-command.jpg" alt="vue内置指令"></p>
<h4 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h4><p><code>v-if</code> 和 <code>v-show</code> 都是 Vue 中的条件渲染指令，用于根据条件来控制元素的显示和隐藏。它们之间的区别如下：</p>
<blockquote>
<ol>
<li>编译时机：<code>v-if</code> 是在编译阶段进行条件判断，如果条件为假，那么该元素及其子元素将不会被编译和渲染到 DOM 中。而 <code>v-show</code> 是在编译阶段将元素渲染到 DOM 中，然后通过 CSS 的 <code>display</code> 属性控制元素的显示和隐藏。</li>
<li>切换消耗：由于 <code>v-if</code> 是在编译阶段进行条件判断，当条件发生变化时，会触发元素的创建或销毁，因此切换时的消耗较大。而 <code>v-show</code> 只是通过修改 CSS 的 <code>display</code> 属性来切换元素的可见性，所以切换时的消耗较小。</li>
<li>初始渲染开销：由于 <code>v-if</code> 是在编译阶段进行条件判断，当条件为假时，元素及其子元素不会被编译和渲染，所以初始渲染的开销较小。而 <code>v-show</code> 在初始渲染时，会将元素及其子元素都渲染到 DOM 中，然后通过 CSS 控制其可见性，所以初始渲染的开销较大。</li>
<li>条件切换频率：如果需要频繁切换元素的显示和隐藏，建议使用 <code>v-show</code>，因为它只是通过修改 CSS 属性来切换，性能更好。如果切换频率较低，可以使用 <code>v-if</code>，因为它在条件为假时会销毁元素，可以减少页面中的 DOM 元素数量。</li>
</ol>
</blockquote>
<p>​    <code>v-if</code> 适用于条件切换频率较低的情况，可以节省初始渲染开销和内存占用；<code>v-show</code> 适用于频繁切换元素的可见性，可以减少切换消耗。根据具体的需求和场景选择合适的条件渲染指令。</p>
<h4 id="v-if-和-v-for-哪个优先级更高"><a href="#v-if-和-v-for-哪个优先级更高" class="headerlink" title="v-if 和 v-for 哪个优先级更高"></a>v-if 和 v-for 哪个优先级更高</h4><p>​    在 Vue 中，<code>v-for</code> 指令的优先级高于 <code>v-if</code> 指令。这意味着当一个元素同时使用了 <code>v-if</code> 和 <code>v-for</code>，<code>v-for</code> 将首先被解析和执行，然后在每个迭代的元素上进行 <code>v-if</code> 的条件判断。</p>
<p>​    具体来说，当使用 <code>v-if</code> 和 <code>v-for</code> 同时存在于同一个元素上时，Vue 的编译器会先处理 <code>v-for</code>，根据数据集合生成对应的元素列表。然后，在每个生成的元素上，会再依次应用 <code>v-if</code> 的条件判断。这意味着，如果 <code>v-if</code> 的条件为假，对应的元素将不会被渲染到最终的 DOM 中。</p>
<p>​    <code>v-for</code> 会先根据 <code>items</code> 数据集合生成对应的元素列表，然后在每个元素上应用 <code>v-if</code> 的条件判断。只有当 <code>item.visible</code> 的值为真时，对应的元素才会被渲染到最终的 DOM 中。</p>
<p>​    需要注意的是，在某些特定情况下，使用 <code>v-if</code> 和 <code>v-for</code> 同时存在可能会导致性能问题，因为每次迭代都需要进行条件判断。在这种情况下，可以考虑使用计算属性或过滤器来预先筛选数据集合，以减少渲染的元素数量，从而提升性能。</p>
<h4 id="slot（插槽）的作用"><a href="#slot（插槽）的作用" class="headerlink" title="slot（插槽）的作用"></a>slot（插槽）的作用</h4><p>​    插槽（Slot）是 Vue 中一种用于扩展组件内容的机制。通过插槽，你可以在组件的模板中预留出一些位置，然后在使用该组件时，将内容插入到这些位置上。</p>
<p>插槽的作用主要有以下几个方面：</p>
<blockquote>
<ol>
<li>内容分发：插槽允许组件的使用者向组件中传递内容，并在组件内部进行渲染。使用插槽可以将组件设计得更加灵活，使得组件可以接受不同的内容进行渲染，从而满足不同的需求。</li>
<li>组件组合：通过插槽，你可以将多个组件组合在一起，形成更复杂的组合组件。插槽使得组件之间的组合变得简单，你可以将多个组件的内容组合在一起，并且可以在父组件中决定如何组合它们。</li>
<li>默认内容：插槽可以设置默认内容，当使用组件时没有提供具体内容时，将会使用默认的插槽内容进行渲染。这样可以确保即使没有传入内容，组件仍然可以正常显示一些默认的内容。</li>
</ol>
</blockquote>
<p>​    在 Vue 中，有两种类型的插槽：具名插槽和默认插槽。具名插槽允许你为插槽指定名称，并在组件中根据名称进行内容分发。默认插槽是没有名称的，当组件中没有具名插槽时，会将内容分发到默认插槽中。</p>
<p>​    通过使用插槽，你可以将组件的结构和样式与具体的内容进行解耦，提高了组件的可复用性和灵活性。它是 Vue 中非常强大和常用的特性之一。</p>
<h4 id="关于-Vue-的单向数据流"><a href="#关于-Vue-的单向数据流" class="headerlink" title="关于 Vue 的单向数据流"></a>关于 Vue 的单向数据流</h4><p>​    数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<blockquote>
<p>注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</p>
</blockquote>
<p>​    如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改。</p>
<h4 id="computed-和-watch-的区别和运用的场景"><a href="#computed-和-watch-的区别和运用的场景" class="headerlink" title="computed 和 watch 的区别和运用的场景"></a>computed 和 watch 的区别和运用的场景</h4><p>​    computed 是<a target="_blank" rel="noopener" href="https://juejin.cn/post/6956407362085191717">计算属性</a>，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。</p>
<p>​    <a target="_blank" rel="noopener" href="https://juejin.cn/post/6954925963226382367">watch</a>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p>
<p>​    计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑计算属性原理详解 </p>
<h4 id="vue-中使用了哪些设计模式"><a href="#vue-中使用了哪些设计模式" class="headerlink" title="vue 中使用了哪些设计模式"></a>vue 中使用了哪些设计模式</h4><blockquote>
<p>1.工厂模式 - 传入参数即可创建实例</p>
<p>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p>
<p>2.单例模式 - 整个程序有且仅有一个实例</p>
<p>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉</p>
<p>3.发布-订阅模式 (vue 事件机制)</p>
<p>4.观察者模式 (响应式数据原理)</p>
<p>5.装饰模式: (@装饰器的用法)</p>
<p>6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="Vue-模板编译原理"><a href="#Vue-模板编译原理" class="headerlink" title="Vue 模板编译原理"></a>Vue 模板编译原理</h4><p>Vue 的模板编译原理主要包括以下步骤：</p>
<blockquote>
<ol>
<li>解析：Vue 的模板编译器将模板字符串解析为抽象语法树（AST）。AST 是一个树状结构，表示了模板中的各个节点和它们之间的关系。</li>
<li>优化：在解析完成后，编译器会对生成的 AST 进行优化。这个优化过程包括静态节点标记、静态根节点提升和事件侦听器的缓存等。这些优化可以提高渲染性能和减少运行时的开销。</li>
<li>代码生成：在优化完成后，编译器会根据 AST 生成渲染函数。渲染函数是一个 JavaScript 函数，它接收数据作为参数，返回一个虚拟 DOM 树。渲染函数可以将模板中的数据和逻辑转换为实际的 DOM 操作。</li>
<li>组件化编译：如果模板中包含组件，编译器会递归地对组件进行编译。这样可以将组件的模板编译为渲染函数，并生成组件的渲染逻辑。</li>
</ol>
</blockquote>
<p>​    在运行时，Vue 实例会通过编译后的渲染函数生成虚拟 DOM，并将其与实际的 DOM 进行比对，只更新需要改变的部分，以提高性能。</p>
<p>​    Vue 的模板编译原理将模板字符串解析为 AST，经过优化后生成渲染函数，然后在运行时使用渲染函数生成虚拟 DOM，并进行差异比对来更新视图。这种编译的过程使得 Vue 具有高效的渲染性能和灵活的组件化开发能力。</p>
<h4 id="Vue-的性能优化"><a href="#Vue-的性能优化" class="headerlink" title="Vue 的性能优化"></a>Vue 的性能优化</h4><p>Vue 的性能优化可以从以下几个方面考虑：</p>
<blockquote>
<ol>
<li>减少不必要的重新渲染：Vue 使用响应式系统来跟踪数据的变化并更新视图。为了减少不必要的重新渲染，可以使用合理的计算属性和侦听器，避免不必要的计算和更新。另外，使用 v-if 和 v-show 来条件渲染元素，只渲染当前需要显示的部分。</li>
<li>列表渲染优化：在使用 v-for 渲染列表时，使用唯一的 key 属性来提高性能。Vue 使用 key 来跟踪每个节点的身份，以便在更新过程中进行重用和重新排序，而不是完全重新创建和销毁 DOM 节点。</li>
<li>懒加载和异步组件：对于大型的页面或组件，可以使用懒加载和异步组件来延迟加载和渲染。这可以加快初始加载时间并减少首屏渲染的工作量。</li>
<li>使用 v-if 和 v-for 的选择：在需要根据条件动态渲染的元素上使用 v-if，而不是在列表上使用 v-for。因为 v-if 在条件不满足时会完全销毁和重建元素，而 v-for 只是在数据发生变化时更新元素。</li>
<li>使用虚拟列表或无限滚动：当需要处理大量数据列表时，可以使用虚拟列表或无限滚动的技术来提高性能。这样可以减少一次性渲染的节点数量，只渲染可见部分，从而减少内存占用和渲染时间。</li>
<li>合理使用异步更新：Vue 提供了 nextTick 方法和 $nextTick 实例方法来在下次 DOM 更新周期之后执行回调。合理使用异步更新可以将多个更新合并成一次，减少不必要的计算和渲染。</li>
<li>基于路由的代码分割：通过合理的路由配置和动态导入，将页面的代码拆分成更小的块，按需加载和渲染，提高初始加载速度和页面切换的响应性。</li>
<li>合理使用缓存：对于一些计算开销较大的结果或静态数据，可以使用缓存来避免重复计算或请求。例如，使用计算属性的缓存选项或使用工具库进行数据缓存。</li>
</ol>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jayhodon</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章連結:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://Jayhodon.github.io/2023/06/12/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">https://Jayhodon.github.io/2023/06/12/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版權聲明:
                    </i>
                </span>
                <span class="reprint-info">
                    本部落格所有文章除特別聲明外，均採用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    許可協議。轉載請註明來源
                    <a href="/about" target="_blank">Jayhodon</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>複製成功，請遵循本文的轉載規則</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                    <span class="chip bg-color">前端</span>
                                </a>
                            
                                <a href="/tags/Vue/">
                                    <span class="chip bg-color">Vue</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Javascript/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="设计模式 - Javascript">
                        
                        <span class="card-title">设计模式 - Javascript</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            该博文是js的内功进阶修炼 - JavaScript设计模式
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-07-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/Javascript/" class="post-category">
                                    Javascript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                    <a href="/tags/Javascript/">
                        <span class="chip bg-color">Javascript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/05/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="浏览器相关">
                        
                        <span class="card-title">浏览器相关</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            一篇了解、剖析浏览器相关原理知识点的手作指北。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-05-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/" class="post-category">
                                    个人知识库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目錄</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1 , h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1 , h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2024</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">Jayhodon</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;總訪問量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;總訪問人數:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/jayhodon" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:tang9568@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2324729568" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2324729568" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="請輸入搜索的關鍵字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
