<!DOCTYPE HTML>
<html lang="zh-HK">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Vue.js设计与实现, Jayhodon&#39;s Blog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Vue.js设计与实现 | Jayhodon&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.2"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <!-- <img src="/medias/logo.png" class="logo-img" alt="LOGO"> -->
                    
                    <span class="logo-span">Jayhodon&#39;s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Jayhodon&#39;s Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Jayhodon" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #695075 ;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Jayhodon" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Vue.js设计与实现</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #8f3a81 ;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #8f3a81 ;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                <span class="chip bg-color">前端</span>
                            </a>
                        
                            <a href="/tags/Vue/">
                                <span class="chip bg-color">Vue</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                前端
                            </a>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF/Vue/" class="post-category">
                                Vue
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>發布日期:&nbsp;&nbsp;
                    2023-06-12
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="Vue的设计模式"><a href="#Vue的设计模式" class="headerlink" title="Vue的设计模式"></a>Vue的设计模式</h3><h4 id="MVC-和-MVVM-区别"><a href="#MVC-和-MVVM-区别" class="headerlink" title="MVC 和 MVVM 区别"></a>MVC 和 MVVM 区别</h4><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范</p>
<ul>
<li>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li>
<li>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</li>
<li>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据</li>
</ul>
<p>MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。</p>
<h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><p>MVVM 新增了 VM 类</p>
<blockquote>
<p>ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。</p>
</blockquote>
<p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</p>
<p>整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性</p>
<blockquote>
<p>注意：Vue 并没有完全遵循 MVVM 的思想 这一点官网自己也有说明。严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</p>
</blockquote>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/../images/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/vue-life.jpg" alt="Vue生命周期"></p>
<blockquote>
<p><strong>beforeCreate</strong> 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问</p>
<p><strong>created</strong> 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom</p>
<p><strong>beforeMount</strong> 在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p><strong>mounted</strong> 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点</p>
<p><strong>beforeUpdate</strong> 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p>
<p><strong>updated</strong> 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。</p>
<p><strong>beforeDestroy</strong> 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。</p>
<p><strong>destroyed</strong> Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p>
<p><strong>activated</strong> keep-alive 专属，组件被激活时调用</p>
<p><strong>deactivated</strong> keep-alive 专属，组件被销毁时调用</p>
</blockquote>
<h4 id="Vue中的-keep-alive-组件"><a href="#Vue中的-keep-alive-组件" class="headerlink" title="Vue中的 keep-alive 组件"></a>Vue中的 keep-alive 组件</h4><p><strong>Vue中的keep-alive是一个内置组件</strong>，它的主要作用是缓存其他组件的实例，以避免重复渲染和销毁，从而提供性能优化。具体来说，当使用keep-alive包裹动态组件时，它会缓存不活动的组件实例，而不是销毁它们。这样，在组件切换时，这些组件的实例就会被缓存起来，而不是每次都重新创建。</p>
<p>keep-alive组件可以设置以下props属性：</p>
<ul>
<li><code>include</code>：字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li><code>exclude</code>：字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li><code>max</code>：数字。最多可以缓存多少组件实例。</li>
</ul>
<p>此外，当组件被包含在keep-alive中时，会多出两个生命周期的钩子：<code>activated</code>和<code>deactivated</code>。<code>activated</code>在keep-alive组件激活时调用，而<code>deactivated</code>在keep-alive组件停用时调用。这两个钩子在服务器端渲染期间不被调用。</p>
<p>使用keep-alive可以将数据保留在内存中，但如果你需要在每次进入页面时获取最新的数据，你需要在<code>activated</code>阶段获取数据，承担原来<code>created</code>钩子函数中获取数据的任务。</p>
<p>总的来说，keep-alive是一个用于优化Vue应用性能的组件，它可以在组件切换时缓存组件实例，避免重复渲染和销毁。</p>
<h4 id="keep-alive-中的生命周期有哪些"><a href="#keep-alive-中的生命周期有哪些" class="headerlink" title="keep-alive 中的生命周期有哪些"></a>keep-alive 中的生命周期有哪些</h4><blockquote>
<p>​    keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存，在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。 如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。</p>
<p>​    同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。 当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期； 当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。</p>
</blockquote>
<h4 id="异步请求在哪一步发起？"><a href="#异步请求在哪一步发起？" class="headerlink" title="异步请求在哪一步发起？"></a>异步请求在哪一步发起？</h4><blockquote>
<p>可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p>
<p>如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面  loading 时间；</li>
<li>ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
</blockquote>
<h4 id="Vue-的父子组件生命周期钩子函数执行顺序"><a href="#Vue-的父子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父子组件生命周期钩子函数执行顺序"></a>Vue 的父子组件生命周期钩子函数执行顺序</h4><blockquote>
<p><strong>加载渲染过程:</strong></p>
<p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p>
<p><strong>子组件更新过程:</strong></p>
<p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p>
<p><strong>父组件更新过程:</strong></p>
<p>父 beforeUpdate-&gt;父 updated</p>
<p><strong>销毁过程:</strong></p>
<p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p>
</blockquote>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><h4 id="组件中为什么-data-是一个函数？"><a href="#组件中为什么-data-是一个函数？" class="headerlink" title="组件中为什么 data 是一个函数？"></a>组件中为什么 <code>data</code> 是一个函数？</h4><blockquote>
<p>在 Vue 组件中，为什么 <code>data</code> 是一个函数而不是一个对象的原因是为了确保每个组件实例都有其自己的数据副本。当组件被定义时，<code>data</code> 必须是一个函数。每次创建组件实例时，Vue 都会调用该函数来返回一个全新的数据对象。</p>
<p>这是因为 Vue 组件可以在应用中存在多个实例，每个实例都应该具有独立的状态和数据。如果 <code>data</code> 是一个对象，那么所有组件实例将共享相同的数据对象，这将导致一个实例的数据变化会影响到其他实例。</p>
<p>通过将 <code>data</code> 定义为函数，Vue 在创建组件实例时会为每个实例调用该函数，从而返回一个新的数据对象。这样，每个组件实例都有自己的数据副本，它们之间相互独立，可以独立地修改和维护各自的状态。</p>
</blockquote>
<h4 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h4><p>v-model 其实就是语法糖，v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<blockquote>
<p>text 和 textarea 元素使用 value property 和 input 事件；</p>
<p>checkbox 和 radio 使用 checked property 和 change 事件；</p>
<p>select 字段将 value 作为 prop 并将 change 作为事件。</p>
</blockquote>
<p>在普通标签上:</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  //这一行等于下一行
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sth <span class="token punctuation">=</span> $event.target.value<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
</code></pre>
<p>在组件上:</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>currency-input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>price<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>currentcy-input</span><span class="token punctuation">></span></span>
<span class="token comment" spellcheck="true">&lt;!--上行代码是下行的语法糖
 &lt;currency-input :value="price" @input="price = arguments[0]">&lt;/currency-input>
--></span>

<span class="token comment" spellcheck="true">&lt;!-- 子组件定义 --></span>
Vue.component('currency-input', {
 template: `
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
    <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>input<span class="token punctuation">"</span></span>
    <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span>
    <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$emit(<span class="token punctuation">'</span>input<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">"</span></span>
   <span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
 `,
 props: ['value'],
})
</code></pre>
<h4 id="Vue数据双向绑定原理"><a href="#Vue数据双向绑定原理" class="headerlink" title="Vue数据双向绑定原理"></a>Vue数据双向绑定原理</h4><h5 id="vue的响应式基本原理："><a href="#vue的响应式基本原理：" class="headerlink" title="vue的响应式基本原理："></a>vue的响应式基本原理：</h5><blockquote>
<p>1、vue会遍历此data中对象所有的属性，</p>
<p>2、并使用Object.defineProperty进行数据劫持，把这些属性全部转为getter/setter，</p>
<p>3、而每个组件实例都有watcher对象，</p>
<p>4、它会在组件渲染的过程中把属性记录为依赖，</p>
<p>5、之后当依赖项的 setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p>
</blockquote>
<p>eg：</p>
<p>Object.defineProperty( ):</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">"My name is "</span> <span class="token operator">+</span> name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
 
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jayhodon'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// My name is Jayhodon</span>
</code></pre>
<h5 id="vue的响应式原理设计三个重要对象："><a href="#vue的响应式原理设计三个重要对象：" class="headerlink" title="vue的响应式原理设计三个重要对象："></a>vue的响应式原理设计三个重要对象：</h5><blockquote>
<p>Observer对象：vue中的数据对象在初始化过程中转换为Observer对象。</p>
<p>Watcher对象：将模板和Observer对象结合在一起生成Watcher实例，Watcher是订阅者中的订阅者。</p>
<p>Dep对象：Watcher对象和Observer对象之间纽带，每一个Observer都有一个Dep实例，用来存储订阅者Watcher。</p>
</blockquote>
<p>当属性变化会执行主题对象Observer的dep.notify方法， 这个方法会遍历订阅者Watcher列表向其发送消息， Watcher会执行run方法去更新视图。模板编译过程中的指令和数据绑定都会生成Watcher实例，实例中的watch属性也会生成Watcher实例。</p>
<p>总的来说就是：</p>
<blockquote>
<p>1、在生命周期的initState方法中将data，prop，method，computed，watch中的数据劫持， 通过observe方法与Object.defineProperty方法将相关对象转为换Observer对象。</p>
<p>2、然后在initRender方法中解析模板，通过Watcher对象，Dep对象与观察者模式将模板中的 指令与对象的数据建立依赖关系，使用全局对象Dep.target实现依赖收集。</p>
<p>3、当数据变化时，setter被调用，触发Object.defineProperty方法中的dep.notify方法， 遍历该数据依赖列表，执行器update方法通知Watcher进行视图更新。</p>
</blockquote>
<h5 id="使用Object-defineProperty实现监听变量"><a href="#使用Object-defineProperty实现监听变量" class="headerlink" title="使用Object.defineProperty实现监听变量:"></a>使用Object.defineProperty实现监听变量:</h5><p>实现步骤：</p>
<p>Observer：</p>
<p> 用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Observer</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Observer<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    walk<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            self<span class="token punctuation">.</span><span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    defineReactive<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> childObj <span class="token operator">=</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 递归遍历所有子属性</span>
        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
            enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> getter <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    dep<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断是否需要添加订阅者，并添加订阅者</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> val<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> setter <span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
                dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果数据发生了变化，则通知所有的订阅者</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>value <span class="token operator">||</span> <span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数</span>
<span class="token keyword">function</span> Dep <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Dep<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    addSub<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    notify<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
<p>Watcher：</p>
<p> 可以收到属性的变化通知并执行相应的函数，从而更新视图。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> exp<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>exp <span class="token operator">=</span> exp<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将自己添加到订阅器的操作</span>
<span class="token punctuation">}</span>

Watcher<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    update<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    run<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>exp<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> oldVal <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!==</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>cb<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 缓存自己</span>
        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>exp<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">// 强制执行监听器里的get函数</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 释放自己</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>这时只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> SelfVue <span class="token punctuation">(</span>data<span class="token punctuation">,</span> el<span class="token punctuation">,</span> exp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">[</span>exp<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化模板数据的值</span>
    <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> exp<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>完整版参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/libin-1/p/6893712.html">vue的双向绑定原理及实现</a>    <a target="_blank" rel="noopener" href="https://github.com/canfoo/self-vue/tree/master/v3">源 码</a></p>
<h5 id="使用ES6的proxy简单实现监听变量"><a href="#使用ES6的proxy简单实现监听变量" class="headerlink" title="使用ES6的proxy简单实现监听变量:"></a>使用ES6的proxy简单实现监听变量:</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
 msg<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">10</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//懒监听，去获取的时候才监听对象里面的对象，而不是直接递归循环监听</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//数组新增会执行两次，一次是修改length，一次是添加值</span>
  <span class="token keyword">let</span> oldValue <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>oldValue<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">//找不到老值，新增</span>
  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>oldValue <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">//老值和新值不相等，修改</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
proxy<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">;</span>
</code></pre>
<p>区别：</p>
<blockquote>
<p>1、语法层面上</p>
<p>defineProperty只能响应首次渲染时候的属性，</p>
<p>defineProperty无法一次性监听所有属性，必须通过遍历或者递归的方式来实现且无法监听新增的属性，对于数组defineProperty则需要劫持数组方法。</p>
<p>Proxy需要的是整体监听，不需要关心里面有什么属性，而且Proxy的配置项有13种，可以做更细致的事情，这是之前的defineProperty无法达到的。</p>
<p>2、兼容层面上</p>
<p>vue2.x之所以只能兼容到IE8就是因为defineProperty无法兼容IE8,其他浏览器也会存在轻微兼容问题。</p>
<p>proxy的话除了IE，其他浏览器都兼容，这次vue3还是使用了它，说明vue3直接放弃了IE的兼容考虑。</p>
</blockquote>
<p> 为什么Vue 3 使用 Proxy 替代了 Vue 2 中的 Object.defineProperty：</p>
<blockquote>
<ol>
<li>更好的性能：Vue 3 使用 Proxy 可以提供比 Object.defineProperty 更高的性能。Proxy 可以拦截更多的操作，包括属性访问、属性设置、删除属性等，而 Object.defineProperty 只能拦截属性的读取和设置。</li>
<li>更好的扩展性：Proxy 提供了更多的拦截方法，可以针对更多的操作进行定制。这使得 Vue 3 在响应式系统的实现上更加灵活和可扩展。</li>
<li>更好的支持嵌套对象：Proxy 对于嵌套对象的响应式支持更加完善。Vue 3 的响应式系统可以追踪到嵌套对象的变化，并在需要时触发更新。</li>
<li>更好的 TypeScript 支持：Proxy 的类型推断更准确，可以提供更好的 TypeScript 支持，让开发者在编码过程中能够获得更准确的类型提示和错误检查。</li>
</ol>
</blockquote>
<p>​    总体来说，Vue 3 使用 Proxy 替代了 Vue 2 中的 Object.defineProperty，主要是为了提供更好的性能、更好的扩展性、更好的嵌套对象支持和更好的 TypeScript 支持。这些改进使得 Vue 3 在响应式系统的实现上更加先进和灵活，提供了更好的开发体验和性能优化。</p>
<h4 id="defineProperty和proxy的区别"><a href="#defineProperty和proxy的区别" class="headerlink" title="defineProperty和proxy的区别"></a>defineProperty和proxy的区别</h4><p><code>Object.defineProperty</code> 和 <code>Proxy</code> 在 JavaScript 中都是用于对对象或属性的操作，但它们在许多方面存在差异。以下是它们之间的主要区别：</p>
<ol>
<li>ES 版本<ul>
<li><code>Object.defineProperty</code> 是 ES5 引入的方法。</li>
<li><code>Proxy</code> 是 ES6 引入的新特性，提供了更强大的对象操作能力。</li>
</ul>
</li>
<li>操作对象的方式<ul>
<li><code>Object.defineProperty</code> 用于直接在一个对象上定义新的属性，或者修改一个对象的现有属性，并返回这个对象。它可以用来对单个属性进行控制，如设置属性的可写性、可枚举性、可配置性等。</li>
<li><code>Proxy</code> 则是一个构造函数，可以创建一个代理对象，对目标对象（target）进行拦截和修改。Proxy 可以对整个对象进行拦截，而不仅仅是单个属性。它允许你拦截诸如读取、赋值、函数调用等多种操作，并提供相应的处理逻辑。</li>
</ul>
</li>
<li>监听能力<ul>
<li><code>Object.defineProperty</code> 在监听对象属性时，有一定的局限性。例如，它不能监听到数组下标的变化或对象新增的属性。</li>
<li><code>Proxy</code> 则可以监听到更多类型的操作，包括数组的下标变化、对象新增属性等。</li>
</ul>
</li>
<li>性能与递归<ul>
<li>由于 <code>Object.defineProperty</code> 需要在开始时对所有属性进行递归监听，因此在处理大型对象时可能会产生较大的性能开销。</li>
<li><code>Proxy</code> 在这方面更具优势。它的监听是动态的，即只有在真正访问到某个属性时才会触发监听。这使得 <code>Proxy</code> 在处理大型对象时更加高效。</li>
</ul>
</li>
<li>对源对象的影响<ul>
<li>使用 <code>Object.defineProperty</code> 修改对象时，实际上是直接修改了源对象。这可能会导致源对象被污染。</li>
<li><code>Proxy</code> 则创建了一个代理对象，对源对象进行代理，所有的修改都是在代理对象上进行的，不会直接修改源对象。</li>
</ul>
</li>
<li>浏览器兼容性<ul>
<li><code>Object.defineProperty</code> 在大多数现代浏览器中都有良好的支持，但可能不兼容一些较旧的浏览器，如 IE8。</li>
<li><code>Proxy</code> 的兼容性相对较差，特别是在一些较旧的浏览器中，如 IE11。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>Object.defineProperty</code> 和 <code>Proxy</code> 在功能、性能、监听能力、对源对象的影响以及浏览器兼容性等方面都存在差异。在选择使用哪种方法时，需要根据具体的应用场景和需求进行权衡。</p>
<h4 id="Vue2通过数组下标更改数组视图为什么不会更新？而Vue3却可以？"><a href="#Vue2通过数组下标更改数组视图为什么不会更新？而Vue3却可以？" class="headerlink" title="Vue2通过数组下标更改数组视图为什么不会更新？而Vue3却可以？"></a>Vue2通过数组下标更改数组视图为什么不会更新？而Vue3却可以？</h4><p>Vue2通过数组下标直接更改数组内容后视图不会更新的原因是Vue2的响应式系统是基于<code>Object.defineProperty</code>实现的。<code>Object.defineProperty</code>只能检测到对象属性的读取和设置，但无法检测到数组索引（即下标）的变化或数组长度的改变。因此，当Vue2通过数组下标直接修改数组内容时，Vue的响应式系统无法捕获到这种变化，从而导致视图不会更新。</p>
<p>然而，Vue3的响应式系统是基于ES6的<code>Proxy</code>实现的，它能够拦截到对目标对象的任何操作，包括数组索引的变化和数组长度的改变。因此，当Vue3通过数组下标修改数组内容时，<code>Proxy</code>会拦截到这种变化，并通知Vue的响应式系统更新视图。</p>
<p>另外，Vue2也提供了一些方法（如<code>Vue.set</code>或<code>this.$set</code>）来手动触发视图的更新。这些方法允许你向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。但是，在Vue3中，由于<code>Proxy</code>的强大能力，这种手动触发视图更新的需求大大减少。</p>
<p>总的来说，Vue2和Vue3在响应式系统的实现上存在差异，导致它们在处理数组下标更改时的行为不同。Vue3的<code>Proxy</code>实现使得其能够更准确地捕获到对象的变化，并触发视图的更新。</p>
<h4 id="Vue2中如何监听-检测-对象或者数组某个属性的变化？"><a href="#Vue2中如何监听-检测-对象或者数组某个属性的变化？" class="headerlink" title="Vue2中如何监听(检测)对象或者数组某个属性的变化？"></a>Vue2中如何监听(检测)对象或者数组某个属性的变化？</h4><p>在Vue 2中，监听对象或数组某个属性的变化通常需要使用Vue的实例方法<code>watch</code>来观察特定的数据变化，或者使用<code>Object.defineProperty</code>（Vue内部已经为你处理了这一点，但如果你需要手动监听，你可以使用它）。不过，由于Vue 2的响应式系统是基于<code>Object.defineProperty</code>的，对于数组，Vue 2只能检测到数组长度的改变或某些特定方法的调用（如<code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>splice</code>, <code>sort</code>, <code>reverse</code>），而不能直接检测到数组索引（即下标）的变化。</p>
<h3 id="监听对象属性的变化"><a href="#监听对象属性的变化" class="headerlink" title="监听对象属性的变化"></a>监听对象属性的变化</h3><p>你可以使用Vue实例的<code>watch</code>选项或<code>this.$watch</code>方法来监听对象属性的变化。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
    obj<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
      a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  
      b<span class="token punctuation">:</span> <span class="token number">2</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
    <span class="token string">'obj.a'</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj.a changed:'</span><span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 或者在Vue实例创建后使用this.$watch  </span>
<span class="token comment" spellcheck="true">// this.$watch('obj.a', function (newVal, oldVal) { ... });</span>
</code></pre>
<h3 id="监听数组元素的变化"><a href="#监听数组元素的变化" class="headerlink" title="监听数组元素的变化"></a>监听数组元素的变化</h3><p>由于Vue 2不能检测到数组索引的直接变化，所以你不能直接监听一个数组元素的变化。但你可以使用Vue的<code>watch</code>配合计算属性（computed properties）或其他逻辑来间接地实现这一点。</p>
<p>然而，对于数组本身的变化（如长度变化或特定方法的调用），Vue 2是可以检测到的。如果你需要监听这些变化，你可以在Vue实例中设置一个监听器。</p>
<h3 id="手动监听对象或数组属性"><a href="#手动监听对象或数组属性" class="headerlink" title="手动监听对象或数组属性"></a>手动监听对象或数组属性</h3><p>如果你需要更细粒度的控制，或者Vue的响应式系统不能满足你的需求，你可以使用<code>Object.defineProperty</code>（对于对象）或手动检测数组的变化（对于数组）。但请注意，这样做可能会与Vue的响应式系统产生冲突或导致不可预测的行为。</p>
<h3 id="使用Vue-3的Composition-API"><a href="#使用Vue-3的Composition-API" class="headerlink" title="使用Vue 3的Composition API"></a>使用Vue 3的Composition API</h3><p>如果你正在考虑迁移到Vue 3，那么Composition API中的<code>ref</code>和<code>reactive</code>函数以及<code>watch</code>和<code>watchEffect</code>函数提供了更强大和灵活的响应式系统。在Vue 3中，你可以使用<code>reactive</code>来创建一个响应式对象，并使用<code>watch</code>来监听它的任何属性的变化，而不需要担心Vue无法检测到的边缘情况。</p>
<p>总之，在Vue 2中监听对象或数组属性的变化通常需要使用Vue的<code>watch</code>选项或方法，但请注意Vue 2的响应式系统的限制。如果你需要更复杂的逻辑或更细粒度的控制，你可能需要手动实现或使用其他库来帮助你。</p>
<h4 id="Vue2中vm-set-的实现原理"><a href="#Vue2中vm-set-的实现原理" class="headerlink" title="Vue2中vm.$set 的实现原理"></a>Vue2中vm.$set 的实现原理</h4><p>在 Vue 2 中，<code>vm.$set</code> 方法用于向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。Vue 的响应式系统是基于 <code>Object.defineProperty</code> 实现的，而 <code>Object.defineProperty</code> 无法检测到对象新属性的添加或删除，这是它的一个限制。因此，Vue 提供了 <code>vm.$set</code> 方法来绕过这个限制。</p>
<p><code>vm.$set</code> 的实现原理大致如下：</p>
<ol>
<li><strong>判断目标是否为数组</strong>：如果目标是一个数组，Vue 会尝试使用数组的 <code>splice</code> 方法来确保新添加的元素也是响应式的，并触发视图更新。这是因为 Vue 可以检测到数组 <code>splice</code> 方法的调用，从而触发更新。</li>
<li><strong>判断目标是否为对象</strong>：如果目标是一个对象，Vue 会使用 <code>Object.defineProperty</code> 来定义新属性。但是，由于 <code>Object.defineProperty</code> 不能检测到新属性的添加，所以 Vue 还需要做一些额外的工作来确保新属性是响应式的。<ul>
<li>Vue 会在内部维护一个依赖追踪系统，用于跟踪哪些属性被用于渲染。当使用 <code>vm.$set</code> 添加新属性时，Vue 会将这个新属性添加到依赖追踪系统中。</li>
<li>当组件重新渲染时，Vue 会遍历这个依赖追踪系统，检查哪些属性发生了变化。如果某个属性是新添加的（即之前没有被用于渲染），Vue 就会知道需要触发一次更新。</li>
</ul>
</li>
<li><strong>触发视图更新</strong>：无论是通过数组 <code>splice</code> 方法还是对象属性的添加，一旦 Vue 检测到变化，它就会触发一次组件的重新渲染，从而更新视图。</li>
</ol>
<p>需要注意的是，虽然 <code>vm.$set</code> 可以确保新添加的属性是响应式的，但它并不能将已经存在的非响应式属性转换为响应式属性。如果你尝试将一个已经存在的非响应式属性转换为响应式属性，那么 <code>vm.$set</code> 是无效的。此外，如果你直接在对象的原型链上添加属性，那么这些属性也不会是响应式的。</p>
<p>最后，Vue 3 的响应式系统基于 ES6 的 <code>Proxy</code> 实现，它可以更加直接地检测到对象属性的添加、删除和修改，从而不再需要 <code>vm.$set</code> 这样的方法来实现响应式。</p>
<h4 id="Vue-中的数据为什么频繁变化时只会更新一次-？"><a href="#Vue-中的数据为什么频繁变化时只会更新一次-？" class="headerlink" title="Vue 中的数据为什么频繁变化时只会更新一次 ？"></a>Vue 中的数据为什么频繁变化时只会更新一次 ？</h4><p>​    在 Vue 中，当数据频繁变化时，Vue 会对数据变化进行优化处理，以减少不必要的更新操作，从而提高性能。    </p>
<blockquote>
<p>Vue 使用了异步更新队列的机制，即将数据变化的通知放入队列中，然后在下一个事件循环周期中统一进行更新操作。这样做的好处是，当数据频繁变化时，不会立即触发更新，而是等待下一个事件循环周期进行批量更新，从而避免了频繁的更新操作。</p>
<p>具体来说，当多次修改数据时，Vue 会将这些修改操作合并为一个更新操作。例如，连续对同一个数据进行多次修改，只会触发一次更新操作，以最终的修改结果为准。</p>
<p>这种优化机制可以有效减少不必要的 DOM 操作和重新渲染，提升性能和效率。同时，也避免了频繁的更新导致的性能问题和不必要的资源消耗。</p>
</blockquote>
<p>​    然而，需要注意的是，由于异步更新机制，Vue 在某些特定场景下可能无法立即获取到最新的数据。如果需要在数据更新后立即执行某些操作，可以利用 Vue 提供的 <code>$nextTick</code> 方法或使用 Vue 的生命周期钩子函数来确保在更新完成后执行相应的操作。</p>
<p>​    总之，Vue 的更新机制保证了数据变化的高效处理，并通过合并操作减少了不必要的更新，提升了应用的性能和响应速度。</p>
<p>​    </p>
<h5 id="this-nextTick-作用及实现原理"><a href="#this-nextTick-作用及实现原理" class="headerlink" title="this.$nextTick() 作用及实现原理"></a>this.$nextTick() 作用及实现原理</h5><p>​    <code>this.$nextTick()</code> 是 Vue 实例提供的一个方法，用于在 DOM 更新完成后执行回调函数。它的作用是确保在下次 DOM 更新循环结束后执行回调函数，以获取到最新的 DOM 状态。</p>
<blockquote>
<p>实现原理：</p>
<ol>
<li>当调用 <code>this.$nextTick()</code> 方法时，Vue 会将传入的回调函数添加到一个队列中，该队列用于存储待执行的回调函数。</li>
<li>Vue 会检测当前是否存在微任务（Promise 或 MutationObserver）或宏任务（setTimeout 或 setImmediate）队列。</li>
<li>如果存在微任务或宏任务队列，则将回调函数添加到微任务或宏任务队列中，确保在下一个事件循环周期中执行。</li>
<li>如果当前不存在微任务或宏任务队列，则创建一个微任务队列，并将回调函数添加到其中。</li>
<li>在下一个事件循环周期中，Vue 会执行微任务队列中的所有回调函数，并将其从队列中移除。</li>
</ol>
</blockquote>
<p>​    通过这种机制，<code>this.$nextTick()</code> 方法可以保证在 DOM 更新完成后执行回调函数，以便获取到最新的 DOM 状态。这在某些场景下非常有用，比如在修改数据后立即获取更新后的 DOM 元素，或在更新后对某些 DOM 操作进行后续处理。</p>
<p>​    需要注意的是，由于 <code>this.$nextTick()</code> 方法使用了异步更新机制，因此回调函数的执行时机不是立即的，而是在下一个事件循环周期中。如果需要在回调函数执行完成后执行一些操作，可以在回调函数中进行处理，或者使用 <code>Promise</code> 或 <code>async/await</code> 来等待回调函数执行完成。</p>
<h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><h4 id="Vue-组件通讯有哪几种方式"><a href="#Vue-组件通讯有哪几种方式" class="headerlink" title="Vue 组件通讯有哪几种方式"></a>Vue 组件通讯有哪几种方式</h4><blockquote>
<ol>
<li><p>props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的</p>
</li>
<li><p>$parent,$children 获取当前组件的父组件和当前组件的子组件</p>
</li>
<li><p>父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用，用于跨级通讯)</p>
</li>
<li><p>$refs 获取组件实例</p>
</li>
<li><p>envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式</p>
</li>
<li><p>vuex 状态管理</p>
</li>
</ol>
</blockquote>
<p><strong>props &amp; $emit:</strong></p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>Son @changeData<span class="token operator">=</span><span class="token string">"changeData"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
 <span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'@/components/son'</span>
 <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
   name<span class="token punctuation">:</span><span class="token string">'Father'</span><span class="token punctuation">,</span>
   components<span class="token punctuation">:</span><span class="token punctuation">{</span>Son<span class="token punctuation">}</span><span class="token punctuation">,</span>
   methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
     <span class="token function">changeData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//来自子组件的数据</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span>el<span class="token operator">-</span>button @click<span class="token operator">=</span><span class="token string">"handleEmit"</span><span class="token operator">></span>通知父组件需要更改数据了<span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>button<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
 <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
   name<span class="token punctuation">:</span><span class="token string">'Son'</span><span class="token punctuation">,</span>
   methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
     <span class="token function">handleEmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'changeData'</span><span class="token punctuation">,</span><span class="token string">'这是来自子组件的数据'</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p><strong>$parent &amp; $children：</strong></p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>子组件<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span><span class="token string">"Son"</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
      sonData<span class="token punctuation">:</span> <span class="token string">'子组件的数据'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token function">sonHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'子组件的方法'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>fatherData<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//父组件的数据</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span><span class="token function">fantherHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//父组件的方法</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>Son<span class="token operator">></span>父组件<span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'./son.vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'father'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span><span class="token punctuation">{</span>
    Son
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
      fatherData<span class="token punctuation">:</span> <span class="token string">'父组件的数据'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token function">fantherHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'父组件的方法'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sonTitle<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//子组件的数据</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sonHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//子组件的方法</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>这里要注意父组件要在mounted（）这个生命周期对子组件进行取值因为在这时候子组件才完成了 created 与 mounted，并且获取到的数据是一个数组的形式。</p>
<p><strong>provide $ inject：</strong></p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*父组件*/</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
 provide<span class="token punctuation">:</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span><span class="token punctuation">{</span>
     provideData<span class="token punctuation">:</span> <span class="token string">'父组件的数据'</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*子组件*/</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  inject<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'provideData'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  created <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>provideName<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//"父组件的数据"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>$refs：</strong></p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>Son ref<span class="token operator">=</span><span class="token string">"son"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Son<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> Son <span class="token keyword">from</span> <span class="token string">'./son.vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'father'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span><span class="token punctuation">{</span>
    Son
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>son<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/*组件实例*/</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p><strong>envetBus：</strong></p>
<p>需要先创建一个公共的eventBus.js，并将Vue实例暴露出去</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p> 在需要组件通信的组件A中引入eventBus.js，并通过$emit发布回调事件</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>div<span class="token operator">></span>组件A<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>el<span class="token operator">-</span>button @click<span class="token operator">=</span><span class="token string">"changeData"</span><span class="token operator">></span>修改数据A<span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>button<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../bus.js"</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token function">changeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"editData"</span><span class="token punctuation">,</span> <span class="token string">'这是修改后的数据'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>组件B中同样引入eventBus.js文件，并通过$on监听事件回调</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>组件B<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> EventBus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../bus.js"</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mounted<span class="token punctuation">:</span><span class="token punctuation">{</span>
    EventBus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'editData'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> 
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<h4 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h4><p>在 Vue 中，父子组件之间可以通过 props 和事件来进行通信。</p>
<ol>
<li><p>父组件向子组件传递数据：通过在父组件中使用 props 将数据传递给子组件。子组件可以在其模板中通过使用 props 来接收父组件传递的数据。</p>
<p>父组件：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>ChildComponent <span class="token punctuation">:</span>message<span class="token operator">=</span><span class="token string">"parentMessage"</span> <span class="token operator">/</span><span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">'./ChildComponent.vue'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      parentMessage<span class="token punctuation">:</span> <span class="token string">'Hello from parent'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    ChildComponent<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>子组件：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
</li>
<li><p>子组件通过触发事件改变父组件的值：子组件可以通过 $emit 方法触发自定义事件，从而通知父组件进行相应的操作。</p>
<p>父组件：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>ChildComponent <span class="token punctuation">:</span>counter<span class="token operator">=</span><span class="token string">"counter"</span> @increment<span class="token operator">=</span><span class="token string">"handleIncrement"</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>p<span class="token operator">></span>Counter<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> counter <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">import</span> ChildComponent <span class="token keyword">from</span> <span class="token string">'./ChildComponent.vue'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      counter<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    ChildComponent<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">handleIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>子组件：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>
  <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"handleClick"</span><span class="token operator">></span>Increment<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token operator">&lt;</span>script<span class="token operator">></span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'counter'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
</li>
</ol>
<p>​    通过上述方式，父子组件可以进行数据的传递和通信。子组件可以通过触发事件的方式来改变父组件的值。需要注意的是，子组件不能直接修改父组件的 props 数据，而是通过事件向父组件发送请求，由父组件进行相应的操作来修改数据。</p>
<p>​    如果子组件需要修改父组件的数据，父组件可以将需要修改的数据作为 props 传递给子组件，然后子组件通过触发事件来请求父组件进行数据的修改。这样可以保持数据流的单向性，提高组件的可维护性和可预测性。</p>
<h4 id="平行组件通信"><a href="#平行组件通信" class="headerlink" title="平行组件通信"></a>平行组件通信</h4><p>在 Vue 中，平行组件之间的通信可以通过以下几种方式实现：</p>
<blockquote>
<ol>
<li>使用共享状态（Shared State）：可以创建一个共享的数据源，例如 Vuex 状态管理库或者一个全局的事件总线。所有的平行组件都可以访问和修改这个共享的状态，从而实现通信。</li>
<li>使用父组件作为中介：如果平行组件位于同一个父组件下，可以通过父组件作为中介来进行通信。平行组件通过将需要共享的数据或者方法传递给父组件，再由父组件将数据或者方法传递给其他平行组件。</li>
<li>使用事件总线：可以创建一个全局的事件总线，利用 Vue 的实例作为事件中心，平行组件通过订阅和触发事件来进行通信。</li>
<li>使用浏览器的事件系统：平行组件可以通过浏览器的事件系统（如 <code>window.dispatchEvent</code> 和 <code>window.addEventListener</code>）来进行通信。组件可以通过触发自定义事件，然后在其他组件中通过监听这些事件来实现通信。</li>
<li>使用非父子组件通信插件：可以使用一些 Vue 的插件来实现非父子组件之间的通信，例如 Vue Bus、mitt 等。</li>
</ol>
</blockquote>
<p>​    需要根据具体的场景和需求选择合适的通信方式。在选择通信方式时，可以考虑组件之间的关系、数据的复杂度以及通信的频率等因素。</p>
<h4 id="Vue中子组件可以直接改变父组件的数据吗？"><a href="#Vue中子组件可以直接改变父组件的数据吗？" class="headerlink" title="Vue中子组件可以直接改变父组件的数据吗？"></a>Vue中子组件可以直接改变父组件的数据吗？</h4><p>在Vue中，子组件通常不应该直接改变父组件的数据。这是因为Vue遵循单向数据流的原则，即数据从父组件流向子组件，而不是反过来。这种设计有助于保持组件之间的独立性和可维护性。</p>
<p>然而，在某些情况下，你可能需要在子组件中更新父组件的数据。Vue提供了几种方法来实现这一点：</p>
<ol>
<li><strong>使用自定义事件</strong>：子组件可以通过触发一个自定义事件来通知父组件进行更新。父组件可以监听这个事件，并在事件处理函数中更新自己的数据。</li>
</ol>
<pre class=" language-vue"><code class="language-vue">// 子组件  
<template>  
  <button @click="notifyParent">通知父组件</button>  
</template>  
  
<script>  
export default {  
  methods: {  
    notifyParent() {  
      this.$emit('update:data', newValue); // 触发自定义事件，并传递新值  
    }  
  }  
}  
</script>  
  
// 父组件  
<template>  
  <ChildComponent @update:data="updateData" />  
</template>  
  
<script>  
import ChildComponent from './ChildComponent.vue';  
  
export default {  
  components: { ChildComponent },  
  data() {  
    return {  
      parentData: ''  
    };  
  },  
  methods: {  
    updateData(newValue) {  
      this.parentData = newValue; // 更新父组件的数据  
    }  
  }  
}  
</script>
</code></pre>
<ol>
<li><strong>使用<code>.sync</code>修饰符</strong>：Vue 2.3.0+ 版本提供了一个<code>.sync</code>修饰符，它允许子组件以一种更简洁的方式触发父组件的更新。然而，请注意，在Vue 3中，<code>.sync</code>修饰符已被移除。</li>
<li>**使用<code>v-model</code>**：虽然<code>v-model</code>主要用于表单输入元素，但它也可以用于自定义组件，以实现父子组件之间的双向绑定。在自定义组件中，你需要监听一个输入事件（如<code>input</code>），并在事件处理函数中触发一个<code>update:modelValue</code>事件。</li>
<li><strong>使用Vuex或Pinia等状态管理库</strong>：对于大型应用，你可能需要使用Vuex或Pinia等状态管理库来管理应用的状态。这些库允许你在任何组件中访问和更新全局状态。</li>
</ol>
<p>总之，虽然子组件不应该直接改变父组件的数据，但Vue提供了多种方法来实现父子组件之间的数据通信和更新。</p>
<h3 id="状态管理-Vuex"><a href="#状态管理-Vuex" class="headerlink" title="状态管理 - Vuex"></a>状态管理 - Vuex</h3><p>​    Vuex是Vue.js官方提供的状态管理模式和库。它被设计用于解决Vue应用中的状态管理问题。Vuex基于Flux架构和Redux模式，提供了一种集中管理和共享状态的机制。</p>
<p>Vuex的核心概念包括：</p>
<blockquote>
<ol>
<li>State（状态）：用于存储应用的状态数据，类似于组件中的data。它是响应式的，可以通过getter获取和修改。</li>
<li>Mutation（变更）：用于修改状态的方法，类似于组件中的methods。只能进行同步操作，且只能在mutation中修改状态。</li>
<li>Action（动作）：用于处理异步操作或复杂的业务逻辑，可以包含多个mutation的组合。可以触发mutation来修改状态。</li>
<li>Getter（获取器）：用于派生状态，类似于组件中的computed。可以对状态进行计算和包装，提供派生的数据。</li>
<li>Module（模块）：将大型应用的状态拆分为多个模块，每个模块有自己的state、mutation、action和getter。</li>
</ol>
</blockquote>
<p>​    通过使用Vuex，我们可以集中管理和共享应用的状态，使得状态的变化和处理逻辑更可控和可维护。它适用于大型的、状态复杂的应用，可以简化组件之间的通信，提高代码的可读性和可测试性。同时，Vuex也提供了开发工具和插件，方便调试和扩展。</p>
<p>​    在Vue应用中使用Vuex需要先安装和配置，然后在组件中引入和使用。通过定义state、mutations、actions和getters，我们可以在组件中访问和修改共享状态。Vuex还提供了一些辅助函数和工具，用于简化使用和处理异步操作。</p>
<h4 id="mutations-能不能做异步"><a href="#mutations-能不能做异步" class="headerlink" title="mutations 能不能做异步"></a>mutations 能不能做异步</h4><p>​    在Vuex中，mutations默认是同步操作，只能用于修改状态的同步变更。这是为了确保状态的变更是可追踪和可预测的。</p>
<p>​    在某些情况下，我们可能需要在mutations中进行异步操作，比如在异步请求数据后再修改状态。然而，直接在mutations中执行异步操作是不被推荐的做法，因为它会破坏状态变更的可追踪性。</p>
<p>​    如果需要进行异步操作，可以使用actions来处理。Actions可以包含异步操作，并且可以触发mutations来修改状态。这样可以保持状态变更的可追踪性，同时也可以方便地进行异步处理。</p>
<p>示例代码：</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Vuex store</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    count<span class="token punctuation">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">decrement</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">asyncIncrement</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 在组件中使用</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'decrement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">asyncIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'asyncIncrement'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>​    在上述示例中，通过<code>context.commit</code>来触发mutation的执行，<code>this.$store.dispatch</code>来触发action的执行。这样就可以实现异步操作并且保持状态变更的可追踪性。</p>
<p>​    虽然mutations默认是同步操作，但可以通过actions来处理异步操作，并在actions中触发mutations来修改状态。这样可以更好地控制和管理状态的变更过程。</p>
<h4 id="Vuex-页面刷新数据丢失怎么解决"><a href="#Vuex-页面刷新数据丢失怎么解决" class="headerlink" title="Vuex 页面刷新数据丢失怎么解决"></a>Vuex 页面刷新数据丢失怎么解决</h4><p>​    当刷新页面时，由于Vuex中的数据存储在内存中，数据会丢失。这是因为Vuex是基于客户端的状态管理库，数据不会被持久化保存。每次刷新页面都会重新初始化Vuex的状态。</p>
<p>​    为了解决刷新页面导致Vuex数据丢失的问题，可以考虑以下几种方法：</p>
<blockquote>
<ol>
<li>使用持久化方案：可以将Vuex的状态持久化保存到本地存储（如localStorage或sessionStorage）中。在应用初始化时，从本地存储中读取状态并还原到Vuex中。这样可以在刷新页面后重新加载保存的状态，避免数据丢失。</li>
<li>利用路由参数或URL查询参数传递数据：将需要持久化的数据通过路由参数或URL查询参数传递给其他页面。这样在刷新页面时，可以通过获取路由参数或URL查询参数来恢复数据。</li>
<li>使用后端存储方案：如果应用需要长期保存状态数据，并且在不同设备或浏览器中共享状态，可以考虑将状态数据存储在后端服务器或数据库中。在刷新页面时，可以通过请求后端获取保存的状态数据并还原到Vuex中。</li>
</ol>
</blockquote>
<p>​    vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件。推荐使用 <code>vuex-persist</code> 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中</p>
<blockquote>
<p>​    ps: 需要根据具体的应用场景和需求选择适合的方法。持久化方案和后端存储方案可能需要进行数据序列化和反序列化操作，以确保数据的正确保存和恢复。同时，需要注意数据的安全性和隐私保护，避免敏感数据泄露。</p>
</blockquote>
<h4 id="Vuex-和-localStorage-的区别"><a href="#Vuex-和-localStorage-的区别" class="headerlink" title="Vuex 和 localStorage 的区别"></a>Vuex 和 localStorage 的区别</h4><p>Vuex和localStorage是两种不同的概念和用途：</p>
<blockquote>
<ol>
<li>Vuex：Vuex是Vue.js官方提供的状态管理库。它用于在Vue应用中集中管理和共享状态。Vuex的目的是解决组件之间共享数据、状态管理和数据流的问题。Vuex提供了一种集中式的数据存储机制，可以在多个组件中访问和修改共享的状态，以实现组件之间的通信和数据同步。Vuex的数据存储在内存中，它是基于内存的状态管理解决方案，适用于应用内部的数据共享和状态管理。</li>
<li>localStorage：localStorage是Web浏览器提供的一种本地存储机制。它允许将数据以键值对的形式存储在浏览器的本地存储空间中，并且数据在页面刷新或关闭后仍然保持有效。localStorage提供了持久化的存储能力，可以在不同的页面和会话中共享数据。localStorage中的数据以字符串形式存储，需要进行数据的序列化和反序列化。</li>
</ol>
</blockquote>
<p>区别：</p>
<blockquote>
<ul>
<li>Vuex是专门为Vue应用设计的状态管理库，用于管理应用内的状态和数据流，解决组件之间的数据共享和状态管理问题。而localStorage是Web浏览器提供的一种本地存储机制，用于持久化地存储数据，并且在不同的浏览器会话中共享数据。</li>
<li>Vuex的数据存储在内存中，适用于应用内部的数据共享和状态管理，而localStorage的数据存储在浏览器的本地存储空间中，可以在不同的页面和会话中共享数据。</li>
<li>Vuex提供了一套API和机制用于管理和修改状态，包括使用mutation修改状态、使用action处理异步操作等。而localStorage是基于键值对的简单存储机制，只能通过setItem和getItem等方法进行基本的数据存储和读取，没有提供数据管理和状态变更的机制。</li>
</ul>
</blockquote>
<p>​    Vuex适用于Vue应用内部的状态管理和数据共享，而localStorage适用于持久化地存储和共享数据。在具体使用时，可以根据应用需求选择合适的方案或结合两者使用。</p>
<h3 id="虚拟-dom-和-diff-算法"><a href="#虚拟-dom-和-diff-算法" class="headerlink" title="虚拟 dom 和 diff 算法"></a>虚拟 dom 和 diff 算法</h3><p>​    虚拟DOM（Virtual DOM）和差异算法（Diff Algorithm）是前端领域中常用的概念，它们在优化页面渲染性能和提升开发效率方面发挥了重要作用。</p>
<blockquote>
<p>​    虚拟DOM是一种以JavaScript对象形式表示的轻量级的内存中的DOM表示。它是对真实DOM的一种抽象和模拟，在内存中进行操作和计算，然后再将结果批量更新到真实的DOM上。虚拟DOM的目的是在保持视图和状态同步的同时，减少对真实DOM的直接操作，从而提升性能和响应速度。</p>
<p>​    差异算法（Diff Algorithm）是虚拟DOM的核心算法之一，用于比较两个虚拟DOM树之间的差异，并将差异应用到真实的DOM上。通过比较新旧虚拟DOM树的差异，可以准确地找出需要更新的部分，避免全量更新整个DOM树，从而减少不必要的操作和性能损耗。</p>
</blockquote>
<p>​    Diff算法的基本原理是对比新旧虚拟DOM树的节点，找出发生变化的节点，然后根据变化类型（插入、更新、移除等）对真实DOM进行相应的操作。Diff算法通常采用深度优先遍历的方式，通过递归遍历虚拟DOM树的节点，对比节点之间的差异，生成更新操作的指令。</p>
<p>常用的Diff算法有两种实现方式：基于递归的Diff算法和基于循环的Diff算法。</p>
<blockquote>
<p>​    基于递归的Diff算法简单直观，但在处理大型虚拟DOM树时可能存在性能问题。</p>
<p>​    基于循环的Diff算法采用迭代的方式，通过循环遍历虚拟DOM树的节点，以较低的时间复杂度找出差异。</p>
</blockquote>
<p>​    虚拟DOM和差异算法是前端开发中用于优化页面渲染性能的重要技术。虚拟DOM提供了一种高效的内存中的DOM表示，而差异算法则能够准确地比较两个虚拟DOM树之间的差异，最小化对真实DOM的操作，从而提高页面的性能和响应速度。</p>
<h4 id="什么是虚拟-dom-？有什么用？"><a href="#什么是虚拟-dom-？有什么用？" class="headerlink" title="什么是虚拟 dom ？有什么用？"></a>什么是虚拟 dom ？有什么用？</h4><p>​    虚拟DOM（Virtual DOM）是一种在内存中构建和操作的虚拟的DOM树。它是对真实DOM的一种抽象和模拟，用JavaScript对象表示整个DOM结构及其属性。</p>
<p>​    虚拟DOM的基本思想是将页面的状态（数据）和视图（DOM）分离，通过对虚拟DOM的操作来更新视图，而不是直接操作真实的DOM。当数据发生变化时，会通过比较新旧虚拟DOM的差异（Diff算法），找出需要更新的部分，然后将更新应用到真实DOM上，从而保持页面和数据的同步。</p>
<p>虚拟DOM的主要优点包括：</p>
<blockquote>
<ol>
<li>性能优化：通过将DOM操作集中在虚拟DOM上，减少了直接操作真实DOM的次数，从而提高了性能。虚拟DOM可以批量更新真实DOM，避免了频繁的重绘和回流。</li>
<li>跨平台能力：虚拟DOM可以在不同的平台上运行，例如浏览器、移动端、服务器端等。这样可以实现一次编写，多平台复用。</li>
<li>方便的UI组件化：虚拟DOM可以将整个页面划分为组件，每个组件都有自己的虚拟DOM。这样可以实现组件的高度复用和模块化开发。</li>
<li>简化复杂的UI更新逻辑：通过比较新旧虚拟DOM的差异，可以精确地找出需要更新的部分，避免全量更新整个DOM树，从而简化了复杂的UI更新逻辑。</li>
</ol>
</blockquote>
<p>​    虚拟DOM通过在内存中构建和操作DOM的抽象表示，提供了一种高效、跨平台、组件化的方式来管理和更新页面的视图。它是现代前端框架（如React、Vue等）中的重要概念，能够提升开发效率和页面性能。</p>
<h5 id="虚拟DOM的解析过程"><a href="#虚拟DOM的解析过程" class="headerlink" title="虚拟DOM的解析过程:"></a>虚拟DOM的解析过程:</h5><p>虚拟DOM的解析过程可以简单分为三个步骤：<strong>创建</strong>、<strong>更新</strong>和<strong>渲染</strong>。</p>
<blockquote>
<ol>
<li>创建虚拟DOM（Virtual DOM）：在应用程序初始化时，通过使用特定的语法或调用相关API创建虚拟DOM。虚拟DOM是使用JavaScript对象表示整个DOM结构及其属性，它包括节点类型、标签名、属性、子节点等信息。</li>
<li>更新虚拟DOM：当应用程序的状态（数据）发生变化时，需要更新虚拟DOM以反映这些变化。这个过程通常由框架或库内部的更新机制自动处理，它会根据新的数据生成新的虚拟DOM，并与旧的虚拟DOM进行比较，找出差异（Diff算法）。</li>
<li>渲染虚拟DOM：在更新虚拟DOM后，需要将最新的虚拟DOM渲染到真实的DOM上，以更新页面的显示。这个过程通常由框架或库提供的渲染引擎负责处理，它会根据虚拟DOM的变化，将变化部分应用到真实DOM上，从而更新页面的内容。</li>
</ol>
</blockquote>
<p>具体来说，虚拟DOM的解析过程如下：</p>
<blockquote>
<ol>
<li>创建虚拟DOM：根据应用程序的需求，通过特定的语法或调用相关API创建虚拟DOM。这可以是手动创建的，也可以是由框架或库自动生成的。</li>
<li>更新虚拟DOM：当应用程序的状态发生变化时，生成新的虚拟DOM，并与旧的虚拟DOM进行比较，找出差异（Diff算法）。差异通常包括节点的增、删、改、移等操作。</li>
<li>应用差异：将差异应用到真实DOM上，更新页面的显示。这个过程可以通过操作真实DOM进行，也可以通过一些优化技术（例如批量更新、异步渲染等）来提高性能。</li>
<li>渲染页面：根据最新的虚拟DOM，将其渲染到真实DOM上，更新页面的内容。这可以是整个虚拟DOM的渲染，也可以是部分虚拟DOM的渲染，具体取决于差异的范围。</li>
</ol>
</blockquote>
<p>​    虚拟DOM的解析过程是一个通过创建、更新和渲染虚拟DOM来实现页面更新的过程。它通过比较差异，减少了对真实DOM的频繁操作，提高了性能和用户体验。</p>
<h4 id="Vue中是如何将模版语法转换为虚拟DOM的？"><a href="#Vue中是如何将模版语法转换为虚拟DOM的？" class="headerlink" title="Vue中是如何将模版语法转换为虚拟DOM的？"></a>Vue中是如何将模版语法转换为虚拟DOM的？</h4><p>在Vue中，模板语法被转换为虚拟DOM（Virtual DOM）的过程涉及多个步骤，这些步骤主要由Vue的编译器和运行时系统完成。以下是一个简化的概述：</p>
<ol>
<li><strong>解析模板</strong>：<ul>
<li>Vue首先使用其内置的HTML解析器将模板字符串解析成一个抽象语法树（AST）。这个AST是一个树形结构，它表示了模板中的HTML元素、属性、文本以及其他Vue特定的指令（如<code>v-if</code>、<code>v-for</code>等）。</li>
<li>解析过程中，Vue会识别并处理模板中的特殊语法，如插值表达式（<code>&#123;&#123; message &#125;&#125;</code>）和指令（<code>v-bind:class=&quot;active&quot;</code>）。</li>
</ul>
</li>
<li><strong>优化AST</strong>：<ul>
<li>在生成AST之后，Vue会对其进行一些优化。例如，它会检测并删除静态子树（即那些永远不会改变的元素和属性），以便在后续的渲染过程中跳过它们。</li>
<li>Vue还会对AST进行其他优化，如常量折叠和表达式简化，以进一步减少运行时的计算量。</li>
</ul>
</li>
<li><strong>生成渲染函数</strong>：<ul>
<li>基于优化后的AST，Vue会生成一个渲染函数（render function）。这个渲染函数是一个纯JavaScript函数，它接受一个“创建元素”的函数作为参数，并返回一个虚拟节点（VNode）作为结果。</li>
<li>虚拟节点（VNode）是Vue中的一个核心概念，它是一个轻量级的JavaScript对象，描述了DOM元素的结构和属性。虚拟节点是Vue实现高效DOM更新策略的关键。</li>
</ul>
</li>
<li><strong>创建虚拟DOM</strong>：<ul>
<li>当渲染函数被调用时，它会返回一个虚拟节点（VNode）。这个虚拟节点描述了整个模板对应的DOM树的结构和属性。</li>
<li>Vue的运行时系统会维护一个内部的虚拟DOM树，这个树与实际的DOM树保持同步。当数据发生变化时，Vue会重新运行渲染函数来生成一个新的虚拟DOM树，并与旧的虚拟DOM树进行比较。</li>
</ul>
</li>
<li><strong>差异算法</strong>：<ul>
<li>Vue使用了一个高效的差异算法（称为“patch”算法）来比较新旧两个虚拟DOM树之间的差异。这个算法会找出哪些部分已经改变，哪些部分没有改变，并生成一个描述这些差异的“补丁”（patch）。</li>
<li>然后，Vue会根据这个补丁来更新实际的DOM树，只修改那些真正需要改变的部分，从而实现高效的DOM更新。</li>
</ul>
</li>
</ol>
<p>总的来说，Vue通过将模板语法转换为虚拟DOM，并利用高效的差异算法来更新DOM，从而实现了快速、高效的视图渲染和更新。</p>
<h4 id="Vue中虚拟dom变成实际-dom-是怎么发生的？"><a href="#Vue中虚拟dom变成实际-dom-是怎么发生的？" class="headerlink" title="Vue中虚拟dom变成实际 dom 是怎么发生的？"></a>Vue中虚拟dom变成实际 dom 是怎么发生的？</h4><p>在Vue中，虚拟DOM（VNode）转化为实际DOM的过程主要发生在Vue的渲染函数中。这个过程大致可以分为以下几个步骤：</p>
<ol>
<li><strong>创建虚拟DOM</strong>：当Vue组件的状态发生变化时，Vue会重新执行渲染函数，生成一个新的虚拟DOM树。这个虚拟DOM树是一个轻量级的JavaScript对象，描述了页面的结构和状态。</li>
<li><strong>对比新旧虚拟DOM</strong>：Vue会使用diff算法来对比新旧两个虚拟DOM树之间的差异。这个算法会尽可能地复用旧的DOM节点，以减少不必要的DOM操作。具体来说，diff算法会按照以下步骤进行：<ul>
<li>从新旧VNode的头部和尾部开始比较，寻找可以复用的节点。</li>
<li>如果找到可以复用的节点，则跳过它们，继续比较下一对节点。</li>
<li>如果找不到可以复用的节点，则创建一个新的DOM节点。</li>
<li>递归地遍历每个新旧节点对，执行相同的比较和复用过程。</li>
</ul>
</li>
<li><strong>生成差异补丁</strong>：在对比完新旧虚拟DOM之后，Vue会生成一个描述差异的“补丁”（patch）。这个补丁包含了需要执行的DOM操作，如节点的增删改等。</li>
<li><strong>应用差异补丁</strong>：最后，Vue会根据生成的差异补丁来更新实际的DOM树。这个过程是通过Vue的patch函数来实现的，它会遍历差异补丁并执行相应的DOM操作。由于Vue在diff过程中已经尽可能地复用了旧的DOM节点，所以这个过程通常是非常高效和快速的。</li>
</ol>
<p>总的来说，Vue通过创建虚拟DOM、对比新旧虚拟DOM、生成差异补丁和应用差异补丁等步骤，实现了将虚拟DOM转化为实际DOM的过程。这个过程不仅提高了页面渲染的效率，还减少了不必要的DOM操作，从而提升了页面的性能和用户体验。</p>
<h4 id="怎么实现虚拟dom-和实际dom-的分离和衔接？"><a href="#怎么实现虚拟dom-和实际dom-的分离和衔接？" class="headerlink" title="怎么实现虚拟dom 和实际dom 的分离和衔接？"></a>怎么实现虚拟dom 和实际dom 的分离和衔接？</h4><p>在Vue中，虚拟DOM（VNode）与实际DOM的分离和衔接是通过Vue的渲染系统来实现的。以下是这个过程的基本步骤：</p>
<h3 id="虚拟DOM与实际DOM的分离"><a href="#虚拟DOM与实际DOM的分离" class="headerlink" title="虚拟DOM与实际DOM的分离"></a>虚拟DOM与实际DOM的分离</h3><ol>
<li><strong>模板编译</strong>：首先，Vue会将组件的模板编译成渲染函数。这个渲染函数是一个JavaScript函数，它会返回一个描述页面结构的虚拟DOM（VNode）树。这个VNode树是实际DOM的一个抽象表示，它包含了节点类型、属性、子节点等信息，但不包含实际的DOM对象。</li>
<li><strong>响应式数据</strong>：Vue使用响应式系统来跟踪组件状态的变化。当组件的响应式数据发生变化时，Vue会重新执行渲染函数，生成一个新的VNode树。</li>
</ol>
<h3 id="虚拟DOM与实际DOM的衔接"><a href="#虚拟DOM与实际DOM的衔接" class="headerlink" title="虚拟DOM与实际DOM的衔接"></a>虚拟DOM与实际DOM的衔接</h3><ol>
<li><strong>新旧VNode对比（Diffing）</strong>：当新的VNode树生成后，Vue会使用一个高效的diff算法来对比新旧两个VNode树。这个算法会找出哪些节点是新增的、哪些节点是修改的、哪些节点是删除的，并生成一个描述这些差异的“补丁”（patch）。</li>
<li><strong>应用补丁</strong>：然后，Vue会遍历这个补丁，并根据其中的指令来更新实际的DOM树。这个过程是通过Vue的patch函数来实现的。patch函数会遍历补丁中的每个节点，并执行相应的DOM操作（如创建、更新、删除节点等）。</li>
<li><strong>复用节点</strong>：为了提高性能，Vue会尽可能地复用旧的DOM节点。在diff过程中，Vue会检查新旧VNode的属性和子节点是否相同，如果相同则直接复用旧的DOM节点，而不是重新创建一个新的节点。这样可以减少不必要的DOM操作，提高页面的渲染性能。</li>
</ol>
<p><strong>总结</strong></p>
<p>Vue通过模板编译、响应式数据、新旧VNode对比和应用补丁等步骤，实现了虚拟DOM与实际DOM的分离和衔接。这种分离和衔接的方式不仅提高了页面的渲染性能，还使得开发者可以更加关注业务逻辑和数据状态，而不需要过多地关心DOM操作的细节。</p>
<h4 id="Virtual-Dom的优势在哪里？"><a href="#Virtual-Dom的优势在哪里？" class="headerlink" title="Virtual Dom的优势在哪里？"></a>Virtual Dom的优势在哪里？</h4><p>Virtual DOM（虚拟DOM）的优势主要体现在以下几个方面：</p>
<ol>
<li><p>性能优化</p>
<p>：</p>
<ul>
<li><strong>减少直接DOM操作</strong>：直接操作DOM是昂贵的，因为每次DOM变更都会导致浏览器重新计算布局和重绘。Virtual DOM允许我们先在内存中构建和修改一个轻量级的JavaScript对象树（VNode树），然后再一次性将这个对象树渲染到真实的DOM上。这减少了不必要的DOM操作，提高了性能。</li>
<li><strong>智能的diff算法</strong>：当数据变更时，Virtual DOM库（如React、Vue等）会使用高效的diff算法来对比新旧VNode树，找出需要变更的部分，并生成一个“补丁”（patch）。然后，这个“补丁”会被应用到真实的DOM上，只更新那些真正需要变更的部分，而不是整个DOM树。</li>
</ul>
</li>
<li><p>跨平台兼容性</p>
<p>：</p>
<ul>
<li>Virtual DOM允许开发者编写一套代码，并在不同的平台（如Web、Native等）上运行。这是因为Virtual DOM库可以针对不同的平台实现不同的渲染器（renderer），将相同的VNode树渲染成不同平台的UI。</li>
</ul>
</li>
<li><p>简化复杂度和开发体验</p>
<p>：</p>
<ul>
<li>开发者可以直接操作JavaScript对象（VNode），而不是直接操作DOM。这使得代码更加直观和易于理解。</li>
<li>开发者可以使用声明式的方式来描述UI，而不是使用命令式的方式来直接操作DOM。这降低了代码的复杂度和出错的可能性。</li>
<li>Virtual DOM库通常还提供了丰富的组件生态和工具链，可以进一步提高开发效率和代码质量。</li>
</ul>
</li>
<li><p>更好的可测试性</p>
<p>：</p>
<ul>
<li>由于Virtual DOM是JavaScript对象，所以可以使用JavaScript的测试框架和工具来测试它。这使得UI测试更加容易和可靠。</li>
</ul>
</li>
<li><p>便于实现复杂的UI特性</p>
<p>：</p>
<ul>
<li>Virtual DOM可以方便地实现一些复杂的UI特性，如动画、状态管理、组件化等。这是因为开发者可以在JavaScript层面进行更细粒度的控制和优化。</li>
</ul>
</li>
<li><p>可预测性</p>
<p>：</p>
<ul>
<li>Virtual DOM的渲染过程是可预测的，因为它遵循了先构建VNode树，再diff和patch到真实DOM的流程。这减少了由于直接操作DOM而导致的不确定性和副作用。</li>
</ul>
</li>
</ol>
<p>需要注意的是，虽然Virtual DOM带来了很多优势，但它并不是所有情况下都是最佳选择。在某些简单的UI场景或性能要求极高的场景中，直接操作DOM可能会更加高效。因此，在选择是否使用Virtual DOM时，需要根据具体的应用场景和需求来权衡利弊。</p>
<h4 id="虚拟DOM真的比真实DOM性能好吗"><a href="#虚拟DOM真的比真实DOM性能好吗" class="headerlink" title="虚拟DOM真的比真实DOM性能好吗"></a>虚拟DOM真的比真实DOM性能好吗</h4><p>虚拟DOM（Virtual DOM）与真实DOM（Real DOM）的性能比较并非一概而论，因为它们各自有其优势和劣势，具体取决于使用场景和上下文。</p>
<p>虚拟DOM的优势主要体现在以下几个方面：</p>
<ol>
<li><strong>性能优化</strong>：虚拟DOM通过在JavaScript对象上进行计算和比较，减少了对实际DOM的直接操作。当数据发生变化时，它只更新变化的部分，并生成一个描述差异的“补丁”，然后一次性将这个补丁应用到真实DOM上，从而提高了渲染性能。</li>
<li><strong>跨平台兼容性</strong>：虚拟DOM允许开发者编写一套代码，并在不同的平台（如Web、Native等）上运行。这是因为虚拟DOM库可以针对不同的平台实现不同的渲染器，将相同的VNode树渲染成不同平台的UI。</li>
<li><strong>简化复杂度和开发体验</strong>：开发者可以直接操作JavaScript对象（VNode），而不是直接操作DOM。这使得代码更加直观和易于理解。同时，开发者可以使用声明式的方式来描述UI，而不是使用命令式的方式来直接操作DOM，这降低了代码的复杂度和出错的可能性。</li>
</ol>
<p>然而，虚拟DOM也存在一些劣势：</p>
<ol>
<li><strong>额外的内存消耗</strong>：虚拟DOM需要在内存中构建和存储VNode树，这会增加额外的内存消耗。如果页面庞大或复杂，这种内存消耗可能会更加明显。</li>
<li><strong>初始渲染速度</strong>：在初始渲染时，虚拟DOM需要先构建VNode树，然后再将其渲染到真实DOM上。这个过程可能比直接操作真实DOM要慢一些，尤其是在页面首次加载时。</li>
<li><strong>diff算法的性能</strong>：虚拟DOM的diff算法虽然高效，但在某些情况下（如大量节点变更、深度嵌套等）可能会产生一定的性能开销。</li>
</ol>
<p>相比之下，真实DOM的优势在于：</p>
<ol>
<li><strong>直接操作DOM</strong>：真实DOM直接在浏览器中操作实际的DOM元素，确保了可靠的渲染和交互。它提供了各种原生的API和事件处理机制，可以直接操作DOM元素。</li>
<li><strong>性能较低但直接</strong>：当数据变化较频繁时，真实DOM需要频繁地进行重排、重绘等操作，导致性能下降。然而，在某些情况下（如简单的UI场景或性能要求极高的场景），直接操作DOM可能会更加高效。</li>
</ol>
<p>综上所述，虚拟DOM和真实DOM各有其优缺点。在选择使用哪种方式时，需要根据具体的应用场景和需求来权衡利弊。在某些情况下，虚拟DOM可能会提供更好的性能和开发体验；而在其他情况下，真实DOM可能更加适合。</p>
<h4 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h4><p>​    Diff算法是虚拟DOM更新的核心算法，它用于比较新旧虚拟DOM之间的差异，并根据差异进行最小化的DOM操作，以提高更新效率。</p>
<p>​    Diff算法的基本原理是通过逐层比较新旧虚拟DOM的节点，找出节点之间的差异，并记录下来。它遵循以下几个基本规则：</p>
<blockquote>
<ol>
<li>同层比较：Diff算法会逐层比较新旧虚拟DOM的节点，并将它们进行一一对比。如果节点类型不同，直接替换节点；如果节点类型相同但属性不同，更新节点的属性；如果节点类型和属性都相同，继续比较其子节点。</li>
<li>列表比较：当比较的节点是列表（数组）类型时，Diff算法会使用特定的算法进行列表比较，例如使用唯一的key来标识列表项，以避免整个列表重新渲染。</li>
<li>唯一标识：Diff算法会使用唯一的标识（通常是key属性）来识别节点，以便在比较过程中准确定位节点的位置，从而进行精确的差异对比和操作。</li>
<li>递归比较：Diff算法会递归地比较节点的子节点，以确保所有层级的差异都能被发现和处理。</li>
</ol>
</blockquote>
<p>​    通过以上规则，Diff算法能够在比较的过程中找出两个虚拟DOM之间的差异，并生成一个差异对象（或称为补丁），记录下需要进行的DOM操作，例如插入、删除、更新等。然后，这个差异对象可以被应用到真实的DOM上，进行最小化的DOM操作，以实现页面的更新。</p>
<p>​    Diff算法的优点是能够准确地识别差异，并最小化DOM操作，提高页面更新的效率。然而，它也有一些限制和性能方面的考虑，例如当比较的虚拟DOM结构非常复杂时，Diff算法的性能可能会下降，需要合理地设计虚拟DOM结构和优化更新策略来提升性能。</p>
<p>​    Diff算法是虚拟DOM实现高效更新的核心，它通过比较新旧虚拟DOM之间的差异，实现最小化的DOM操作，从而提高页面更新的效率。</p>
<h4 id="Vue2中的diff流程"><a href="#Vue2中的diff流程" class="headerlink" title="Vue2中的diff流程"></a>Vue2中的diff流程</h4><p>在Vue2中，diff流程主要指的是当数据发生变化时，Vue如何对比新旧虚拟DOM（VNode）之间的差异，并以最少的DOM操作来更新页面内容。这个流程主要由Vue的diff算法来负责。</p>
<p>以下是Vue2中diff流程的大致步骤：</p>
<ol>
<li>初始化阶段<ul>
<li>通过Vue实例的构造函数，将data数据转为响应式对象。这包括遍历data的属性，对每个属性使用<code>Object.defineProperty()</code>添加getter和setter方法。</li>
<li>初始化一个依赖收集器Dep。</li>
</ul>
</li>
<li>模板编译阶段<ul>
<li>通过解析模板，找到其中绑定的数据，将数据与DOM元素建立关联，并创建对应的Watcher。Watcher作为观察者会在数据变化时触发更新。</li>
</ul>
</li>
<li>依赖收集阶段<ul>
<li>在Watcher的实例化过程中，会获取模板中绑定的数据，触发数据的getter方法。</li>
<li>setter方法中会调用依赖收集器Dep的notify方法，通知所有相关的Watcher进行更新操作。</li>
</ul>
</li>
<li>生成新的虚拟DOM<ul>
<li>当数据发生变化时，相关的Watcher会被触发，重新执行模板编译，生成新的虚拟DOM。</li>
</ul>
</li>
<li>diff算法<ul>
<li>Vue使用diff算法来对比新旧两个虚拟DOM树之间的差异。这个算法的核心思想是通过同层的树节点进行比较，避免了对树进行逐层搜索遍历。</li>
<li>Vue首先会比较新旧两个虚拟节点的头部和尾部节点，看是否可以复用。如果可以，则跳过它们，继续比较下一对节点。</li>
<li>如果头部或尾部的节点不匹配，Vue会尝试以新节点的头部为基准，在旧节点树中查找是否有可以复用的节点。如果有，则复用该节点，并调整真实DOM的位置。</li>
<li>如果找不到可以复用的节点，Vue会创建新的DOM元素。</li>
<li>对于每个新旧节点对，Vue都会递归地遍历它们的子节点，进行相同的比较和复用过程。</li>
</ul>
</li>
<li>应用差异<ul>
<li>根据diff算法的结果，Vue会生成一个描述差异的“补丁”（patch）。</li>
<li>然后，Vue会根据这个补丁来更新实际的DOM树，只修改那些真正需要改变的部分。</li>
</ul>
</li>
</ol>
<p>需要注意的是，Vue2中的diff算法在处理列表渲染时，如果列表项没有使用唯一的<code>key</code>属性，可能会导致性能问题。因为Vue会使用一种“就地复用”的策略来复用列表项，这可能会导致一些意外的副作用。因此，在开发过程中，我们应该尽量为列表项提供一个唯一的<code>key</code>属性。</p>
<h4 id="Vue3中的diff流程"><a href="#Vue3中的diff流程" class="headerlink" title="Vue3中的diff流程"></a>Vue3中的diff流程</h4><p>Vue3中的diff流程相较于Vue2有所改进和优化，特别是在处理组件和列表渲染时。以下是Vue3中diff流程的大致步骤：</p>
<ol>
<li>初始化阶段<ul>
<li>Vue3使用Proxy代替了Vue2中的Object.defineProperty来实现数据的响应式。这使得Vue3在处理数组和对象时更加高效和灵活。</li>
</ul>
</li>
<li>模板编译阶段<ul>
<li>Vue3的编译器将模板编译为渲染函数，该渲染函数返回描述页面结构的VNode（虚拟节点）树。</li>
</ul>
</li>
<li>diff算法准备阶段<ul>
<li>在进行diff之前，Vue3会先进行一些准备工作，如标记需要被复用的节点、记录需要移动的节点等。这些准备工作有助于提高diff的效率。</li>
</ul>
</li>
<li>diff算法执行阶段<ul>
<li>Vue3的diff算法会按照以下步骤执行：<ol>
<li><strong>比较key</strong>：如果新老VNode的key不同，则认为这两个节点是不同的，直接跳过。</li>
<li><strong>比较类型</strong>：如果新老VNode的类型不同（例如，一个是元素节点，另一个是组件节点），也认为这两个节点是不同的，直接跳过。</li>
<li><strong>跳过相同节点</strong>：如果当前新老VNode节点是相同的（基于key和类型判断），则继续递归比较其子节点。</li>
<li><strong>标记复用节点</strong>：如果找到一个新的VNode节点可以与某个旧的VNode节点复用（例如，节点的key和类型都相同，但内容可能不同），则将该旧节点从节点池中删除并记录复用节点。</li>
<li><strong>创建新节点</strong>：如果新的VNode节点不能复用任何一个旧的VNode节点，则创建一个新的VNode节点并记录它。</li>
<li><strong>记录移动节点</strong>：如果新的VNode节点不能复用任何一个旧的VNode节点，并且每个旧节点都不等于新节点，则记录需要移动的节点。</li>
</ol>
</li>
</ul>
</li>
<li>应用阶段<ul>
<li>在应用阶段中，Vue3将根据标记阶段中生成的具体操作（如创建、更新、删除节点等）执行patchFn函数，实现对真实DOM的修改和更新。这个过程使用了Vue3的patch函数和相应的优化策略，以最小化DOM操作并提高性能。</li>
</ul>
</li>
</ol>
<p>需要注意的是，Vue3的diff算法在处理列表渲染时，特别强调了使用唯一的<code>key</code>属性的重要性。使用<code>key</code>可以帮助Vue3更准确地识别哪些节点可以复用，哪些节点需要移动或删除，从而提高列表渲染的性能。</p>
<h4 id="Vue2与Vue3两者Diff流程的区别"><a href="#Vue2与Vue3两者Diff流程的区别" class="headerlink" title="Vue2与Vue3两者Diff流程的区别"></a>Vue2与Vue3两者Diff流程的区别</h4><p>Vue2与Vue3的Diff流程之间存在一些关键的区别，这些区别主要体现在对节点处理的方式和优化策略上。</p>
<ol>
<li><strong>处理剩余节点的方式</strong>：<ul>
<li>Vue2：在处理完首尾节点后，Vue2会遍历旧节点，将旧节点映射到map里，然后再遍历新节点，看是否有可以复用的节点。如果有，则打上补丁（patch）；如果没有，则执行相应的创建或删除操作。</li>
<li>Vue3：Vue3在处理完首尾节点后，会建立一个新节点的剩余节点在旧节点中的位置的数组。然后，它通过这个数组找到一个最长递增子序列，这个序列的节点会保持不动。接下来，Vue3会移动剩下的节点，以最小化DOM操作。</li>
</ul>
</li>
<li><strong>对key的处理</strong>：<ul>
<li>在Vue2中，虽然也推荐使用key来标识列表中的每个节点，但如果不使用key，Vue2会使用一种“就地复用”的策略来复用列表项，这可能会导致一些意外的副作用。</li>
<li>Vue3更加强调了key的重要性。在Vue3中，如果新老VNode的key不同，则认为这两个节点是不同的，直接跳过比较。这种策略有助于Vue3更准确地识别哪些节点可以复用，哪些节点需要移动或删除。</li>
</ul>
</li>
<li><strong>优化策略</strong>：<ul>
<li>Vue3在Diff流程中引入了一些新的优化策略，如静态节点提升、静态子树提升和事件监听器的优化等。这些优化策略旨在进一步提高Vue的性能和响应速度。</li>
<li>Vue2虽然也进行了一些优化，但Vue3的优化更加深入和全面。</li>
</ul>
</li>
<li><strong>比较策略</strong>：<ul>
<li>Vue2的Diff算法主要使用首尾比较法（头-头、头-尾、尾-头、尾-尾），然后根据比较结果执行相应的创建、更新或删除操作。</li>
<li>Vue3的Diff算法在比较策略上更加灵活和高效。它通过建立节点位置数组和寻找最长递增子序列来最小化DOM操作，从而提高了性能。</li>
</ul>
</li>
</ol>
<p>总的来说，Vue3的Diff流程相较于Vue2更加高效和优化，特别是在处理复杂列表和组件时。这些改进使得Vue3在性能和响应速度方面都有了显著的提升。</p>
<h4 id="Vue的diff算法和React的diff算法的异同"><a href="#Vue的diff算法和React的diff算法的异同" class="headerlink" title="Vue的diff算法和React的diff算法的异同"></a>Vue的diff算法和React的diff算法的异同</h4><p>Vue和React都使用了diff算法来优化DOM的更新过程，但它们在实现方式和优化策略上存在一些异同。</p>
<p>相同点：</p>
<ol>
<li><strong>目标</strong>：两者都是为了减少不必要的DOM操作，提高性能。它们都通过比较新旧虚拟DOM（VNode或ReactElement）的差异，然后只更新真正需要改变的部分。</li>
<li><strong>虚拟DOM</strong>：Vue和React都使用了虚拟DOM（VNode或ReactElement）作为真实DOM的抽象表示。这使得它们可以在不直接操作真实DOM的情况下进行高效的DOM操作模拟。</li>
<li><strong>同级比较</strong>：两者的diff算法都只会在同层级进行比较，不会跨层级比较。这是因为跨层级比较不仅复杂度高，而且在实际应用中很少发生。</li>
</ol>
<p>不同点：</p>
<ol>
<li><strong>比较策略</strong>：<ul>
<li>Vue：Vue的diff算法主要使用了双端比较的策略。它会从新旧VNode的头部和尾部开始比较，然后逐渐向中间靠拢。同时，Vue也会使用一些优化策略，如静态节点提升和事件监听器的优化。</li>
<li>React：React的diff算法则主要使用了深度优先遍历的策略。它会逐层比较新旧ReactElement的子节点，直到找到需要更新的部分。React还使用了独特的key属性来标识列表中的每个子节点，以便更准确地识别哪些节点可以复用。</li>
</ul>
</li>
<li><strong>优化策略</strong>：<ul>
<li>Vue：Vue在diff过程中使用了许多优化策略，如静态节点提升、静态子树提升和事件监听器的优化。这些策略使得Vue在处理复杂组件和列表时更加高效。</li>
<li>React：React的diff算法主要使用了ReactElement的type和key属性来进行优化。当ReactElement的type和key都相同时，React会尽可能地复用已有的DOM节点。此外，React还使用了shouldComponentUpdate生命周期方法和React.memo高阶组件来进一步减少不必要的渲染。</li>
</ul>
</li>
<li><strong>列表处理</strong>：<ul>
<li>Vue：Vue在处理列表时，如果列表项没有使用唯一的key属性，可能会导致性能问题。因为Vue会使用一种“就地复用”的策略来复用列表项，这可能会导致一些意外的副作用。</li>
<li>React：React在处理列表时，强烈推荐使用唯一的key属性来标识每个列表项。这使得React能够更准确地识别哪些节点可以复用，哪些节点需要移动或删除。因此，React的列表渲染性能通常优于Vue。</li>
</ul>
</li>
<li><strong>补丁过程</strong>：<ul>
<li>Vue：Vue在diff过程中会生成一个描述差异的“补丁”（patch）。然后，Vue会根据这个补丁来更新真实的DOM树。Vue的补丁过程相对简单直接，主要涉及到节点的增删改操作。</li>
<li>React：React的diff算法在找到需要更新的部分后，会直接调用React的Reconciliation（协调）算法来更新真实的DOM树。这个过程相对复杂一些，因为它需要处理更多的边界情况和优化策略。但是，React的Reconciliation算法也非常高效和可靠，能够确保DOM更新的正确性和性能。</li>
</ul>
</li>
</ol>
<h4 id="举例介绍一下双端比较算法"><a href="#举例介绍一下双端比较算法" class="headerlink" title="举例介绍一下双端比较算法"></a>举例介绍一下双端比较算法</h4><p>双端比较算法（也称为双端Diff算法）是一种在数据结构中用于比较两个序列并找出它们之间差异的算法。在Vue等前端框架中，双端比较算法被用于虚拟DOM和实际DOM之间的比较和更新。</p>
<p>双端比较算法的工作原理是同时从两个序列的起始位置和结束位置开始比较，向中间移动，逐个比较元素，找出不同之处。这种算法相较于单向比较（即只从起始位置开始逐个比较元素）的优势在于，它可以更全面地考虑匹配情况，通过跳过相同的前缀和后缀部分，减少比较的次数，提高算法的效率。</p>
<p>以下是一个简单的双端比较算法的示例：</p>
<p>假设我们有两个列表，旧列表（oldList）和新列表（newList）。我们想要找出这两个列表之间的差异，并尽可能复用相同的元素。</p>
<ol>
<li><strong>初始化指针</strong>：我们初始化四个指针，分别指向旧列表和新列表的起始位置和结束位置。<ul>
<li>oldStart：指向旧列表的起始位置。</li>
<li>oldEnd：指向旧列表的结束位置。</li>
<li>newStart：指向新列表的起始位置。</li>
<li>newEnd：指向新列表的结束位置。</li>
</ul>
</li>
<li><strong>从两端开始比较</strong>：<ul>
<li>首先，我们比较oldStart和newStart指向的元素，看它们是否相同。如果相同，我们可以认为这两个元素没有变化，不需要进行任何操作，然后将oldStart和newStart都向内移动一位。</li>
<li>接着，我们比较oldEnd和newEnd指向的元素，同样看它们是否相同。如果相同，我们同样不需要进行任何操作，将oldEnd和newEnd都向内移动一位。</li>
<li>如果oldStart和newStart指向的元素不相同，但oldEnd和newEnd指向的元素相同，那么我们可以考虑将oldEnd指向的元素移动到oldStart的位置（如果可能的话），然后更新相应的引用和索引。</li>
<li>如果上述比较都没有找到相同的元素，我们可以继续向中间移动指针，并逐个比较元素。</li>
</ul>
</li>
<li><strong>递归或迭代处理</strong>：在比较过程中，如果发现某个子列表发生了变化（即新增、删除或修改了元素），我们可以递归或迭代地对该子列表应用双端比较算法，以找出更详细的差异。</li>
<li><strong>生成差异补丁</strong>：最后，根据比较结果生成一个描述差异的“补丁”（patch）。这个补丁包含了需要执行的DOM操作，如节点的增删改等。然后，我们可以根据这个补丁来更新实际的DOM树。</li>
</ol>
<p>通过双端比较算法，我们可以更高效地找出两个列表之间的差异，并尽可能复用相同的元素，从而提高页面的渲染性能和用户体验。</p>
<h4 id="举例介绍一下最长递增子序列算法"><a href="#举例介绍一下最长递增子序列算法" class="headerlink" title="举例介绍一下最长递增子序列算法"></a>举例介绍一下最长递增子序列算法</h4><p>最长递增子序列（Longest Increasing Subsequence，简称LIS）算法是计算机科学中的一个经典算法，用于在一个给定的序列中找出最长递增子序列的长度。下面我将通过一个具体的例子来介绍这个算法。</p>
<p>假设我们有一个序列 <code>&#123; 3, 5, 7, 1, 2, 8 &#125;</code>，我们需要找出这个序列的最长递增子序列。</p>
<ol>
<li><strong>初始化</strong>：<ul>
<li>创建一个与原始序列相同长度的数组 <code>dp</code>，其中 <code>dp[i]</code> 表示以原始序列中第 <code>i</code> 个元素结尾的最长递增子序列的长度。</li>
<li>初始化 <code>dp</code> 数组的所有元素为 1，因为每个元素本身都可以作为一个长度为 1 的递增子序列。</li>
</ul>
</li>
<li><strong>动态规划</strong>：<ul>
<li>从左到右遍历原始序列。对于每个元素 <code>nums[i]</code>，再遍历它之前的所有元素 <code>nums[j]</code>（其中 <code>j &lt; i</code>）。</li>
<li>如果 <code>nums[i]</code> 大于 <code>nums[j]</code>，那么说明我们可以将 <code>nums[i]</code> 添加到以 <code>nums[j]</code> 结尾的递增子序列的末尾，从而得到一个更长的递增子序列。</li>
<li>更新 <code>dp[i]</code> 为 <code>dp[j] + 1</code> 和之前 <code>dp[i]</code> 的值中的较大者，以确保 <code>dp[i]</code> 总是表示以 <code>nums[i]</code> 结尾的最长递增子序列的长度。</li>
</ul>
</li>
<li><strong>找出最长递增子序列的长度</strong>：<ul>
<li>在遍历完整个序列后，<code>dp</code> 数组中的最大值就是最长递增子序列的长度。</li>
<li>在这个例子中，<code>dp</code> 数组的值将会是 <code>&#123;1, 2, 3, 1, 2, 4&#125;</code>，所以最长递增子序列的长度是 4。</li>
</ul>
</li>
<li><strong>构造最长递增子序列</strong>（可选）：<ul>
<li>如果需要找出具体的最长递增子序列，可以在动态规划的过程中记录每个位置的最长递增子序列的前一个元素的位置。</li>
<li>从最长递增子序列的最后一个元素开始，根据记录的位置信息向前追溯，直到追溯到第一个元素，从而构造出整个最长递增子序列。</li>
<li>在这个例子中，最长递增子序列是 <code>&#123;3, 5, 7, 8&#125;</code>。</li>
</ul>
</li>
</ol>
<p>这就是最长递增子序列算法的基本思想和实现过程。通过动态规划的思想，我们可以在时间复杂度为 O(n^2) 的情况下解决这个问题。</p>
<h4 id="Vue-中-key-的作用"><a href="#Vue-中-key-的作用" class="headerlink" title="Vue 中 key 的作用"></a>Vue 中 key 的作用</h4><p>在Vue中，key是用于识别VNode（虚拟DOM节点）的特殊属性。它的作用主要有以下几个方面：</p>
<blockquote>
<ol>
<li>提供唯一标识：每个VNode都应该具有唯一的key值，用于在diff算法中准确地识别VNode节点的变化。通过key，Vue可以精确地判断哪些VNode是新增的、哪些是删除的，从而最小化DOM操作，提高页面更新的效率。</li>
<li>优化列表渲染：当使用v-for指令进行列表渲染时，每个列表项都应该提供一个唯一的key值。这样，Vue可以基于key的变化来确定列表项的新增、删除、移动等操作，从而避免重新渲染整个列表，提高列表渲染的性能。</li>
<li>维持组件状态：当使用key在动态组件或条件渲染中切换组件时，key的变化可以强制Vue销毁旧组件并创建新组件。这样做可以保持组件的状态和避免重用旧组件的状态，确保组件能够正确地更新和重新渲染。</li>
</ol>
</blockquote>
<p>​    需要注意的是，key的值应该是稳定且唯一的。在使用v-for渲染列表时，推荐使用具有唯一性的属性值作为key，如ID或其他唯一标识符。避免使用索引作为key，因为索引在列表发生变化时可能会导致错误的渲染结果。</p>
<p>​    Vue中的key属性用于唯一标识VNode，它在diff算法中起着重要的作用，能够提高页面更新的效率、优化列表渲染，并维持组件的状态。合理使用key可以确保Vue能够准确地识别和处理VNode的变化，提供更好的性能和用户体验。</p>
<h3 id="Vue2-与-Vue3的区别"><a href="#Vue2-与-Vue3的区别" class="headerlink" title="Vue2 与 Vue3的区别"></a>Vue2 与 Vue3的区别</h3><h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><blockquote>
<ul>
<li>Vue2：Vue2的生命周期包括beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed等钩子函数。这些钩子函数允许我们在组件的不同生命周期阶段执行特定的操作，例如在created钩子函数中进行数据初始化，在mounted钩子函数中操作DOM元素等。</li>
<li>Vue3：Vue3保留了大部分Vue2的生命周期钩子函数，但也引入了新的钩子函数如setup。setup钩子函数用于代替Vue2中的beforeCreate和created钩子函数，它提供了更灵活的组合式函数编程方式，可以更好地封装组件逻辑和复用代码。</li>
</ul>
</blockquote>
<h4 id="Diff算法："><a href="#Diff算法：" class="headerlink" title="Diff算法："></a>Diff算法：</h4><blockquote>
<ul>
<li>Vue2：Vue2使用基于虚拟DOM的Diff算法来计算需要更新的最小操作，然后将这些操作应用于真实的DOM树。Vue2的Diff算法会比较新旧虚拟DOM树的差异，然后只对差异部分进行更新，以减少不必要的DOM操作，提高性能和渲染效率。</li>
<li>Vue3：Vue3在Diff算法方面进行了优化。首先，Vue3使用了基于Proxy的响应式系统，通过代理对象来监听数据的变化，从而减少了对getter和setter的劫持，提升了性能。其次，Vue3引入了静态标记，即在编译阶段对模板进行静态分析，标记出静态节点，从而避免在Diff算法中对这些静态节点进行比较，进一步提高了性能和渲染效率。</li>
</ul>
</blockquote>
<h4 id="数据响应式原理："><a href="#数据响应式原理：" class="headerlink" title="数据响应式原理："></a>数据响应式原理：</h4><blockquote>
<ul>
<li>Vue2：Vue2使用Object.defineProperty实现数据的响应式。当数据被访问或修改时，Vue2通过劫持数据的get和set方法来追踪数据的变化。这样一来，当数据发生变化时，Vue2能够检测到变化并通知相关的组件进行更新。</li>
<li>Vue3：Vue3使用Proxy对象实现数据的响应式。Proxy对象可以代理目标对象并拦截对目标对象的访问和修改操作。通过代理对象的监听和触发机制，Vue3能够实时地追踪数据的变化，并触发相应的更新操作，从而实现数据响应式。</li>
</ul>
</blockquote>
<h4 id="组件通讯："><a href="#组件通讯：" class="headerlink" title="组件通讯："></a>组件通讯：</h4><blockquote>
<ul>
<li>Vue2：Vue2中组件通讯主要通过props和$emit进行父子组件之间的通讯。父组件通过props将数据传递给子组件，子组件通过$emit触发自定义事件来通知父组件。此外，Vue2还提供了事件总线、Vuex等方式来实现非父子组件之间的通讯。</li>
<li>Vue3：Vue3保留了Vue2的组件通讯方式，即父子组件之间通过props和emit进行通讯。而与Vue2不同的是，Vue3引入了Composition API，提供了更灵活的组合式函数编程方式来处理组件之间的通讯。通过使用Composition API中的响应式函数、上下文传递等特性，我们可以更方便地在组件之间共享状态和方法。</li>
</ul>
</blockquote>
<h4 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h4><p>​    Composition API 是 Vue 3 中引入的一种新的 API 风格，用于编写组件的逻辑和复用代码。它是一种基于函数的 API，与 Vue 2 中的选项式 API（Options API）相比，Composition API 更加灵活、组合性更强，能够更好地组织和管理组件的代码。</p>
<p>​    使用 Composition API，我们可以将一个组件的相关逻辑聚合在一起，而不是按照选项的顺序分散在不同的生命周期钩子函数中。这使得组件的逻辑更加清晰、可读性更高，同时也方便代码的复用和测试。</p>
<p>​    Composition API 提供了一系列的函数和响应式的 API，例如 <code>setup</code> 函数、<code>ref</code>、<code>reactive</code>、<code>watch</code> 等，用于定义组件的状态和行为。下面是 Composition API 的一些特点和用法：</p>
<blockquote>
<ol>
<li><code>setup</code> 函数：在组件中使用 <code>setup</code> 函数来定义组件的状态和行为。<code>setup</code> 函数在组件创建之前执行，可以访问组件的 props 和 context，并返回一个对象，这个对象中的属性和方法将被暴露给组件的模板部分使用。</li>
<li><code>ref</code> 和 <code>reactive</code>：<code>ref</code> 和 <code>reactive</code> 是用于创建响应式数据的 API。<code>ref</code> 用于创建一个单一的响应式数据，而 <code>reactive</code> 用于创建一个包含多个属性的响应式对象。</li>
<li><code>watch</code>：<code>watch</code> 函数用于监听响应式数据的变化，并在数据变化时执行相应的操作。它可以监听单个数据或多个数据，还可以设置深度监听、异步监听等。</li>
<li>生命周期钩子函数：在 Composition API 中，生命周期钩子函数的命名发生了变化，例如 <code>beforeCreate</code> 和 <code>created</code> 改为了 <code>onBeforeMount</code> 和 <code>onMounted</code>。这些钩子函数可以在 <code>setup</code> 函数中使用，与其他逻辑代码一起组合。</li>
<li>自定义函数：在 Composition API 中，我们可以自定义函数来封装和复用一些逻辑代码，而不必依赖于特定的生命周期钩子函数。</li>
</ol>
</blockquote>
<p>​    使用 Composition API，我们能够更好地组织组件的代码，提高代码的可读性和维护性。它适用于编写中小型到大型复杂组件，并且提供了更好的代码复用和测试能力。</p>
<p>​    Vue3在许多其他方面也进行了改进和优化，如编译优化、TypeScript支持、组合式API等。开发者在选择Vue版本时，需要根据项目需求和实际情况综合考虑，以及考虑迁移成本和团队熟悉度等因素。</p>
<h4 id="vue2以及vue3的diff算法有了解吗-他们之间的不同是什么"><a href="#vue2以及vue3的diff算法有了解吗-他们之间的不同是什么" class="headerlink" title="vue2以及vue3的diff算法有了解吗 他们之间的不同是什么"></a>vue2以及vue3的diff算法有了解吗 他们之间的不同是什么</h4><p>Vue.js的diff算法是其用于比较新旧虚拟DOM树并确定最小更新集的核心机制。Vue 2和Vue 3的diff算法在设计和实现上有一些重要的不同。</p>
<p><strong>Vue 2的diff算法</strong></p>
<p>Vue 2的diff算法主要关注于组件级别的更新，而不是细粒度的DOM节点级别的比较。以下是Vue 2 diff算法的一些关键点：</p>
<ol>
<li><strong>同级比较</strong>：Vue 2的diff算法只比较同一层级的节点，不跨层级比较。</li>
<li><strong>双端比较</strong>：当列表更新时，Vue 2会采用双端比较的策略，从列表的头部和尾部开始比较，然后逐渐向中心逼近，以尽量减少节点的移动次数。</li>
<li><strong>更新策略</strong>：当无法通过头尾比较找到匹配的节点时，Vue 2会尝试复用旧节点，通过更新节点的属性或子节点来匹配新的虚拟节点，并将其移动到正确的位置。</li>
</ol>
<p>然而，Vue 2的diff算法也存在一些限制，例如它不会进行跨层级的节点比较，这可能导致一些不必要的DOM操作。</p>
<p><strong>Vue 3的diff算法</strong></p>
<p>Vue 3对diff算法进行了重大改进，以进一步提高性能并减少不必要的DOM操作。以下是Vue 3 diff算法的一些主要变化：</p>
<ol>
<li><strong>基于Proxy的响应式系统</strong>：Vue 3使用了基于Proxy的响应式系统，能够更精确地追踪数据变化，从而减少了不必要的计算和渲染。这使得diff算法在比较新旧虚拟DOM树时能够更准确地确定需要更新的部分。</li>
<li><strong>静态提升</strong>：Vue 3在编译阶段会对模板进行静态分析，将不会改变的静态节点提升到渲染函数之外。这样，在每次渲染时，这些静态节点就不会被重新创建和比较，从而减少了不必要的计算和DOM操作。</li>
<li><strong>块级更新</strong>：Vue 3引入了块级更新的概念，将组件树拆分为多个块，每个块都拥有自己的渲染函数和依赖关系。当某个块的数据发生变化时，只有该块及其子块会被重新渲染和比较，而不是整个组件树。这进一步减少了不必要的计算和DOM操作。</li>
<li><strong>事件监听器的优化</strong>：Vue 3对事件监听器进行了优化，使用了一种称为“事件委托”的技术来减少事件监听器的数量。这样，当事件触发时，Vue 3可以更快地找到并处理相应的事件监听器，从而提高了性能。</li>
</ol>
<p>总的来说，Vue 3的diff算法通过更精确的追踪数据变化、静态提升、块级更新和事件监听器的优化等手段，进一步提高了Vue应用的渲染性能和用户体验。</p>
<h4 id="Vue3相对于Vue2进行了哪些优化？"><a href="#Vue3相对于Vue2进行了哪些优化？" class="headerlink" title="Vue3相对于Vue2进行了哪些优化？"></a>Vue3相对于Vue2进行了哪些优化？</h4><ol>
<li><strong>更灵活的响应式系统</strong>：Vue 2.x 中响应式系统的核心是 <strong>Object.defineProperty</strong>，劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式。Vue 3.x 中使用 <strong>Proxy</strong>对象重写响应式系统。</li>
<li><strong>更快的渲染速度</strong>：Vue3 的编译器生成的渲染函数比 Vue2 生成的更高效。</li>
<li><strong>编译阶段</strong>：Vue 2.x 通过标记静态节点，优化 diff 的过程。Vue 3.x中<strong>标记和提升</strong>所有的静态节点，diff的时候<strong>只需要对比动态节点</strong>内容。</li>
<li><strong>更小的体积</strong>：Vue3 将源码拆分为多个独立的模块，这样就可以按需导入所需的模块，从而减小了整个库的体积。</li>
<li><strong>更好的 TypeScript 支持</strong>：Vue3 对 TypeScript 的支持更加友好，内部使用了更先进的 TypeScript 特性，并为其提供了更好的声明文件。</li>
<li><strong>更好的组件系统</strong>：比如，Vue3中引入了一个新的 <code>Fragment</code> 组件，它可以替代原来的 <code>template</code> 标签作为根节点</li>
<li><strong>新增了setup组合式API</strong></li>
</ol>
<h3 id="路由-vue-router"><a href="#路由-vue-router" class="headerlink" title="路由 - vue-router"></a>路由 - vue-router</h3><h4 id="vue-router-中常用的路由模式实现原理吗"><a href="#vue-router-中常用的路由模式实现原理吗" class="headerlink" title="vue-router 中常用的路由模式实现原理吗"></a>vue-router 中常用的路由模式实现原理吗</h4><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a><strong>hash 模式</strong></h5><ol>
<li>location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li>
<li>可以为 hash 的改变添加监听事件</li>
</ol>
<pre class=" language-javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"hashchange"</span><span class="token punctuation">,</span> funcRef<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了</p>
<blockquote>
<p>特点：兼容性好但是不美观</p>
</blockquote>
<h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a><strong>history 模式</strong></h5><p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p>
<p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p>
<blockquote>
<p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p>
</blockquote>
<h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h4><p>路由守卫是在路由导航过程中进行拦截和控制的功能。</p>
<p>Vue Router 提供了以下几种类型的路由守卫：</p>
<blockquote>
<ol>
<li>全局前置守卫（Global Before Guards）：<ul>
<li><code>beforeEach(to, from, next)</code>：在每个路由跳转之前调用，可以用来进行全局的前置验证或处理逻辑。</li>
</ul>
</li>
<li>路由独享的守卫（Per-Route Guards）：<ul>
<li><code>beforeEnter(to, from, next)</code>：在某个特定路由配置中定义的守卫，只会对该路由生效。</li>
</ul>
</li>
<li>组件内的守卫（In-Component Guards）：<ul>
<li><code>beforeRouteEnter(to, from, next)</code>：在进入路由对应的组件之前调用，可以访问组件实例，但此时组件实例还没有被创建。</li>
<li><code>beforeRouteUpdate(to, from, next)</code>：在当前路由组件复用时调用，例如在同一路由下切换不同的参数。</li>
<li><code>beforeRouteLeave(to, from, next)</code>：在离开当前路由组件时调用，可以阻止离开或在离开前进行一些处理。</li>
</ul>
</li>
</ol>
</blockquote>
<p>这些守卫函数接收三个参数：</p>
<ul>
<li><code>to</code>：即将进入的目标路由对象</li>
<li><code>from</code>：当前导航正要离开的路由对象</li>
<li><code>next</code>：函数，用于进入下一个守卫或确认导航</li>
</ul>
<p>在守卫函数中，可以通过调用 <code>next()</code> 方法来进行导航控制：</p>
<ul>
<li>调用 <code>next()</code> 进行正常导航</li>
<li>调用 <code>next(false)</code> 中止当前导航</li>
<li>调用 <code>next(&#39;/path&#39;)</code> 或 <code>next(&#123; path: &#39;/path&#39; &#125;)</code> 进行重定向导航</li>
</ul>
<p>使用路由守卫可以实现诸如登录验证、权限控制、页面访问限制等功能，提供了灵活且强大的路由导航控制机制。</p>
<p> <a target="_blank" rel="noopener" href="https://router.vuejs.org/guide/advanced/navigation-guards.html">Vue Router 的官方文档</a></p>
<h4 id="Vue-router中如何实现懒加载？"><a href="#Vue-router中如何实现懒加载？" class="headerlink" title="Vue-router中如何实现懒加载？"></a>Vue-router中如何实现懒加载？</h4><p>在 Vue-router 中实现懒加载（也称为代码分割或异步组件）主要通过动态 <code>import()</code> 语法来完成。这种语法允许你只在需要时才加载和执行 JavaScript 模块。当使用 Vue-router 配置路由时，你可以将组件定义为一个返回 Promise 的函数，该函数内部使用 <code>import()</code> 来异步加载组件。</p>
<p>下面是一个 Vue-router 中实现懒加载的示例：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>  
<span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span>  
  
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span>  
  
<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  
  <span class="token punctuation">{</span>  
    path<span class="token punctuation">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span>  
    name<span class="token punctuation">:</span> <span class="token string">'Home'</span><span class="token punctuation">,</span>  
    <span class="token comment" spellcheck="true">// 使用动态 import 语法来懒加载 Home 组件  </span>
    component<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/Home.vue'</span><span class="token punctuation">)</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token punctuation">{</span>  
    path<span class="token punctuation">:</span> <span class="token string">'/about'</span><span class="token punctuation">,</span>  
    name<span class="token punctuation">:</span> <span class="token string">'About'</span><span class="token punctuation">,</span>  
    <span class="token comment" spellcheck="true">// 使用动态 import 语法来懒加载 About 组件  </span>
    component<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/About.vue'</span><span class="token punctuation">)</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token comment" spellcheck="true">// ... 其他路由  </span>
<span class="token punctuation">]</span>  
  
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  routes <span class="token comment" spellcheck="true">// （缩写）相当于 routes: routes  </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
  
<span class="token keyword">export</span> <span class="token keyword">default</span> router
</code></pre>
<p>在这个例子中，<code>import(&#39;./views/Home.vue&#39;)</code> 和 <code>import(&#39;./views/About.vue&#39;)</code> 会被 Webpack（或其他模块打包器）解析，并生成单独的代码块。这些代码块只有在它们对应的路由被访问时才会被加载和执行。</p>
<p>此外，对于嵌套路由（子路由），你也可以在父路由组件中懒加载子路由的组件：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  
  <span class="token punctuation">{</span>  
    path<span class="token punctuation">:</span> <span class="token string">'/parent'</span><span class="token punctuation">,</span>  
    component<span class="token punctuation">:</span> ParentComponent<span class="token punctuation">,</span>  
    children<span class="token punctuation">:</span> <span class="token punctuation">[</span>  
      <span class="token punctuation">{</span>  
        path<span class="token punctuation">:</span> <span class="token string">'child'</span><span class="token punctuation">,</span>  
        component<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/ChildComponent.vue'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 懒加载子组件  </span>
      <span class="token punctuation">}</span>  
    <span class="token punctuation">]</span>  
  <span class="token punctuation">}</span>  
  <span class="token comment" spellcheck="true">// ... 其他路由  </span>
<span class="token punctuation">]</span>
</code></pre>
<p>通过这种方式，你可以将 Vue 应用程序拆分成多个更小的代码块，从而实现按需加载和更好的首屏加载性能。这对于大型单页面应用程序尤其有用，因为它们可能会包含很多不同的页面和组件。</p>
<h4 id="Vue-router中如何实现把组件按组分块？"><a href="#Vue-router中如何实现把组件按组分块？" class="headerlink" title="Vue-router中如何实现把组件按组分块？"></a>Vue-router中如何实现把组件按组分块？</h4><p>在 Vue.js 中，Vue Router 主要用于构建单页面应用程序 (SPA) 的路由系统。然而，将组件按组分块（通常指的是代码分割或懒加载）并不是 Vue Router 的直接功能，而是 Webpack、Rollup 或其他模块打包工具的功能。</p>
<p>不过，Vue Router 和 Webpack（或其他打包工具）可以很好地配合，以实现组件的懒加载或代码分割。</p>
<p>下面是一个使用 Webpack 和 Vue Router 实现组件懒加载的例子：</p>
<p>首先，确保你已经安装了 Vue Router 和 Vue。</p>
<p>然后，在你的 Vue Router 配置中，你可以使用动态导入（<code>import()</code>）语法来按需加载组件。例如：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>  
<span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span>  
  
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span>  
  
<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  
  <span class="token punctuation">{</span>  
    path<span class="token punctuation">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span>  
    name<span class="token punctuation">:</span> <span class="token string">'Home'</span><span class="token punctuation">,</span>  
    component<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/Home.vue'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 懒加载 Home 组件  </span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token punctuation">{</span>  
    path<span class="token punctuation">:</span> <span class="token string">'/about'</span><span class="token punctuation">,</span>  
    name<span class="token punctuation">:</span> <span class="token string">'About'</span><span class="token punctuation">,</span>  
    component<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/About.vue'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 懒加载 About 组件  </span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token comment" spellcheck="true">// 其他路由...  </span>
<span class="token punctuation">]</span>  
  
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  mode<span class="token punctuation">:</span> <span class="token string">'history'</span><span class="token punctuation">,</span>  
  base<span class="token punctuation">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>BASE_URL<span class="token punctuation">,</span>  
  routes  
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
  
<span class="token keyword">export</span> <span class="token keyword">default</span> router
</code></pre>
<p>在上述示例中，<code>component</code> 选项不再是一个直接的组件对象，而是一个返回 Promise 的函数。当路由被访问时，Webpack 会自动将相应的组件代码分割到一个新的 bundle 中，并仅在需要时加载它。</p>
<p>此外，如果你希望将多个组件或路由组合到一个“组”中，并一起进行懒加载，你可能需要创建一个更高层次的组件或布局，然后在该组件或布局中动态导入所需的子组件。例如：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 创建一个高层次的布局组件  </span>
<span class="token keyword">const</span> DashboardLayout <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./layouts/DashboardLayout.vue'</span><span class="token punctuation">)</span>  
  
<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  
  <span class="token punctuation">{</span>  
    path<span class="token punctuation">:</span> <span class="token string">'/dashboard'</span><span class="token punctuation">,</span>  
    name<span class="token punctuation">:</span> <span class="token string">'Dashboard'</span><span class="token punctuation">,</span>  
    component<span class="token punctuation">:</span> DashboardLayout<span class="token punctuation">,</span>  
    children<span class="token punctuation">:</span> <span class="token punctuation">[</span>  
      <span class="token punctuation">{</span>  
        path<span class="token punctuation">:</span> <span class="token string">'reports'</span><span class="token punctuation">,</span>  
        name<span class="token punctuation">:</span> <span class="token string">'Reports'</span><span class="token punctuation">,</span>  
        component<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/Dashboard/Reports.vue'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 懒加载 Reports 组件  </span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>  
      <span class="token punctuation">{</span>  
        path<span class="token punctuation">:</span> <span class="token string">'settings'</span><span class="token punctuation">,</span>  
        name<span class="token punctuation">:</span> <span class="token string">'Settings'</span><span class="token punctuation">,</span>  
        component<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./views/Dashboard/Settings.vue'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 懒加载 Settings 组件  </span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>  
      <span class="token comment" spellcheck="true">// 其他子路由...  </span>
    <span class="token punctuation">]</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token comment" spellcheck="true">// 其他路由...  </span>
<span class="token punctuation">]</span>
</code></pre>
<p>在这个例子中，<code>DashboardLayout</code> 是一个更高层次的布局组件，它包含了一些子路由（如 ‘Reports’ 和 ‘Settings’）。这些子路由的组件都是按需加载的。</p>
<h4 id="SPA与前端路由的关系"><a href="#SPA与前端路由的关系" class="headerlink" title="SPA与前端路由的关系"></a>SPA与前端路由的关系</h4><p>SPA（Single Page Application，单页面应用）与前端路由之间有着密切的关系。</p>
<p>SPA指的是一个web网站只有唯一的一个HTML页面，所有的组件和功能的展示与切换都在这唯一的一个页面内完成。由于整个应用只有一个页面，所以用户在使用SPA时，页面的整体框架不会发生变化，只是页面的局部内容会进行更新。</p>
<p>为了实现SPA中不同组件或功能之间的切换，就需要使用前端路由。前端路由主要负责监听URL地址栏中的变化，然后根据这些变化来渲染不同的组件或页面内容。在SPA中，当用户点击一个链接或触发某个事件时，前端路由会捕获到这个变化，然后根据路由配置找到对应的组件，并将其渲染到页面上，从而实现页面的局部更新。</p>
<p>因此，可以说SPA是前端路由的应用场景之一，而前端路由则是SPA实现不同功能之间切换的关键技术。通过使用前端路由，SPA可以在不刷新页面的情况下实现页面的局部更新和组件的切换，从而提供更好的用户体验和更快的页面加载速度。</p>
<h4 id="实现SPA单页面应用的核心原理"><a href="#实现SPA单页面应用的核心原理" class="headerlink" title="实现SPA单页面应用的核心原理"></a>实现SPA单页面应用的核心原理</h4><p>实现SPA（单页面应用）的核心原理主要包括以下几个方面：</p>
<ol>
<li>单页加载<ul>
<li>SPA在初始加载时只会加载一个HTML文件，通常是一个空白的主页面。所有的页面内容都通过AJAX或WebSocket等技术从服务器获取，并使用JavaScript将内容动态地插入到页面中，从而实现页面的更新。</li>
</ul>
</li>
<li>前端路由<ul>
<li>SPA使用前端路由来处理URL和页面之间的映射关系。通过监听浏览器URL的变化，SPA能够根据不同的URL加载相应的内容，而无需重新请求服务器。这使得用户在导航和浏览应用程序时无需刷新页面。</li>
</ul>
</li>
<li>数据驱动视图<ul>
<li>SPA采用了数据驱动的视图模型，通常使用MVVM（Model-View-ViewModel）或MVC（Model-View-Controller）的架构模式。当数据发生变化时，视图会自动更新，而无需重新加载页面。</li>
</ul>
</li>
<li>异步数据请求<ul>
<li>SPA应用通过Ajax或者WebSocket等技术与服务器进行异步通信，从服务器获取数据。当用户触发某个事件或者首次加载页面时，SPA应用会根据特定的请求参数发送请求，并将服务器响应的数据更新到页面中的相应位置。</li>
</ul>
</li>
<li>视图组件化<ul>
<li>SPA应用通常会将页面拆分成多个小的、可复用的组件。每个组件都负责渲染页面的一部分，并处理相关的交互逻辑。通过使用现代前端框架（如React、Angular、Vue.js）来构建这些组件，可以大大提高开发效率和代码的可维护性。</li>
</ul>
</li>
<li>状态管理<ul>
<li>在SPA中，由于页面不会重新加载，因此需要一种机制来管理组件之间的状态和数据共享。这通常通过状态管理库（如Redux、Vuex等）来实现。这些库提供了一种全局的、可预测的状态管理方案，使得组件之间的数据共享和通信变得更加简单和清晰。</li>
</ul>
</li>
</ol>
<p>通过以上核心原理，SPA能够实现在不刷新页面的情况下加载新的内容，提高用户体验和性能。同时，通过组件化和状态管理等技术，SPA也能够更好地支持复杂的前端应用开发和维护。</p>
<h4 id="SPA单页面应用，首屏加载有哪些优化方法？"><a href="#SPA单页面应用，首屏加载有哪些优化方法？" class="headerlink" title="SPA单页面应用，首屏加载有哪些优化方法？"></a>SPA单页面应用，首屏加载有哪些优化方法？</h4><p>SPA（单页面应用）的首屏加载优化是提高用户体验和页面性能的关键。以下是一些常见的SPA首屏加载优化方法：</p>
<ol>
<li>代码分割与懒加载<ul>
<li>使用Webpack等工具进行代码分割，将代码拆分成多个小的包，根据需求异步加载。</li>
<li>懒加载（Lazy Loading）或路由懒加载：只在需要时才加载相关组件或代码，避免一次性加载整个应用。</li>
</ul>
</li>
<li>使用CDN加速<ul>
<li>将静态资源（如JavaScript、CSS和图片）部署到CDN（内容分发网络）上，通过CDN的缓存和全球分布式节点加速资源的加载速度。</li>
</ul>
</li>
<li>压缩与优化资源<ul>
<li>使用压缩工具（如Terser、UglifyJS等）压缩JavaScript和CSS文件，减少文件大小。</li>
<li>对图片进行压缩和优化，使用更高效的图片格式（如WebP）代替传统的JPEG或PNG格式。</li>
<li>合并多个小图片为雪碧图（CSS Sprites），减少HTTP请求次数。</li>
</ul>
</li>
<li>优化HTTP请求<ul>
<li>减少HTTP请求次数，合并相关请求或使用HTTP/2的多路复用技术。</li>
<li>使用浏览器缓存，减少不必要的请求。</li>
<li>启用Gzip压缩，减少传输数据量。</li>
</ul>
</li>
<li>利用前端缓存<ul>
<li>利用浏览器缓存（如localStorage、sessionStorage、IndexedDB等）存储常用数据或计算结果，减少服务器请求。</li>
<li>使用缓存库（如Redux Persist）来缓存Redux状态，避免在页面重新加载时丢失数据。</li>
</ul>
</li>
<li>按需加载<ul>
<li>只加载当前页面所需的内容和资源，避免加载不必要的代码和数据。</li>
<li>使用动态导入（dynamic imports）来按需加载JavaScript模块。</li>
</ul>
</li>
<li>使用现代前端框架<ul>
<li>使用React、Vue.js、Angular等现代前端框架，它们提供了许多内置的性能优化机制，如虚拟DOM、数据绑定和组件生命周期等。</li>
</ul>
</li>
<li>服务端渲染（SSR）<ul>
<li>对于首屏加载，可以使用服务端渲染（SSR）技术来预渲染页面，然后在客户端接管渲染过程。这样可以加快首屏的加载速度，并提供更好的用户体验。</li>
</ul>
</li>
<li>性能监测与分析<ul>
<li>使用性能监测工具（如Lighthouse、WebPageTest等）对SPA进行性能监测和分析，找出性能瓶颈并进行优化。</li>
</ul>
</li>
<li>减少DOM操作<ul>
<li>尽量避免在首屏加载时进行复杂的DOM操作，以减少渲染时间和CPU占用。</li>
</ul>
</li>
</ol>
<p>通过结合以上优化方法，可以显著提高SPA的首屏加载性能，从而提升用户体验和页面性能。</p>
<h4 id="Vue-router中-route-和-router-的区别"><a href="#Vue-router中-route-和-router-的区别" class="headerlink" title="Vue-router中$route 和$router 的区别"></a>Vue-router中$route 和$router 的区别</h4><p>在 Vue.js 的 Vue-router 中，<code>$route</code> 和 <code>$router</code> 是两个常用的对象，它们各自扮演着不同的角色。</p>
<ol>
<li><p><strong>$route</strong>：</p>
<ul>
<li><p><code>$route</code> 是一个只读的路由信息对象，它包含了当前 URL 解析得到的信息，以及 URL 匹配到的路由记录（route records）。</p>
</li>
<li><p>它是一个局部的对象，每个路由都会有一个 <code>$route</code> 对象。</p>
</li>
<li><p>你可以通过</p>
<pre><code>$route
</code></pre>
<p>访问到当前路由的许多属性，如：</p>
<ul>
<li><code>$route.path</code>：字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。</li>
<li><code>$route.params</code>：一个 key/value 对象，包含了动态片段和全匹配片段的键值对。</li>
<li><code>$route.query</code>：一个 key/value 对象，表示 URL 查询参数。例如，对于路径 “/foo?user=1”，则有 <code>$route.query.user == 1</code>。</li>
<li><code>$route.name</code>：(当前路由的名字，如果有的话)</li>
<li><code>$route.hash</code>：(当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串)</li>
<li><code>$route.fullPath</code>：(完成解析后的 URL，包含查询参数和 hash 的完整路径)</li>
<li>等等。</li>
</ul>
</li>
<li><p><code>$route</code> 主要用于获取当前路由的信息，但它是只读的，你不能直接修改它。</p>
</li>
</ul>
</li>
<li><p><strong>$router</strong>：</p>
<ul>
<li><p><code>$router</code> 是 Vue-router 的实例对象，它包含了所有的路由配置和路由导航的方法。</p>
</li>
<li><p>它是一个全局的路由实例，任何页面都可以调用其方法。</p>
</li>
<li><pre><code>$router
</code></pre>
<p>提供了许多 API 来控制路由的跳转和导航，如：</p>
<ul>
<li><code>push(location, onComplete?, onAbort?)</code>：导航到不同的 URL。 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</li>
<li><code>replace(location, onComplete?, onAbort?)</code>：跟 <code>push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是替换掉当前的 history 记录。</li>
<li><code>go(n)</code>：在 history 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code>。</li>
<li>等等。</li>
</ul>
</li>
<li><p><code>$router</code> 主要用于进行路由操作，如跳转到指定的路由、前进、后退等。</p>
</li>
</ul>
</li>
</ol>
<p>总的来说，<code>$route</code> 和 <code>$router</code> 在 Vue-router 中各有其用，<code>$route</code> 用于获取当前路由的信息，而 <code>$router</code> 用于进行路由的操作和导航。</p>
<h4 id="Vue-router中路由传递参数以及跳转的方法有哪些"><a href="#Vue-router中路由传递参数以及跳转的方法有哪些" class="headerlink" title="Vue-router中路由传递参数以及跳转的方法有哪些"></a>Vue-router中路由传递参数以及跳转的方法有哪些</h4><p>在Vue-router中，路由传递参数以及跳转的方法有多种。以下是一些主要的方法：</p>
<p><strong>1. 通过 <code>&lt;router-link&gt;</code> 传递参数</strong></p>
<p>你可以直接在 <code>&lt;router-link&gt;</code> 组件的 <code>to</code> 属性中传递参数。这有两种方式：</p>
<ul>
<li>使用 <code>params</code> 传递参数：</li>
</ul>
<pre class=" language-html"><code class="language-html">html复制代码

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ name: <span class="token punctuation">'</span>user<span class="token punctuation">'</span>, params: { userId: 123 }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>User<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>
</code></pre>
<p>注意，这种方式需要在路由配置中声明对应的参数：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  
  path<span class="token punctuation">:</span> <span class="token string">'/user/:userId'</span><span class="token punctuation">,</span>  
  name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span>  
  component<span class="token punctuation">:</span> User  
<span class="token punctuation">}</span>
</code></pre>
<p>在目标组件中，你可以通过 <code>this.$route.params.userId</code> 来获取传递的参数。</p>
<ul>
<li>使用 <code>query</code> 传递参数：</li>
</ul>
<pre class=" language-html"><code class="language-html">html复制代码

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ path: <span class="token punctuation">'</span>user<span class="token punctuation">'</span>, query: { userId: 123 }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>User<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>
</code></pre>
<p>或者</p>
<pre class=" language-html"><code class="language-html">html复制代码

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ name: <span class="token punctuation">'</span>user<span class="token punctuation">'</span>, query: { userId: 123 }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>User<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>
</code></pre>
<p>在目标组件中，你可以通过 <code>this.$route.query.userId</code> 来获取传递的参数。这种方式的参数会显示在URL中，形如 <code>/user?userId=123</code>。</p>
<p><strong>2. 通过编程式导航（<code>this.$router.push</code>）传递参数</strong></p>
<p>与 <code>&lt;router-link&gt;</code> 类似，你也可以在 <code>this.$router.push</code> 方法中传递参数：</p>
<ul>
<li>使用 <code>params</code> 传递参数：</li>
</ul>
<pre class=" language-javascript"><code class="language-javascript">javascript复制代码

<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>注意，这种方式也需要在路由配置中声明对应的参数。</p>
<ul>
<li>使用 <code>query</code> 传递参数：</li>
</ul>
<pre class=" language-javascript"><code class="language-javascript">javascript复制代码

<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> query<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>或者</p>
<pre class=" language-javascript"><code class="language-javascript">javascript复制代码

<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> query<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>在目标组件中，获取参数的方式与 <code>&lt;router-link&gt;</code> 相同。</p>
<p><strong>3. 使用 <code>this.$router.replace</code> 替换当前路由</strong></p>
<p><code>this.$router.replace</code> 的用法与 <code>this.$router.push</code> 基本相同，唯一的区别是 <code>replace</code> 不会向历史记录中添加新条目，而是替换掉当前的条目。</p>
<p><strong>4. 使用 <code>this.$router.go(n)</code> 进行导航</strong></p>
<p><code>this.$router.go(n)</code> 方法会根据传入的整数 <code>n</code> 在历史记录中向前或向后跳转。例如，<code>this.$router.go(1)</code> 会向前跳转一个条目，而 <code>this.$router.go(-1)</code> 会向后跳转一个条目。</p>
<p>以上就是Vue-router中路由传递参数以及跳转的主要方法。</p>
<h4 id="Vue-router中的命名视图"><a href="#Vue-router中的命名视图" class="headerlink" title="Vue-router中的命名视图"></a>Vue-router中的命名视图</h4><p>Vue-router 中的命名视图（Named Views）允许你在同一个路由的渲染过程中使用多个组件。在常规的路由配置中，一个路由通常映射到一个组件，但是命名视图允许你定义一个路由对应多个组件，并在 <code>&lt;router-view&gt;</code> 中使用 <code>name</code> 属性来指定要渲染哪个组件。</p>
<p><strong>使用命名视图</strong></p>
<ol>
<li><p><strong>在路由配置中定义多个组件</strong>：<br>在路由配置中，你可以使用 <code>components</code>（注意是复数形式）而不是 <code>component</code>，并指定一个带有组件名称的对象。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>  
    <span class="token punctuation">{</span>  
      path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>  
      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
        <span class="token keyword">default</span><span class="token punctuation">:</span> Header<span class="token punctuation">,</span>  
        leftMenu<span class="token punctuation">:</span> Menu<span class="token punctuation">,</span>  
        rightContent<span class="token punctuation">:</span> Content  
      <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">]</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
</li>
<li><p>**在模板中使用 <code>&lt;router-view&gt;</code>**：<br>在模板中，你可以使用多个 <code>&lt;router-view&gt;</code> 标签，并使用 <code>name</code> 属性来指定要渲染哪个组件。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 渲染 default 组件 --></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>leftMenu<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 渲染 leftMenu 组件 --></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rightContent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 渲染 rightContent 组件 --></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
</code></pre>
<p>如果没有为 <code>&lt;router-view&gt;</code> 指定 <code>name</code> 属性，则默认渲染 <code>default</code> 组件。</p>
</li>
</ol>
<p><strong>注意事项</strong></p>
<ul>
<li>命名视图允许你在同一个路由中渲染多个组件，但它们并不是嵌套的，而是同级展示。</li>
<li>在路由配置中，你需要使用 <code>components</code> 而不是 <code>component</code>，并以键值对的形式来指定每个组件。</li>
<li>在模板中，你可以使用多个 <code>&lt;router-view&gt;</code> 标签，并通过 <code>name</code> 属性来指定要渲染的组件。</li>
</ul>
<p>命名视图在需要同时展示多个组件的复杂布局中非常有用，比如一个包含侧边栏和主内容的页面。通过使用命名视图，你可以更加灵活地组织你的组件和路由。</p>
<h4 id="Vue-router中的嵌套路由"><a href="#Vue-router中的嵌套路由" class="headerlink" title="Vue-router中的嵌套路由"></a>Vue-router中的嵌套路由</h4><p>Vue-router中的嵌套路由是指通过路由实现组件的嵌套展示，主要由页面结构决定。在实际项目中，应用界面通常由多层嵌套的组件组合而成，为了使这些多层嵌套的组件能够通过路由访问，路由也需要具有嵌套关系，即在路由里面嵌套它的子路由。</p>
<p>在Vue Router中，你可以通过在路由配置中嵌套路由对象来定义嵌套路由。每个嵌套的路由对象都会被关联到一个父级路由的组件中。</p>
<p>以下是嵌套路由的基本配置语法（以Vue Router 3为例）：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>  
    <span class="token punctuation">{</span>  
      path<span class="token punctuation">:</span> <span class="token string">'/parent'</span><span class="token punctuation">,</span>  
      component<span class="token punctuation">:</span> ParentComponent<span class="token punctuation">,</span>  
      children<span class="token punctuation">:</span> <span class="token punctuation">[</span>  
        <span class="token punctuation">{</span>  
          <span class="token comment" spellcheck="true">// 当 /parent/child 被匹配时  </span>
          <span class="token comment" spellcheck="true">// ChildComponent 将会被渲染在 ParentComponent 的 &lt;router-view> 中  </span>
          path<span class="token punctuation">:</span> <span class="token string">'child'</span><span class="token punctuation">,</span>  
          component<span class="token punctuation">:</span> ChildComponent  
        <span class="token punctuation">}</span><span class="token punctuation">,</span>  
        <span class="token comment" spellcheck="true">// 你可以继续嵌套下去...  </span>
      <span class="token punctuation">]</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">]</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>在上述代码中，<code>/parent/child</code> 路由对应的组件 <code>ChildComponent</code> 将会嵌套在 <code>/parent</code> 路由对应的组件 <code>ParentComponent</code> 中。在 <code>ParentComponent</code> 的模板中，你需要使用 <code>&lt;router-view&gt;</code> 来渲染子路由对应的组件。</p>
<p>需要注意的是，在定义子路由的 <code>path</code> 属性时，不需要添加 <code>/</code> 前缀，因为子路由的 <code>path</code> 是相对于其父路由的 <code>path</code> 的。</p>
<p>另外，嵌套路由的匹配是按照顺序进行的，所以你需要确保父路由的匹配规则在子路由之前。如果父路由的匹配规则在子路由之后，那么当访问子路由时，父路由的匹配规则也会被执行，这可能会导致一些不期望的结果。</p>
<p>总之，Vue-router中的嵌套路由是一种非常强大的功能，它允许你根据页面结构来组织路由和组件，从而构建出更加复杂和灵活的应用界面。</p>
<h4 id="Vue-router中的路由重定向和404"><a href="#Vue-router中的路由重定向和404" class="headerlink" title="Vue-router中的路由重定向和404"></a>Vue-router中的路由重定向和404</h4><p>在Vue Router中，路由重定向和404页面处理是常见的功能需求。以下是关于如何在Vue Router中实现路由重定向和404页面处理的方法：</p>
<p><strong>路由重定向</strong></p>
<p>Vue Router支持通过<code>redirect</code>字段进行基本的重定向配置。你可以将某个路径重定向到另一个路径，从而实现页面的跳转。</p>
<ol>
<li><strong>基本重定向</strong>：</li>
</ol>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  
  <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token string">'/'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token comment" spellcheck="true">// 其他路由配置...  </span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<p>在上述示例中，当用户访问<code>/home</code>路径时，将会被重定向到根路径<code>/</code>。</p>
<ol>
<li><strong>动态重定向</strong>：</li>
</ol>
<p>Vue Router还支持通过函数返回值来动态配置重定向。这样你可以根据一定的条件来决定重定向的目标路径。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  
  <span class="token punctuation">{</span>  
    path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span>  
    redirect<span class="token punctuation">:</span> to <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  
      <span class="token comment" spellcheck="true">// 如果id为'admin'，则重定向到'/admin'；否则重定向到'/user'  </span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id <span class="token operator">===</span> <span class="token string">'admin'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token string">'/admin'</span><span class="token punctuation">;</span>  
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> <span class="token string">'/user'</span><span class="token punctuation">;</span>  
      <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token comment" spellcheck="true">// 其他路由配置...  </span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>404页面处理</strong></p>
<p>当用户在浏览器中访问一个不存在的路由时，Vue Router不会默认提供404页面。但是，你可以通过配置一个通配符路由来实现404页面处理。</p>
<ol>
<li><strong>配置通配符路由</strong>：</li>
</ol>
<p>在路由配置中添加一个通配符路由（例如<code>&#123; path: &#39;*&#39;, component: NotFoundComponent &#125;</code>），当其他路由都无法匹配时，这个通配符路由将被匹配，并渲染相应的组件（NotFoundComponent）。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  
  <span class="token comment" spellcheck="true">// 其他路由配置...  </span>
  <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> NotFoundComponent <span class="token punctuation">}</span><span class="token punctuation">,</span>  
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<p>在上面的示例中，NotFoundComponent是你定义的404页面组件。</p>
<ol>
<li><strong>服务器配置</strong>：</li>
</ol>
<p>如果你的项目部署在服务器上，并且使用了Vue Router的history模式（而不是默认的hash模式），那么你还需要在服务器上配置相应的路由规则。具体来说，你可以将所有未知的路由都指向同一个入口文件（例如index.html），然后由Vue Router来处理相应的路由逻辑。这样，当在浏览器中刷新页面时，服务器会返回index.html，并由Vue Router来处理相应的路由逻辑。</p>
<p>请注意，以上方法仅适用于前端路由处理。如果你的项目需要后端也处理路由逻辑（例如使用SSR或Nuxt.js等框架），你可能需要在后端也进行相应的配置。</p>
<h3 id="Vue生态"><a href="#Vue生态" class="headerlink" title="Vue生态"></a>Vue生态</h3><h4 id="Vue项目中如何二次封装axios？"><a href="#Vue项目中如何二次封装axios？" class="headerlink" title="Vue项目中如何二次封装axios？"></a>Vue项目中如何二次封装axios？</h4><p>在Vue项目中，二次封装axios可以帮助我们更好地管理请求和响应，例如添加全局的请求头、错误处理、请求拦截、响应拦截等。以下是一个简单的步骤，说明如何二次封装axios：</p>
<ol>
<li><strong>安装axios</strong></li>
</ol>
<p>首先，你需要确保你的项目中已经安装了axios。如果还没有安装，你可以通过npm或yarn来安装：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> axios --save  
<span class="token comment" spellcheck="true"># 或者  </span>
yarn add axios
</code></pre>
<ol>
<li><strong>创建axios封装文件</strong></li>
</ol>
<p>在你的Vue项目中，通常会在<code>src/utils</code>或者<code>src/api</code>目录下创建一个新的文件，例如<code>http.js</code>或<code>axios.js</code>，用于封装axios。</p>
<ol>
<li><strong>引入axios并进行配置</strong></li>
</ol>
<p>在封装文件中，首先引入axios，并进行一些基本的配置，如baseURL、timeout等。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token punctuation">;</span>  
  
<span class="token keyword">const</span> service <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  baseURL<span class="token punctuation">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>VUE_APP_BASE_API<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// url = base url + request url  </span>
  <span class="token comment" spellcheck="true">// withCredentials: true, // send cookies when cross-domain requests  </span>
  timeout<span class="token punctuation">:</span> <span class="token number">5000</span> <span class="token comment" spellcheck="true">// request timeout  </span>
  <span class="token comment" spellcheck="true">// ... 其他配置项  </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>注意：<code>process.env.VUE_APP_BASE_API</code>是一个环境变量，你可以在你的<code>.env</code>文件中定义它，以便于在不同的环境中使用不同的API地址。</p>
<ol>
<li><strong>请求拦截</strong></li>
</ol>
<p>在发送请求之前，你可以添加一些拦截器，用于处理一些全局的逻辑，如添加请求头、修改请求数据等。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 请求拦截器  </span>
service<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>  
  config <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// 在发送请求之前做些什么  </span>
    <span class="token comment" spellcheck="true">// 例如添加请求头  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      config<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'Authorization'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Bearer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">return</span> config<span class="token punctuation">;</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// 对请求错误做些什么  </span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// for debug  </span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ol>
<li><strong>响应拦截</strong></li>
</ol>
<p>在收到响应之后，你也可以添加一些拦截器，用于处理一些全局的逻辑，如判断响应状态码、对响应数据进行处理等。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 响应拦截器  </span>
service<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>  
  response <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  
    <span class="token keyword">const</span> res <span class="token operator">=</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>  
    <span class="token comment" spellcheck="true">// 如果自定义的code不是20000，则判断为错误。  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>code <span class="token operator">!==</span> <span class="token number">20000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>message <span class="token operator">||</span> <span class="token string">'Error'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  
      <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'err'</span> <span class="token operator">+</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// for debug  </span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ol>
<li><strong>导出封装的axios</strong></li>
</ol>
<p>最后，你需要将封装好的axios导出，以便在其他地方使用。</p>
<pre class=" language-javascript"><code class="language-javascript">javascript复制代码

<span class="token keyword">export</span> <span class="token keyword">default</span> service<span class="token punctuation">;</span>
</code></pre>
<ol>
<li><strong>在Vue组件中使用</strong></li>
</ol>
<p>现在，你就可以在你的Vue组件中引入并使用这个封装好的axios了。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'@/utils/axios'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引入封装好的axios  </span>
  
axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/user/list'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>注意：这里的<code>@</code>符号是webpack的一个别名配置，通常指向<code>src</code>目录。如果你的项目中没有这样的配置，你需要使用完整的路径来引入axios。</p>
<h4 id="Axios的请求拦截和响应拦截底层实现原理是什么？"><a href="#Axios的请求拦截和响应拦截底层实现原理是什么？" class="headerlink" title="Axios的请求拦截和响应拦截底层实现原理是什么？"></a>Axios的请求拦截和响应拦截底层实现原理是什么？</h4><p>Axios的请求拦截和响应拦截的底层实现原理主要基于JavaScript的函数式编程和Promise的特性。以下是具体的实现原理：</p>
<ol>
<li><strong>拦截器数组</strong>：<ul>
<li>Axios内部维护了两个数组，一个用于存储请求拦截器，另一个用于存储响应拦截器。每个拦截器都是一个函数，这些函数按照它们在数组中定义的顺序被依次执行。</li>
</ul>
</li>
<li><strong>拦截器函数的参数</strong>：<ul>
<li><strong>请求拦截器</strong>：通常接收一个配置对象（通常是请求的配置）作为参数，并返回一个配置对象或Promise。</li>
<li><strong>响应拦截器</strong>：接收一个响应对象作为参数，并返回一个响应对象或Promise。</li>
</ul>
</li>
<li><strong>拦截器的执行</strong>：<ul>
<li><strong>请求拦截</strong>：当Axios发起一个请求时，它会首先遍历并执行请求拦截器数组中的每个函数。这些函数可以对请求进行预处理，比如添加请求头、处理错误等。处理后的请求配置会传递给下一个拦截器，直到所有的请求拦截器都执行完毕，然后才会真正发起HTTP请求。</li>
<li><strong>响应拦截</strong>：一旦请求被发送并得到响应，Axios会遍历并执行响应拦截器数组中的每个函数。这些函数可以对响应进行后处理，比如数据转换、错误处理等。处理后的响应对象会传递给下一个拦截器，直到所有的响应拦截器都执行完毕，然后才会将最终的响应结果返回给调用者。</li>
</ul>
</li>
<li><strong>Promise和异步处理</strong>：<ul>
<li>Axios使用Promise作为异步处理的基础。这使得拦截器的处理可以支持异步操作，比如从localStorage中读取token、发送异步验证请求等。如果拦截器函数返回的是一个Promise，那么Axios会等待这个Promise解析完毕后再继续执行后续的逻辑。</li>
</ul>
</li>
<li><strong>链式结构和顺序执行</strong>：<ul>
<li>Axios的拦截器是链式结构的，这意味着你可以同时使用多个拦截器，并且它们会按照添加的顺序依次执行。无论是请求拦截器还是响应拦截器，都会按照它们在数组中定义的顺序被依次执行。这种设计使得你可以灵活地组合不同的拦截器，以满足不同的需求。</li>
</ul>
</li>
</ol>
<p>总的来说，Axios的请求拦截和响应拦截底层实现原理主要依赖于JavaScript的函数式编程和Promise的特性，通过维护两个拦截器数组来实现对请求和响应的预处理和后处理。这种设计使得你可以更加灵活地控制和管理HTTP请求和响应的过程。</p>
<h4 id="Vue-cli中assets文件夹和static文件夹的区别"><a href="#Vue-cli中assets文件夹和static文件夹的区别" class="headerlink" title="Vue-cli中assets文件夹和static文件夹的区别"></a>Vue-cli中assets文件夹和static文件夹的区别</h4><p>在Vue-cli项目中，<code>assets</code>文件夹和<code>static</code>文件夹都用于存放静态资源，但它们在使用和处理方式上有一些关键的区别。</p>
<ol>
<li><strong>处理方式</strong>：<ul>
<li><strong>assets</strong>：<code>assets</code>文件夹中的文件会被Webpack处理。这意味着你可以使用相对路径来引用这些文件，并且Webpack会将这些文件打包到最终的构建中。因此，如果你修改了<code>assets</code>文件夹中的文件，Webpack会重新处理它们。</li>
<li><strong>static</strong>：放在<code>static</code>目录下的资源不会被Webpack处理，而是会被直接复制到最终的打包目录（默认是<code>dist/static</code>）下。你必须使用绝对路径来引用这些文件。这意味着，即使你修改了<code>static</code>文件夹中的文件，Webpack也不会重新处理它们，除非你重新运行构建过程。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>assets</strong>：通常用于存放那些可能会变动的文件，如组件使用的图片、全局的样式文件或工具类js文件等。由于这些文件会被Webpack处理，所以你可以利用Webpack的加载器（loaders）和插件（plugins）来进一步处理这些文件，如压缩、哈希命名等。</li>
<li><strong>static</strong>：适用于存放那些不会变动的文件，如一些第三方库、字体文件或图片等。由于这些文件不会被Webpack处理，所以你可以直接引用它们的原始文件名，而不需要担心Webpack会对其进行重命名或哈希处理。</li>
</ul>
</li>
<li><strong>引用方式</strong>：<ul>
<li><strong>assets</strong>：由于Webpack处理了<code>assets</code>文件夹中的文件，所以你可以使用相对路径来引用它们。例如，如果你有一个在<code>assets/images</code>目录下的图片，你可以在Vue组件中这样引用它：<code>&lt;img src=&quot;./assets/images/my-image.png&quot;&gt;</code>。</li>
<li><strong>static</strong>：由于<code>static</code>文件夹中的文件不会被Webpack处理，所以你必须使用绝对路径来引用它们。这通常是通过在<code>config.js</code>文件中的<code>build.assetsPublicPath</code>和<code>build.assetsSubDirectory</code>选项来配置的。例如，如果你的<code>static</code>文件夹下的图片路径是<code>/static/images/my-image.png</code>，那么你需要在Vue组件中这样引用它：<code>&lt;img src=&quot;/static/images/my-image.png&quot;&gt;</code>。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>assets</code>和<code>static</code>文件夹在Vue-cli项目中都用于存放静态资源，但它们在处理方式、使用场景和引用方式上有所不同。选择使用哪个文件夹取决于你的具体需求和资源的特性。</p>
<h4 id="Vue-cli中的-vue-cli-plugin-babel库"><a href="#Vue-cli中的-vue-cli-plugin-babel库" class="headerlink" title="Vue-cli中的@vue/cli-plugin-babel库"></a>Vue-cli中的@vue/cli-plugin-babel库</h4><p>在Vue CLI项目中，<code>@vue/cli-plugin-babel</code> 是一个插件，用于提供Babel的集成。Babel是一个广泛使用的JavaScript编译器，可以将ES6+代码转换为向后兼容的JavaScript版本，以确保在各种浏览器和环境中都能正常运行。</p>
<p>以下是关于<code>@vue/cli-plugin-babel</code>的一些关键点：</p>
<ol>
<li><strong>安装</strong>：<br>当使用Vue CLI创建项目时，通常会询问你是否需要包含Babel，并默认选择包含。如果你没有选择包含，但之后需要添加它，你可以通过Vue CLI的插件安装命令来添加它：</li>
</ol>
<pre class=" language-bash"><code class="language-bash">bash复制代码

vue add @vue/cli-plugin-babel
</code></pre>
<p>或者，你也可以通过npm或yarn手动安装：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev @vue/cli-plugin-babel  
<span class="token comment" spellcheck="true"># 或者  </span>
yarn add --dev @vue/cli-plugin-babel
</code></pre>
<ol>
<li><strong>配置</strong>：<br>一旦安装了<code>@vue/cli-plugin-babel</code>，它会自动为Vue CLI项目配置Babel。但如果你需要自定义配置，你可以通过以下几种方式进行：<ul>
<li><strong>.babelrc</strong> 或 <strong>babel.config.js</strong>：你可以在项目根目录下创建一个<code>.babelrc</code>文件（JSON格式）或一个<code>babel.config.js</code>文件（JavaScript格式），以指定Babel的配置选项。这些选项可以包括预设（presets）、插件（plugins）等。</li>
<li><strong>vue.config.js</strong>：你也可以在<code>vue.config.js</code>文件中通过修改webpack的配置来影响Babel的行为。</li>
<li><strong>package.json</strong>：Vue CLI还支持在<code>package.json</code>文件的<code>browserslist</code>字段中指定目标浏览器范围，这会影响Babel的转译行为。</li>
</ul>
</li>
<li><strong>使用</strong>：<br>在Vue CLI项目中，一旦你安装了<code>@vue/cli-plugin-babel</code>并配置了它，你就可以编写ES6+的代码了。当你运行<code>vue-cli-service build</code>或<code>vue-cli-service serve</code>等命令时，Babel会自动将你的代码转换为向后兼容的版本。</li>
<li><strong>与Vue CLI的集成</strong>：<br><code>@vue/cli-plugin-babel</code>与Vue CLI紧密集成，使得在Vue项目中使用Babel变得更加简单和方便。它会自动处理Vue文件的单文件组件（SFC）中的<code>&lt;script&gt;</code>部分，确保其中的JavaScript代码得到正确的转译。</li>
<li><strong>自定义配置</strong>：<br>虽然<code>@vue/cli-plugin-babel</code>提供了默认的配置，但你可能需要根据你的项目需求进行自定义配置。例如，你可能需要添加特定的Babel插件或预设来处理特定的语法或功能。你可以通过上面的配置选项来实现这些自定义配置。</li>
</ol>
<h3 id="Vue中的编译流程"><a href="#Vue中的编译流程" class="headerlink" title="Vue中的编译流程"></a>Vue中的编译流程</h3><h4 id="Vue中template模版编译原理"><a href="#Vue中template模版编译原理" class="headerlink" title="Vue中template模版编译原理"></a>Vue中template模版编译原理</h4><p>Vue中的template模板编译原理是一个关键的过程，它负责将Vue模板转换为可执行的JavaScript代码，从而实现数据绑定和响应式更新。以下是Vue模板编译的主要步骤：</p>
<ol>
<li><strong>解析（Parsing）</strong>：<ul>
<li>模板编译器首先读入模板源码，将其词法分析成各个部分。这些部分包括HTML元素、Vue指令（如<code>v-if</code>、<code>v-for</code>等）、以及特殊属性（如<code>:class</code>、<code>:style</code>等）。</li>
<li>解析器内部包含多个子解析器，如HTML解析器、文本解析器以及过滤器解析器等。HTML解析器主要负责解析HTML，并在解析过程中触发钩子函数，这些钩子函数用于构建AST（抽象语法树）节点。</li>
</ul>
</li>
<li><strong>优化（Optimization）</strong>：<ul>
<li>在解析模板的过程中，编译器会标记出那些不需要进行响应式更新的静态节点。静态节点是指在渲染过程中不会发生变化的节点，它们的值在编译时就已经确定。</li>
<li>编译器还会对AST进行优化，去除不必要的节点和属性，简化AST的结构。这些优化操作可以减少后续渲染过程中的不必要计算，提高性能。</li>
</ul>
</li>
<li><strong>生成AST（Abstract Syntax Tree）</strong>：<ul>
<li>AST的generator组件将区分开的各个部分进行上下文解析、封装，形成一个抽象语法树（AST）。AST是一个由节点组成的树状结构，表示了模板的逻辑结构和元素关系。</li>
</ul>
</li>
<li><strong>生成代码（Code Generation）</strong>：<ul>
<li>编译器将优化后的AST进行处理，生成JavaScript代码，即渲染函数。渲染函数是一个接收数据对象作为参数并返回虚拟DOM（Virtual DOM）的JavaScript函数。</li>
<li>虚拟DOM与实际DOM结构相对应，但具有更高的性能和效率。通过渲染函数生成虚拟DOM后，Vue的渲染引擎和diff算法会与实际的DOM进行比较，只更新发生变化的部分，以实现高效的视图更新。</li>
</ul>
</li>
<li><strong>执行渲染函数</strong>：<ul>
<li>渲染函数最终会被执行，将数据渲染到视图中。渲染函数包括了数据的读取、计算和更新等功能，是Vue实现数据绑定和响应式更新的核心。</li>
</ul>
</li>
</ol>
<p>总结来说，Vue中的template模板编译原理是一个将模板源码转换为可执行的JavaScript代码的过程，包括解析、优化、生成AST和生成代码等步骤。这个过程由Vue的编译器完成，实现了Vue的数据绑定和响应式更新。</p>
<h4 id="从编译开始的整个Vue的流程"><a href="#从编译开始的整个Vue的流程" class="headerlink" title="从编译开始的整个Vue的流程"></a>从编译开始的整个Vue的流程</h4><p>从编译开始的整个Vue的流程涉及多个关键步骤，以下是一个简化的概述：</p>
<ol>
<li>安装和配置<ul>
<li>安装Node.js和npm（Node Package Manager），这两个是开发Vue.js项目的基础。</li>
<li>安装Vue CLI（命令行界面），它是一个全局安装的npm包，用于快速搭建Vue.js项目。</li>
</ul>
</li>
<li>创建Vue项目<ul>
<li>使用Vue CLI创建一个新的Vue项目。这通常涉及选择预设的配置、项目名称、版本等信息。</li>
</ul>
</li>
<li>编写Vue组件<ul>
<li>在Vue项目中，你会编写多个Vue组件。每个组件都包含模板（template）、脚本（script）和样式（style）三个部分。</li>
<li>模板定义了组件的HTML结构，可以使用Vue的模板语法（如插值、指令、条件渲染、列表渲染等）。</li>
<li>脚本部分包含了组件的逻辑和数据，使用JavaScript编写。</li>
<li>样式部分定义了组件的样式，可以使用CSS或预处理器（如Sass、Less等）。</li>
</ul>
</li>
<li>模板编译<ul>
<li>Vue.js并不直接将模板转换为DOM元素，而是通过一种称为“模板编译”的技术，将模板转换为可执行的JavaScript代码。</li>
<li>模板编译的过程包括词法分析、语法分析、代码生成等多个步骤。词法分析将模板字符串转换为一系列标记，语法分析将这些标记转换为AST（抽象语法树），代码生成则根据AST生成渲染函数。</li>
<li>渲染函数是一个JavaScript函数，它接收数据作为参数并返回虚拟DOM。虚拟DOM是一个轻量级的JavaScript对象，用于描述真实的DOM结构。</li>
</ul>
</li>
<li>数据响应式<ul>
<li>Vue.js使用数据响应式机制来监听数据的变化，并在数据发生变化时自动更新视图。</li>
<li>当你修改Vue实例的数据时，Vue会遍历其依赖的组件，重新执行它们的渲染函数，并比较新旧虚拟DOM的差异，然后将这些差异应用到实际的DOM上，从而实现视图的更新。</li>
</ul>
</li>
<li>组件挂载和渲染<ul>
<li>使用Vue构造函数创建组件实例，并初始化相关属性和事件。</li>
<li>将组件实例挂载到DOM元素上，开始监听数据变化并渲染视图。</li>
</ul>
</li>
<li>用户交互和事件处理<ul>
<li>用户与Vue应用进行交互时（如点击按钮、输入文本等），会触发相应的事件。</li>
<li>Vue会监听这些事件，并执行相应的事件处理函数。这些函数可以修改Vue实例的数据，从而触发视图的更新。</li>
</ul>
</li>
<li>打包和发布<ul>
<li>使用Webpack等工具将Vue项目打包成可部署的文件（如HTML、CSS、JavaScript等）。</li>
<li>将打包后的文件部署到服务器或CDN上，供用户访问和使用。</li>
</ul>
</li>
</ol>
<p>请注意，以上流程是一个简化的概述，实际的Vue开发流程可能因项目需求和使用的技术栈而有所不同。</p>
<h4 id="Vue实例挂载的过程中发生了什么？"><a href="#Vue实例挂载的过程中发生了什么？" class="headerlink" title="Vue实例挂载的过程中发生了什么？"></a>Vue实例挂载的过程中发生了什么？</h4><p>在Vue实例挂载的过程中，主要发生了以下几个关键步骤：</p>
<ol>
<li>初始化<ul>
<li>Vue会进行一系列的初始化操作，包括合并配置项、初始化生命周期钩子、初始化事件系统、初始化响应式数据等。</li>
</ul>
</li>
<li>模板编译<ul>
<li>如果配置对象中存在<code>template</code>选项，Vue会将模板编译成渲染函数。这个过程包括模板解析、指令解析、AST（抽象语法树）生成等步骤。</li>
<li>渲染函数是Vue中用于生成虚拟DOM的函数。</li>
</ul>
</li>
<li>创建虚拟DOM<ul>
<li>通过调用渲染函数，Vue会根据模板生成虚拟DOM。虚拟DOM是一个轻量级的JavaScript对象，它描述了真实DOM的结构和属性。</li>
</ul>
</li>
<li>执行挂载函数<ul>
<li>Vue会调用<code>mount</code>函数，将虚拟DOM渲染成真实DOM，并将其插入到页面中指定的挂载点上。</li>
<li>这个过程涉及到虚拟DOM的创建、比对和更新，最终将渲染结果呈现在页面上。</li>
</ul>
</li>
<li>数据响应式<ul>
<li>在挂载完成后，Vue会对数据进行响应式处理。这意味着当数据发生变化时，Vue会自动更新相关的视图。</li>
</ul>
</li>
<li>触发生命周期钩子<ul>
<li>在挂载过程中，Vue实例会触发一系列的生命周期钩子函数，比如<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code>等。这些钩子函数允许你在Vue实例的不同阶段执行特定的操作或逻辑。</li>
</ul>
</li>
</ol>
<p>需要注意的是，这个过程是一个简化的概述，并且Vue的实际实现可能更加复杂和详细。但以上步骤涵盖了Vue实例挂载过程中的主要环节。</p>
<h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><h4 id="Vue3中组合式Api对比选项式Api的区别与优势"><a href="#Vue3中组合式Api对比选项式Api的区别与优势" class="headerlink" title="Vue3中组合式Api对比选项式Api的区别与优势"></a>Vue3中组合式Api对比选项式Api的区别与优势</h4><p>Vue 3中引入的组合式API（Composition API）与Vue 2中的选项式API（Options API）在设计和使用上有一些明显的区别与优势。</p>
<p><strong>区别</strong>：</p>
<ol>
<li><strong>结构组织</strong>：选项式API基于对象的设计方式，将Vue实例的各个部分（如data、methods、computed、watch等）拆分成不同的选项，并在创建Vue实例时将它们作为选项传入。而组合式API允许将数据和方法组合在一起，以提供更灵活和可复用的逻辑代码。</li>
<li><strong>代码复用</strong>：随着应用规模的扩大和复杂度的增加，选项式API可能导致代码难以维护和理解。数据和逻辑被分散在多个选项中，很难一眼看出它们之间的关系。而组合式API通过将逻辑封装为自定义函数，可以更好地复用逻辑代码。</li>
<li><strong>类型推断</strong>：Vue 3的组合式API更适用于TypeScript等类型检查工具。使用组合式API，TypeScript可以更准确地推断和捕获类型信息，提供更好的代码补全和错误检测。</li>
</ol>
<p><strong>优势</strong>：</p>
<ol>
<li><strong>代码组织</strong>：组合式API可以更好地组织代码，将相关逻辑代码封装在函数中，按照功能和关注点进行组织。这使得代码更清晰、模块化，并且易于理解和维护。</li>
<li><strong>复用性</strong>：组合式API通过封装逻辑为可复用的函数，提高了代码的复用性。可以根据需要选择性地调用这些函数，并在多个组件之间共享它们。</li>
<li><strong>直观性</strong>：在Vue 3的组合式API中，生命周期钩子函数（如created、mounted、updated、destroyed等）被替代为更直观和一致的函数调用，这使得代码更易于理解和维护。</li>
</ol>
<p>总的来说，组合式API通过提供更好的代码组织、复用性和直观性，解决了选项式API在大型和复杂应用中可能遇到的问题。然而，这并不意味着选项式API已经完全被取代。在Vue 3中，对两种API都提供了支持，开发者可以根据项目的具体需求和自己的偏好来选择使用哪种API。对于简单的场景，使用选项式API可能更加简单方便；而对于需要强烈支持TypeScript或大量逻辑复用的场景，组合式API可能是更好的选择。</p>
<h4 id="Vue3中watch-和-watchEffect-的区别"><a href="#Vue3中watch-和-watchEffect-的区别" class="headerlink" title="Vue3中watch 和 watchEffect 的区别"></a>Vue3中watch 和 watchEffect 的区别</h4><p>在 Vue 3 中，<code>watch</code> 和 <code>watchEffect</code> 都是用于响应式地观察和响应 Vue 组件中的数据变化的方法，但它们之间有一些重要的区别。</p>
<p><strong>watch</strong></p>
<p><code>watch</code> 是 Vue 2.x 和 Vue 3 中都存在的一个功能，它用于侦听特定的数据源，并在其变化时执行回调函数。<code>watch</code> 需要明确指定要侦听的数据源和回调函数。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>明确指定</strong>：你需要明确指定要侦听的数据源，以及当该数据源变化时要执行的回调函数。</li>
<li><strong>获取新旧值</strong>：在回调函数中，你可以获取到数据源变化前后的值（新值和旧值）。</li>
<li><strong>选项丰富</strong>：<code>watch</code> 提供了一些选项，如 <code>immediate</code>（是否在初始化时立即调用一次回调函数）和 <code>deep</code>（是否深度侦听对象内部值的变化）。</li>
</ol>
<p><strong>使用场景：</strong></p>
<ul>
<li>当你需要侦听某个特定的 prop 或 data 属性时。</li>
<li>当你需要在数据源变化时执行一些异步操作或开销较大的操作时。</li>
</ul>
<p><strong>watchEffect</strong></p>
<p><code>watchEffect</code> 是 Vue 3 中新增的一个功能，它用于自动追踪其回调函数中的响应式依赖，并在依赖变化时重新执行该函数。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>自动追踪</strong>：<code>watchEffect</code> 会自动追踪其回调函数中所依赖的响应式数据。</li>
<li><strong>立即执行</strong>：默认情况下，<code>watchEffect</code> 在组件挂载后会立即执行一次回调函数，以捕获初始状态。</li>
<li><strong>无需明确指定依赖</strong>：与 <code>watch</code> 不同，你不需要明确指定要侦听哪些数据源，<code>watchEffect</code> 会自动帮你做这件事。</li>
</ol>
<p><strong>使用场景</strong>：</p>
<ul>
<li>当你需要自动追踪多个响应式依赖时。</li>
<li>当你需要在组件挂载后立即执行一些逻辑时（例如，获取初始数据）。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><code>watch</code> 适用于需要明确指定数据源和回调函数的情况，以及需要获取数据源变化前后值的情况。</li>
<li><code>watchEffect</code> 适用于自动追踪多个响应式依赖，并在依赖变化时重新执行回调函数的情况。它更加灵活和简洁，但可能不如 <code>watch</code> 那么精确。</li>
</ul>
<p>在选择使用 <code>watch</code> 还是 <code>watchEffect</code> 时，你应该根据你的具体需求和场景来决定。</p>
<h4 id="Vue3中render函数的作用"><a href="#Vue3中render函数的作用" class="headerlink" title="Vue3中render函数的作用"></a>Vue3中render函数的作用</h4><p>在 Vue 3 中，<code>render</code> 函数是一个高级特性，它允许你手动编写 JavaScript 来生成虚拟 DOM（Virtual DOM）节点，而不是使用模板语法。<code>render</code> 函数在 Vue 的运行时环境中扮演着将组件的逻辑转换为实际 DOM 结构的关键角色。</p>
<p><code>render</code> 函数接收一个名为 <code>createElement</code> 的函数作为参数，这个函数用于创建虚拟 DOM 节点。<code>createElement</code> 函数接受三个参数：</p>
<blockquote>
<ol>
<li><strong>标签名或组件对象</strong>：可以是原生 HTML 标签名（如 <code>&#39;div&#39;</code>、<code>&#39;span&#39;</code> 等），也可以是 Vue 组件对象。</li>
<li><strong>包含组件的 props/attributes 的数据对象</strong>：这个对象用于定义元素的属性、props、DOM 属性、类名、样式等。</li>
<li><strong>子虚拟节点数组</strong>：一个由 <code>createElement</code> 创建的虚拟节点数组，作为当前元素的子节点。</li>
</ol>
</blockquote>
<p><code>render</code> 函数通常用于以下场景：</p>
<blockquote>
<ol>
<li><strong>高级用法和自定义渲染</strong>：当你需要更细粒度的控制渲染逻辑时，可以使用 <code>render</code> 函数。例如，你可以动态地根据组件的状态和属性来渲染不同的 DOM 结构。</li>
<li><strong>与 JSX 或 TSX 配合使用</strong>：虽然 Vue 本身不直接支持 JSX（JavaScript XML），但你可以通过 Babel 插件（如 <code>@vue/babel-plugin-jsx</code>）将 JSX 转换为 Vue 的 <code>render</code> 函数。这样，你就可以在 Vue 组件中使用类似于 React 的 JSX 语法来编写渲染逻辑。</li>
<li><strong>渲染函数式组件</strong>：函数式组件（Functional Components）是那些没有状态（即没有响应式数据）和实例（即没有 <code>this</code> 上下文）的组件。这些组件只根据传入的 props 来渲染 DOM 结构，因此非常适合使用 <code>render</code> 函数来实现。</li>
</ol>
</blockquote>
<p>需要注意的是，尽管 <code>render</code> 函数提供了更大的灵活性，但在大多数情况下，使用 Vue 的模板语法已经足够满足需求。模板语法更加直观和易于理解，尤其是对于非专业前端开发者来说。因此，在不需要特殊渲染逻辑的情况下，建议使用模板语法来编写 Vue 组件。</p>
<h4 id="Vue3中的setup语法糖"><a href="#Vue3中的setup语法糖" class="headerlink" title="Vue3中的setup语法糖"></a>Vue3中的setup语法糖</h4><p>在 Vue 3 中，<code>setup</code> 函数是 Composition API 的入口点，它使得我们可以在组件中使用响应式数据、生命周期钩子、方法等，而不必依赖于传统的选项式 API（Options API）。然而，Vue 3 还引入了一种称为“语法糖”（Syntactic Sugar）的简化方式，以更简洁的方式使用 Composition API。</p>
<p>这种语法糖主要体现在两个方面：<code>&lt;script setup&gt;</code> 和 <code>ref</code>/<code>reactive</code> 的自动解构。</p>
<p><strong><code>&lt;script setup&gt;</code></strong></p>
<script setup> 是 Vue 3 单文件组件（SFC）中的一个新语法，允许你在 <script> 标签中使用 setup 函数，而无需显式地定义 setup 函数。这种语法会自动将 setup 函数的返回值暴露给模板。


示例：

```vue
<template>  
  <button @click="increment"></button>  
</template>  
  
<script setup>  
import { ref } from 'vue'  
  
const count = ref(0)  
const increment = () => {  
  count.value++  
}  
</script>
<pre><code>
在这个示例中，我们使用了 `&lt;script setup&gt;` 语法，并在其中定义了响应式引用 `count` 和一个方法 `increment`。这些都被自动暴露给模板，使得我们可以在模板中直接使用它们。

**`ref`/`reactive` 的自动解构**

在 `&lt;script setup&gt;` 中，你还可以直接使用 `ref` 或 `reactive` 创建的响应式数据，而无需通过 `.value` 来访问它（在模板中除外）。这是因为 Vue 编译器会自动对 `ref` 进行解构。

示例：

```vue
&lt;template&gt;  
  &lt;input v-model=&quot;message&quot; /&gt;  
  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;  
&lt;/template&gt;  
  
&lt;script setup&gt;  
import &#123; ref &#125; from &#39;vue&#39;  
  
const message = ref(&#39;&#39;)  
&lt;/script&gt;
</code></pre>
<p>在这个示例中，我们直接在 <code>&lt;script setup&gt;</code> 中定义了一个 <code>ref</code> 类型的响应式数据 <code>message</code>。在模板中，我们可以直接使用 <code>v-model=&quot;message&quot;</code> 而不是 <code>v-model=&quot;message.value&quot;</code>。在 <code>&lt;script setup&gt;</code> 的作用域内，我们可以直接通过 <code>message</code> 访问其值，但在模板中仍然需要使用 <code>message</code>（而不是 <code>message.value</code>）作为变量名。</p>
<p><strong>总结</strong></p>
<script setup> 和 ref/reactive 的自动解构是 Vue 3 中引入的两种语法糖，它们使得使用 Composition API 变得更加简洁和直观。这些特性允许我们更专注于组件的逻辑和功能，而不必花费太多精力在语法和结构上。




#### Vue3中的ref、toRef、toRefs

在 Vue 3 中，`ref`、`toRef` 和 `toRefs` 是与响应式引用（reactive references）紧密相关的 API，它们主要用于处理响应式数据。这些 API 允许你创建和管理响应式引用，以便在组件的模板和逻辑中使用。以下是这些 API 的简要说明：

**1. `ref`**

`ref` 函数用于创建一个响应式的引用（reference）。它接受一个初始值作为参数，并返回一个响应式的对象，该对象具有一个 `.value` 属性，用于访问或修改其值。

```javascript
import { ref } from 'vue';  
  
const count = ref(0);  
  
console.log(count.value); // 输出: 0  
  
count.value++;  
console.log(count.value); // 输出: 1
```

在模板中，你可以直接使用 `count`（不需要 `.value`），Vue 会自动为你处理。

**2. `toRef`**

`toRef` 函数用于为一个响应式对象的属性创建一个引用。与 `ref` 不同，`toRef` 创建的引用与原始对象保持连接，当原始对象的属性值发生变化时，引用也会更新。

```javascript
import { reactive, toRef } from 'vue';  
  
const state = reactive({  
  count: 0  
});  
  
const countRef = toRef(state, 'count');  
  
console.log(countRef.value); // 输出: 0  
  
state.count++;  
console.log(countRef.value); // 输出: 1
```

注意，如果你尝试通过 `countRef.value` 修改值，它只会影响 `state.count`，而不是创建一个新的响应式引用。

**3. `toRefs`**

`toRefs` 函数用于将一个响应式对象的所有属性转换为单独的响应式引用，并将它们收集到一个普通对象中。这在你需要将多个响应式属性传递给组件的 props 或在模板中大量使用它们时非常有用。

```javascript
import { reactive, toRefs } from 'vue';  
  
const state = reactive({  
  count: 0,  
  name: 'Vue'  
});  
  
const refs = toRefs(state);  
  
console.log(refs.count.value); // 输出: 0  
console.log(refs.name.value); // 输出: 'Vue'  
  
state.count++;  
console.log(refs.count.value); // 输出: 1
```

在模板中，你可以通过解构（destructuring）`toRefs` 的结果来直接使用这些引用，而无需每次都写 `.value`。

```vue
<template>  
  <div>  
    <p></p> <!-- 直接使用 count，而不是 count.value -->  
    <p></p> <!-- 直接使用 name，而不是 name.value -->  
  </div>  
</template>  
  
<script>  
import { reactive, toRefs } from 'vue';  
  
export default {  
  setup() {  
    const state = reactive({  
      count: 0,  
      name: 'Vue'  
    });  
  
    return {  
      ...toRefs(state)  
    };  
  }  
}  
</script>
<pre><code>


#### Vue3中的 reactive、 shallowReactive 函数

在 Vue 3 的 Composition API 中，`reactive` 和 `shallowReactive` 是两个用于创建响应式对象的函数。它们之间的主要区别在于它们如何处理嵌套对象的响应性。

**reactive**

`reactive` 函数用于创建一个响应式对象，该对象的所有嵌套属性（包括子对象）都是响应式的。当这些属性的值发生变化时，视图将自动更新。

```javascript
import &#123; reactive &#125; from &#39;vue&#39;;  
  
const state = reactive(&#123;  
  count: 0,  
  nested: &#123;  
    name: &#39;Vue&#39;,  
    version: 3  
  &#125;  
&#125;);  
  
// 改变顶级属性的值  
state.count++;  
  
// 改变嵌套对象的属性  
state.nested.name = &#39;Vue.js&#39;;  
  
// 这两个更改都会触发视图的更新
</code></pre>
<p>在上面的例子中，<code>state</code> 是一个响应式对象，它的 <code>count</code> 属性和 <code>nested</code> 对象（包括其 <code>name</code> 和 <code>version</code> 属性）都是响应式的。</p>
<p><strong>shallowReactive</strong></p>
<p><code>shallowReactive</code> 函数也用于创建一个响应式对象，但与 <code>reactive</code> 不同的是，它只使对象的顶层属性变为响应式。对象的嵌套属性（即子对象）不会变为响应式，除非它们本身也是响应式的。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> shallowReactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>  
  
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  
  nested<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
    name<span class="token punctuation">:</span> <span class="token string">'Vue'</span><span class="token punctuation">,</span>  
    version<span class="token punctuation">:</span> <span class="token number">3</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 改变顶级属性的值  </span>
state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 改变嵌套对象的属性（这里不会触发视图的更新，因为 nested 不是响应式的）  </span>
state<span class="token punctuation">.</span>nested<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Vue.js'</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 只有 count 的更改会触发视图的更新</span>
</code></pre>
<p>在上面的例子中，<code>state</code> 是一个响应式对象，但只有它的 <code>count</code> 属性是响应式的。<code>nested</code> 对象和其内部的 <code>name</code>、<code>version</code> 属性都不是响应式的。因此，只有对 <code>count</code> 的更改会触发视图的更新。</p>
<p><strong>何时使用 shallowReactive？</strong></p>
<p>在某些情况下，你可能不希望 Vue 追踪对象内部的所有嵌套属性变化，因为这可能会带来不必要的性能开销。例如，当你有一个大型对象，并且你只对它的顶层属性感兴趣时，<code>shallowReactive</code> 可能是一个更好的选择。但是，请注意，如果你试图修改嵌套对象的属性并期望视图更新，那么你需要确保这些嵌套对象也是响应式的，或者使用其他方法（如 Vuex）来管理你的状态。</p>
<h4 id="Vue3中setup语法下怎么设置name属性？"><a href="#Vue3中setup语法下怎么设置name属性？" class="headerlink" title="Vue3中setup语法下怎么设置name属性？"></a>Vue3中setup语法下怎么设置name属性？</h4><p>在 Vue 3 中，由于 <code>setup()</code> 函数是 Composition API 的一部分，并且它不直接绑定到组件实例上，因此你不能直接在 <code>setup()</code> 函数中设置组件的 <code>name</code> 属性，如同你在 Vue 2 的 <code>options</code> API 中所做的那样。</p>
<p>然而，<code>name</code> 属性主要用于开发工具中的调试和警告，它并不是组件功能所必需的。尽管如此，如果你确实需要在 Vue 3 中为组件设置一个 <code>name</code>，你仍然可以在组件的 <code>options</code> 部分（如果你同时使用 Composition API 和 Options API）或在 Vue 文件的 <code>&lt;script&gt;</code> 标签外（使用单文件组件）进行设置。</p>
<p><strong>使用 Options API 和 Composition API 混合</strong></p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>  
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>  
  
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  
  name<span class="token punctuation">:</span> <span class="token string">'MyComponentName'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 设置组件名  </span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment" spellcheck="true">// ... 其他逻辑  </span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>  
      count  
    <span class="token punctuation">}</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token comment" spellcheck="true">// ... 其他选项，如 methods、computed 等  </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p><strong>仅使用 Composition API</strong></p>
<p>如果你完全使用 Composition API，并且希望保持单文件组件的整洁，你可以在 <code>&lt;script&gt;</code> 标签的外部设置 <code>name</code> 属性：</p>
<pre class=" language-vue"><code class="language-vue"><template>  
  <!-- 组件模板 -->  
</template>  
  
<script>  
import { ref } from 'vue';  
  
export default {  
  setup() {  
    const count = ref(0);  
    // ... 其他逻辑  
    return {  
      count  
    };  
  },  
  // 注意：这里不设置 name，因为我们在外部设置  
};  
</script>  
  
<script setup>  
// 这个 script setup 是 Vue 3 的单文件组件语法糖  
// 由于它不支持直接设置 name，我们通常在外部设置  
</script>  
  
<style scoped>  
/* 组件样式 */  
</style>  
  
<!-- 在单文件组件的外部设置 name -->  
<script>  
export default {  
  name: 'MyComponentName'  
}  
</script>
</code></pre>
<p>但请注意，在 <code>&lt;script setup&gt;</code> 外部再包裹一个 <code>&lt;script&gt;</code> 来设置 <code>name</code> 并不是官方推荐的做法，因为这可能会引入一些混淆。在实际开发中，大多数开发者会选择在 <code>export default</code> 对象中直接设置 <code>name</code>，即使他们主要使用 Composition API。</p>
<p>如果你只使用 <code>&lt;script setup&gt;</code> 并且确实需要 <code>name</code>（尽管通常不需要），你可能需要依赖于外部工具或配置来设置它，或者接受默认的行为（即不设置 <code>name</code>）。</p>
<h4 id="Vue3中的自定义指令"><a href="#Vue3中的自定义指令" class="headerlink" title="Vue3中的自定义指令"></a>Vue3中的自定义指令</h4><p>在 Vue 3 中，自定义指令是一种强大而灵活的功能，允许你创建可复用的 DOM 行为。与 Vue 2 类似，Vue 3 提供了自定义指令的 API，但有一些细微的差别。</p>
<p>在 Vue 3 中，你可以通过 <code>app.directive()</code> 方法在 Vue 应用实例上注册全局自定义指令，或者在组件的 <code>directives</code> 选项上注册局部自定义指令。</p>
<p>自定义指令接收两个参数：指令名和指令定义对象。指令定义对象可以包含以下几个钩子函数（都是可选的）：</p>
<blockquote>
<ul>
<li><code>bind(el, binding, vnode, prevVnode)</code>: 当被绑定的元素挂载到 DOM 中时……调用。只调用一次。</li>
<li><code>inserted(el, binding, vnode, prevVnode)</code>: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li><code>update(el, binding, vnode, prevVnode)</code>: 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</li>
<li><code>componentUpdated(el, binding, vnode, prevVnode)</code>: 指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li><code>unmount(el, binding, vnode, prevVnode)</code>: 指令与元素解绑（只调用一次）。</li>
</ul>
</blockquote>
<p>下面是一个全局自定义指令的示例，它用于将元素的颜色设置为指令的值：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  
  
app<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-color'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  
  <span class="token comment" spellcheck="true">// 当被绑定的元素挂载到 DOM 中时……  </span>
  <span class="token function">bind</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// el 是指令所绑定的元素  </span>
    <span class="token comment" spellcheck="true">// binding 是一个对象，包含以下属性：  </span>
    <span class="token comment" spellcheck="true">//   - name: 指令名，不包括 v- 前缀。  </span>
    <span class="token comment" spellcheck="true">//   - value: 指令的绑定值，例如：v-my-color="123" 中，绑定值为 123。  </span>
    <span class="token comment" spellcheck="true">//   - oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。  </span>
    <span class="token comment" spellcheck="true">//   - expression: 字符串形式的指令表达式。例如 v-my-color="1 + 1" 中，表达式为 "1 + 1"。  </span>
    <span class="token comment" spellcheck="true">//   - arg: 传给指令的参数，可选。例如 v-my-color:red 中，参数为 "red"。  </span>
    <span class="token comment" spellcheck="true">//   - modifiers: 一个包含修饰符的对象。例如：v-my-color.foo.bar 中，修饰符对象为 { foo: true, bar: true }。  </span>
    <span class="token comment" spellcheck="true">// vnode 是 Vue 编译生成的虚拟节点  </span>
    el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> binding<span class="token punctuation">.</span>value  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  <span class="token comment" spellcheck="true">// ... 其他钩子函数  </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
  
app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre>
<p>然后你可以在模板中这样使用自定义指令：</p>
<pre class=" language-html"><code class="language-html">html复制代码

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-my-color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>red<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello World!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
</code></pre>
<p>这将会把文本 “Hello World!” 的颜色设置为红色。注意，我们在 <code>v-my-color</code> 中使用了单引号，这是因为我们实际上是在传递一个字符串字面量给指令。如果 <code>binding.value</code> 是一个变量或表达式，你可以直接写 <code>v-my-color=&quot;myColorVariable&quot;</code>。</p>
<h4 id="pinia：Vue3中的状态管理库"><a href="#pinia：Vue3中的状态管理库" class="headerlink" title="pinia：Vue3中的状态管理库"></a>pinia：Vue3中的状态管理库</h4><p>Pinia是一个专为Vue 3设计的状态管理库，它基于Vue 3的Composition API，并以Vuex的下一代构想为基础，设计了新的Vue存储状态管理库。Pinia的主要特点和优势包括：</p>
<blockquote>
<ol>
<li><strong>简洁和轻量级</strong>：Pinia的设计理念和API都非常直观和简洁，使得开发者可以快速上手。它的大小只有约1KB，是一个轻量级的状态管理工具。</li>
<li><strong>基于响应式系统</strong>：Pinia的状态管理是基于Vue 3的响应式系统的，这意味着当状态发生改变时，相关的组件会自动更新。</li>
<li><strong>模块化设计</strong>：Pinia支持多个store，这使得你可以将应用程序的状态按照功能或模块进行划分，提高了代码的可维护性和可读性。</li>
<li><strong>支持同步和异步操作</strong>：Pinia中的action支持同步和异步操作，这使得你可以更方便地处理异步逻辑，比如从服务器获取数据等。</li>
<li><strong>支持服务端渲染（SSR）</strong>：Pinia可以很好地与Vue的服务端渲染功能配合使用，使得你可以在服务器端就预先渲染出应用程序的状态。</li>
<li><strong>支持Vue Devtools</strong>：Pinia与Vue Devtools完美集成，使得你可以更方便地调试和查看应用程序的状态。</li>
</ol>
</blockquote>
<p>在Pinia中，核心概念是Store，它类似于Vuex中的Store，但是更加轻便和灵活。在Store中，你可以使用Vue 3的响应式系统来定义状态，并通过actions来定义修改状态的方法。</p>
<p>总的来说，Pinia是一个强大而灵活的状态管理库，它可以帮助你更好地管理Vue 3应用程序的状态，提高代码的可维护性和可读性。如果你正在使用Vue 3开发应用程序，那么Pinia是一个值得考虑的状态管理库。</p>
<h4 id="Vue3中怎么封装自定义插件并使用？"><a href="#Vue3中怎么封装自定义插件并使用？" class="headerlink" title="Vue3中怎么封装自定义插件并使用？"></a>Vue3中怎么封装自定义插件并使用？</h4><p>在Vue 3中，你可以通过创建一个包含<code>install</code>方法的对象来封装自定义插件，并使用<code>app.use()</code>方法来安装和使用这个插件。以下是一个简单的步骤说明和示例：</p>
<p><strong>步骤</strong></p>
<ol>
<li><p>定义插件</p>
<p>：</p>
<ul>
<li>创建一个对象，该对象至少应该有一个<code>install</code>方法。</li>
<li><code>install</code>方法接收两个参数：<code>app</code>（Vue应用实例）和<code>options</code>（传递给插件的选项）。</li>
</ul>
</li>
<li><p>编写插件功能</p>
<p>：</p>
<ul>
<li>在<code>install</code>方法中，你可以添加全局方法或属性、添加全局资源、添加组件选项等等。</li>
</ul>
</li>
<li><p>使用插件</p>
<p>：</p>
<ul>
<li>在你的Vue应用中，使用<code>app.use(你的插件)</code>来安装插件。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong></p>
<p>假设我们要创建一个简单的全局提示插件：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// my-plugin.js  </span>
<span class="token keyword">const</span> MyPlugin <span class="token operator">=</span> <span class="token punctuation">{</span>  
  <span class="token comment" spellcheck="true">// install 方法是插件的核心  </span>
  <span class="token function">install</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// 确保插件只被安装一次  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>app<span class="token punctuation">.</span>_installedPlugins<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token keyword">return</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token comment" spellcheck="true">// 添加全局方法  </span>
    app<span class="token punctuation">.</span>config<span class="token punctuation">.</span>globalProperties<span class="token punctuation">.</span>$alert <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token function">alert</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">;</span>  
  
    <span class="token comment" spellcheck="true">// 添加全局指令（如果需要）  </span>
    app<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  
      <span class="token comment" spellcheck="true">// 指令定义  </span>
      <span class="token function">mounted</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment" spellcheck="true">// 指令挂载时的逻辑  </span>
        el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'这是一个自定义指令'</span><span class="token punctuation">;</span>  
      <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
    <span class="token comment" spellcheck="true">// 你可以在这里使用传入的options进行其他操作  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>someOption<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'使用了某个选项:'</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>someOption<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
  
    <span class="token comment" spellcheck="true">// 添加到已安装插件列表  </span>
    app<span class="token punctuation">.</span>_installedPlugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 在你的main.js或main.ts中使用插件  </span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>  
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token punctuation">;</span>  
<span class="token keyword">import</span> MyPlugin <span class="token keyword">from</span> <span class="token string">'./my-plugin'</span><span class="token punctuation">;</span>  
  
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span>  
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">,</span> <span class="token punctuation">{</span> someOption<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传入选项（如果需要）  </span>
app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>在上面的示例中，我们创建了一个名为<code>MyPlugin</code>的插件，它添加了一个全局方法<code>$alert</code>和一个全局指令<code>v-my-directive</code>。然后，在<code>main.js</code>或<code>main.ts</code>中，我们导入了这个插件并使用<code>app.use()</code>方法进行了安装。</p>
<p>注意：在Vue 3中，Vue实例不再暴露<code>Vue.prototype</code>，因此我们使用<code>app.config.globalProperties</code>来添加全局方法或属性。同时，<code>app._installedPlugins</code>是一个内部属性，用于追踪已安装的插件，以确保插件只被安装一次。虽然这不是必需的，但在某些情况下可能很有用。</p>
<h4 id="Vue3中createApp-App-创建应用实例过程中都发生了什么？"><a href="#Vue3中createApp-App-创建应用实例过程中都发生了什么？" class="headerlink" title="Vue3中createApp(App)创建应用实例过程中都发生了什么？"></a>Vue3中createApp(App)创建应用实例过程中都发生了什么？</h4><p>在Vue 3中，<code>createApp(App)</code>方法用于创建一个新的Vue应用实例。当你调用这个方法时，Vue内部会执行一系列的操作来设置和初始化这个应用实例。以下是<code>createApp(App)</code>创建应用实例过程中大致发生的一些步骤：</p>
<blockquote>
<ol>
<li><strong>参数处理</strong>：<code>createApp</code>方法接收一个根组件对象（在你的例子中是<code>App</code>）作为参数。这个对象通常是一个Vue组件，包含了模板、数据、方法等。</li>
<li><strong>创建应用实例</strong>：Vue内部会基于提供的根组件对象创建一个新的应用实例。这个实例包含了Vue应用所需的所有核心功能和状态。</li>
<li><strong>初始化响应式系统</strong>：Vue的响应式系统是其核心特性之一，允许数据和DOM之间保持同步。在创建应用实例时，Vue会初始化响应式系统，将根组件的数据转换为响应式数据。</li>
<li><strong>设置渲染上下文</strong>：Vue需要知道如何将组件渲染到DOM中。在创建应用实例时，Vue会设置渲染上下文，包括挂载点（即DOM元素）和渲染器（用于将虚拟DOM转换为真实DOM）。</li>
<li><strong>注册组件和指令</strong>：如果你在应用实例中注册了全局组件或指令，Vue会在此时将它们添加到全局注册表中。这样，你就可以在应用中的任何地方使用这些组件和指令了。</li>
<li><strong>启动挂载过程</strong>：最后，当你调用<code>app.mount(&#39;#app&#39;)</code>时（其中<code>#app</code>是挂载点的选择器），Vue会开始挂载过程。这个过程包括创建组件的虚拟DOM树、比较虚拟DOM和真实DOM的差异、以及将差异应用到真实DOM上。</li>
</ol>
</blockquote>
<p>需要注意的是，这个过程是一个简化的概述，Vue内部的实际实现可能会更加复杂和详细。此外，Vue 3还引入了许多新特性和优化，如Composition API、Teleport、Suspense等，这些特性在创建和挂载应用实例时也可能会有所体现。</p>
<p>如果你对Vue 3的源码感兴趣，可以查阅Vue的官方文档或源码来了解更多关于<code>createApp</code>方法和应用实例创建过程的细节。</p>
<h4 id="Vue3中有哪些新的组件？"><a href="#Vue3中有哪些新的组件？" class="headerlink" title="Vue3中有哪些新的组件？"></a>Vue3中有哪些新的组件？</h4><p>在Vue 3中，引入了一些新的内置组件，这些组件为开发者提供了更多的灵活性和功能。以下是Vue 3中的一些新组件：</p>
<ol>
<li><p>Teleport</p>
<p>：</p>
<ul>
<li>Teleport 是一种能够将组件的 HTML 结构“传送”到 DOM 树中指定位置的技术。这在处理如模态框、弹出窗口等需要脱离正常文档流的组件时非常有用。</li>
<li>你可以使用 <code>Teleport</code> 组件来指定子组件应该被渲染到哪个 DOM 节点中，而不是在其父组件的模板中。</li>
</ul>
</li>
<li><p>Suspense</p>
<p>：</p>
<ul>
<li>Suspense 组件用于处理异步组件的加载状态。当组件在等待异步组件加载时，你可以指定一个 fallback 组件来显示加载中的状态。</li>
<li>这对于在加载异步数据或组件时提供用户反馈非常有用，尤其是在需要保持 UI 流畅性的情况下。</li>
</ul>
</li>
<li><p>Fragment</p>
<p>：</p>
<ul>
<li>在 Vue 2 中，组件的根节点只能有一个。但在 Vue 3 中，你可以使用 <code>&lt;Fragment&gt;</code> 或简单地不使用根节点来渲染多个根节点。</li>
<li>这使得组件的模板更加灵活，特别是在需要将多个元素作为根元素渲染到 DOM 中的情况下。</li>
</ul>
</li>
<li><p>Transition 和 TransitionGroup</p>
<p>：</p>
<ul>
<li>这些组件在 Vue 2 中已经存在，但在 Vue 3 中得到了改进。它们用于在元素或组件进入、离开或列表更新时应用过渡效果。</li>
<li>通过使用这些组件，你可以更轻松地创建复杂的动画和过渡效果。</li>
</ul>
</li>
</ol>
<p>需要注意的是，虽然这些组件是 Vue 3 的新特性，但它们并不是必须使用的。你可以根据自己的项目需求来选择是否使用这些组件。同时，Vue 社区也提供了许多第三方组件库和插件，这些库和插件也可以为你的项目提供额外的功能和灵活性。</p>
<h4 id="Vue3中Composition-API-和-React-Hook的区别"><a href="#Vue3中Composition-API-和-React-Hook的区别" class="headerlink" title="Vue3中Composition API 和 React Hook的区别"></a>Vue3中Composition API 和 React Hook的区别</h4><p>Vue3中的Composition API和React Hook在多个方面存在区别，这些区别主要体现在语法、概念、数据响应性等方面。</p>
<ol>
<li>语法和概念：</li>
</ol>
<ul>
<li>Vue 3的Composition API使用函数方式组织逻辑，引入了如<code>ref</code>、<code>reactive</code>、<code>computed</code>等新概念。这些函数和概念允许开发者将逻辑和状态管理逻辑分离，使代码更加清晰和可维护。</li>
<li>React Hooks则使用函数调用，主要包括<code>useState</code>、<code>useEffect</code>、<code>useContext</code>等。Hooks允许你在不编写class的情况下使用state以及其他的React特性，从而在不改变组件结构的情况下复用状态逻辑。</li>
</ul>
<ol>
<li>数据响应性：</li>
</ol>
<ul>
<li>Vue 3使用了响应性系统来管理数据的变化。通过使用<code>reactive</code>函数，你可以创建响应式对象，其属性会随着对象属性的改变而自动更新。这在状态管理和数据传递上非常有用。</li>
<li>React则没有内置的响应性系统。在React中，你需要使用<code>useState</code>来管理组件状态，并使用<code>useEffect</code>来处理副作用。然而，这些工具并不提供像Vue那样的自动数据响应性。</li>
</ul>
<ol>
<li>组件逻辑组织：</li>
</ol>
<ul>
<li>使用Composition API，你可以将组件的逻辑按照功能进行组织，而不是按照选项进行组织。这提高了代码的可读性和可维护性。</li>
<li>在React中，Hooks允许你在函数组件中“钩入”React state及生命周期等特性。这意味着你可以在无需编写class组件的情况下使用React的许多高级功能。</li>
</ul>
<p>总的来说，Vue3的Composition API和React Hook都是各自框架中用于提高代码复用性和组织性的重要工具。然而，它们在语法、概念和数据响应性等方面存在差异，这些差异可能会影响开发者在不同框架下的编码习惯和策略。在选择使用哪种技术时，需要根据具体项目的需求和个人偏好来做出决策。</p>
<h3 id="Vue相关"><a href="#Vue相关" class="headerlink" title="Vue相关"></a>Vue相关</h3><h4 id="vue-内置指令"><a href="#vue-内置指令" class="headerlink" title="vue 内置指令"></a>vue 内置指令</h4><p><img src="/../images/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/vue-command.jpg" alt="vue内置指令"></p>
<h4 id="Vue2中的自定义指令"><a href="#Vue2中的自定义指令" class="headerlink" title="Vue2中的自定义指令"></a>Vue2中的自定义指令</h4><p>在Vue 2中，你可以创建和使用自定义指令（Custom Directives）来扩展HTML元素的功能。自定义指令提供了一种灵活的方式来在DOM元素上应用低级别的操作，比如元素插入、更新或移除时的行为。</p>
<h5 id="创建自定义指令"><a href="#创建自定义指令" class="headerlink" title="创建自定义指令"></a>创建自定义指令</h5><p>在Vue中，你可以使用<code>Vue.directive()</code>方法来注册一个全局的自定义指令，或者使用组件的<code>directives</code>选项来注册一个局部的自定义指令。</p>
<p>以下是一个全局自定义指令的示例，该指令会在元素被插入到DOM时聚焦到该元素上（如果它是一个<code>&lt;input&gt;</code>或<code>&lt;textarea&gt;</code>）：</p>
<pre class=" language-javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  
  <span class="token comment" spellcheck="true">// 当被绑定的元素插入到 DOM 中时……  </span>
  inserted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// 聚焦元素  </span>
    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>你也可以定义多个钩子函数，它们会在不同的时间点被调用：</p>
<ul>
<li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
<li><code>update</code>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</li>
<li><code>componentUpdated</code>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li>
<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li>
</ul>
<h5 id="使用自定义指令"><a href="#使用自定义指令" class="headerlink" title="使用自定义指令"></a>使用自定义指令</h5><p>在HTML模板中，你可以通过添加<code>v-</code>前缀和指令名（不需要<code>v-</code>前缀的<code>focus</code>在上面的例子中）来使用自定义指令。如果指令需要值，你可以通过等号（<code>=</code>）来指定一个表达式：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-focus</span><span class="token punctuation">></span></span>  
  
<span class="token comment" spellcheck="true">&lt;!-- 或者，带有参数 --></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-focus:</span>someparam</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>somevalue<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  
  
<span class="token comment" spellcheck="true">&lt;!-- 或者，带有修饰符 --></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-focus.modifier</span><span class="token punctuation">></span></span>
</code></pre>
<p>在指令的定义中，你可以通过<code>binding</code>参数来访问传递给指令的值、参数和修饰符：</p>
<pre class=" language-javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  
  bind<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// el 是指令所绑定的元素  </span>
    <span class="token comment" spellcheck="true">// binding 是一个对象，包含以下属性：  </span>
    <span class="token comment" spellcheck="true">//   - name：指令名，不包括 v- 前缀。  </span>
    <span class="token comment" spellcheck="true">//   - value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。  </span>
    <span class="token comment" spellcheck="true">//   - oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。  </span>
    <span class="token comment" spellcheck="true">//   - expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。  </span>
    <span class="token comment" spellcheck="true">//   - arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。  </span>
    <span class="token comment" spellcheck="true">//   - modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。  </span>
    <span class="token comment" spellcheck="true">// vnode 是 Vue 编译生成的虚拟节点。  </span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>注意：在Vue 3中，自定义指令的API和用法有一些变化，如果你正在使用或考虑升级到Vue 3，请查阅相应的文档。</p>
<h4 id="Vue中的-nextTick及使用场景"><a href="#Vue中的-nextTick及使用场景" class="headerlink" title="Vue中的$nextTick及使用场景"></a>Vue中的$nextTick及使用场景</h4><p>Vue中的<code>$nextTick</code>是一个非常重要的函数，它用于在DOM更新完成后执行回调函数。由于Vue是异步执行DOM更新的，所以当你需要确保在DOM更新后执行某些操作时，就可以使用<code>$nextTick</code>。</p>
<h5 id="nextTick的定义及理解"><a href="#nextTick的定义及理解" class="headerlink" title="$nextTick的定义及理解"></a>$nextTick的定义及理解</h5><p><code>$nextTick</code>是一个Vue实例方法，它接受一个回调函数作为参数，并在DOM更新完成后执行该回调函数。在修改数据之后立即使用这个方法，可以确保获取到更新后的DOM。</p>
<h5 id="nextTick的使用原理"><a href="#nextTick的使用原理" class="headerlink" title="$nextTick的使用原理"></a>$nextTick的使用原理</h5><p>Vue是异步执行DOM更新的，一旦观察到数据变化，Vue就会开启一个队列，并把在同一个事件循环中观察到数据变化的watcher推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。在下一个事件循环的“tick”中，Vue会刷新队列并执行实际工作（已去重的）。因此，<code>$nextTick</code>将回调函数放到微任务或者宏任务当中以延迟它的执行顺序，确保在DOM更新完成后执行回调函数。</p>
<h5 id="nextTick的使用场景"><a href="#nextTick的使用场景" class="headerlink" title="$nextTick的使用场景"></a>$nextTick的使用场景</h5><ol>
<li><strong>确保获取更新后的DOM</strong>：当你修改数据后需要立即获取更新后的DOM时，可以使用<code>$nextTick</code>。例如，你可能需要读取某个DOM元素的文本内容或属性，但由于DOM更新是异步的，直接使用可能会得到旧的值。通过<code>$nextTick</code>，你可以确保在DOM更新后获取到正确的值。</li>
<li><strong>避免在DOM更新前执行某些操作</strong>：有时候你可能需要在DOM更新之前避免执行某些操作，因为这些操作可能会依赖于更新后的DOM状态。通过使用<code>$nextTick</code>，你可以将这些操作放在回调函数中，确保它们在DOM更新后执行。</li>
<li><strong>解决事件触发后获取旧值的问题</strong>：在某些情况下，如点击事件触发后，Vue可能会先把对应方法内的任务执行完，再进行页面渲染。这意味着如果你在事件处理函数中直接读取DOM元素的值，可能会得到旧的值。通过使用<code>$nextTick</code>，你可以确保在DOM更新后读取到正确的值。</li>
<li><strong>切换显示input框时立即获取焦点</strong>：当你需要在切换显示input框时立即让input框获取焦点时，可以使用<code>$nextTick</code>。因为即使你在数据改变后立即尝试让input框获取焦点，但由于DOM更新是异步的，焦点可能会被设置到旧的DOM元素上。通过使用<code>$nextTick</code>，你可以确保在DOM更新后让input框获取焦点。</li>
</ol>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>你可以通过<code>this.$nextTick(callback)</code>的方式在Vue实例中使用<code>$nextTick</code>。其中<code>callback</code>是你要在DOM更新后执行的回调函数。例如：</p>
<pre class=" language-javascript"><code class="language-javascript">methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
  <span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'-'</span><span class="token punctuation">;</span>  
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>continer<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<p>在这个例子中，<code>change</code>方法会修改<code>msg</code>的值，并通过<code>$nextTick</code>确保在DOM更新后打印出更新后的文本内容。</p>
<h4 id="Vue中的过滤器"><a href="#Vue中的过滤器" class="headerlink" title="Vue中的过滤器"></a>Vue中的过滤器</h4><p>在 Vue.js 中，过滤器（Filters）是一种用于在模板中简单处理文本的功能。然而，在 Vue 2.x 中，过滤器主要用于文本格式化，但在 Vue 3.x 中，过滤器已经被移除，因为官方认为它们不如计算属性和方法灵活。不过，由于许多项目可能还在使用 Vue 2.x，因此了解 Vue 2.x 中的过滤器仍然是有用的。</p>
<p>在 Vue 2.x 中，你可以定义全局过滤器或组件级别的过滤器。过滤器函数总是接收表达式的值（之前的值）作为第一个参数。</p>
<h5 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h5><p>你可以使用 <code>Vue.filter()</code> 方法来注册全局过滤器：</p>
<pre class=" language-javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token string">'myFilter'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  <span class="token comment" spellcheck="true">// 对 value 进行处理并返回  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">''</span>  
  value <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
  <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>在模板中，你可以使用双花括号插值或 <code>v-bind</code> 表达式（在 Vue 2.1.0+ 的版本中）来使用这个过滤器：</p>
<pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 在双花括号中 --></span>  
{{ message | myFilter }}  
  
<span class="token comment" spellcheck="true">&lt;!-- 在 v-bind 表达式中 --></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message | myFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
</code></pre>
<h5 id="组件级别的过滤器"><a href="#组件级别的过滤器" class="headerlink" title="组件级别的过滤器"></a>组件级别的过滤器</h5><p>你也可以在组件的选项中定义过滤器：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
    message<span class="token punctuation">:</span> <span class="token string">'hello'</span>  
  <span class="token punctuation">}</span><span class="token punctuation">,</span>  
  filters<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
    <span class="token function">myFilter</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token comment" spellcheck="true">// ... 同全局过滤器  </span>
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>然后在该组件的模板中使用这个过滤器。</p>
<p>在 Vue 3.x 中，过滤器已被移除，但你可以使用以下方法作为替代：</p>
<ol>
<li><strong>计算属性</strong>：对于复杂逻辑，计算属性是一个很好的选择。它们允许你根据组件的其他属性动态地计算新值。</li>
<li><strong>方法</strong>：对于简单的文本格式化，你可以在模板中直接调用一个方法来处理文本。</li>
<li><strong>自定义指令</strong>：虽然这不是处理文本格式化的首选方法，但自定义指令可以用于在DOM元素上执行更复杂的操作。</li>
<li><strong>管道函数</strong>：在 Vuex 或其他状态管理库中，你可能会使用“管道”或“链式函数”来处理状态。这可以看作是在 Vue 3 中实现类似过滤器功能的一种方式。</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>虽然 Vue 3.x 不再支持过滤器，但你可以使用其他功能强大的工具和技术来替代它们。对于简单的文本格式化，你可以直接在模板中调用方法；对于更复杂的逻辑，计算属性是一个很好的选择。</p>
<h4 id="Vue中的component动态组件"><a href="#Vue中的component动态组件" class="headerlink" title="Vue中的component动态组件"></a>Vue中的component动态组件</h4><p>在Vue中，<code>component</code> 元素可以作为一个动态组件使用，它允许你在同一个挂载点动态地切换多个组件。<code>&lt;component&gt;</code> 元素有一个特殊的 <code>is</code> 属性，这个属性用于动态地绑定到要渲染的组件上。</p>
<p><strong>使用场景</strong></p>
<p>动态组件在很多场景下都非常有用，比如：</p>
<ul>
<li>根据用户的交互来切换不同的视图。</li>
<li>创建一个通用的组件容器，该容器可以根据传入的不同参数来渲染不同的组件。</li>
<li>在路由系统中，根据路由的不同来动态地渲染不同的页面组件。</li>
</ul>
<p><strong>示例</strong></p>
<p>下面是一个简单的示例，演示了如何使用 <code>&lt;component&gt;</code> 元素来动态地切换组件：</p>
<pre class=" language-vue"><code class="language-vue"><template>  
  <div id="app">  
    <button @click="currentComponent = 'ComponentA'">显示组件A</button>  
    <button @click="currentComponent = 'ComponentB'">显示组件B</button>  
    <component :is="currentComponent"></component>  
  </div>  
</template>  
  
<script>  
import ComponentA from './components/ComponentA.vue'  
import ComponentB from './components/ComponentB.vue'  
  
export default {  
  data() {  
    return {  
      currentComponent: 'ComponentA'  
    }  
  },  
  components: {  
    ComponentA,  
    ComponentB  
  }  
}  
</script>
</code></pre>
<p>在上面的示例中，我们有两个按钮，分别用于切换要显示的组件。<code>currentComponent</code> 数据属性用于存储当前要显示的组件的名称。然后，在 <code>&lt;component&gt;</code> 元素上使用 <code>:is</code> 绑定来动态地设置要渲染的组件。</p>
<p><strong>注意事项</strong></p>
<ul>
<li><code>&lt;component&gt;</code> 元素的 <code>is</code> 属性可以是组件的注册名称（字符串形式），也可以是组件的构造函数（对象形式）。在上面的示例中，我们使用了字符串形式的注册名称。</li>
<li>动态组件在切换时，默认会销毁之前的组件实例，并重新创建新的实例。这意味着，如果你在组件中使用了生命周期钩子（如 <code>created</code>、<code>mounted</code>、<code>destroyed</code> 等），这些钩子会在组件切换时被触发。</li>
<li>如果你想保留组件的状态或避免重新渲染，可以使用 <code>&lt;keep-alive&gt;</code> 元素来包裹 <code>&lt;component&gt;</code> 元素。这样，当组件切换时，Vue 会缓存被移除的组件实例，而不是销毁它们。当组件再次被使用时，Vue 会从缓存中取出该组件实例，而不是重新创建新的实例。</li>
</ul>
<p>希望这可以帮助你理解Vue中的动态组件！</p>
<h4 id="Vue渲染列表为什么要加key"><a href="#Vue渲染列表为什么要加key" class="headerlink" title="Vue渲染列表为什么要加key?"></a>Vue渲染列表为什么要加key?</h4><p>在Vue中渲染列表时加<code>key</code>的主要原因是为了提高渲染性能和保持组件状态的一致性。具体来说，<code>key</code>的作用主要体现在以下几个方面：</p>
<ol>
<li><strong>提高渲染性能</strong>：Vue在渲染列表时，使用了一种称为“虚拟DOM”的技术来优化性能。当数据变化时，Vue会生成一个新的虚拟DOM树，并与旧的虚拟DOM树进行对比，找出需要更新的部分，并只更新这些部分，而不是整个DOM树。而<code>key</code>就是Vue用来标识每个列表项的唯一标识符。当列表数据变化时，Vue会根据<code>key</code>来快速定位到需要更新的列表项，而不是重新渲染整个列表，从而大大提高了渲染性能。</li>
<li><strong>保持组件状态</strong>：在Vue中，每个组件都有自己的状态。当列表数据变化时，如果不使用<code>key</code>，Vue可能会错误地复用旧的组件实例来渲染新的数据，导致组件状态混乱。而使用<code>key</code>后，Vue可以准确地识别每个组件，确保在重新渲染时能够正确地保持组件的状态。这对于保持页面数据和用户操作的一致性非常重要。</li>
<li><strong>避免数据混乱</strong>：如果不使用<code>key</code>，当列表数据变化时（如删除、添加或移动列表项），Vue可能会因为无法准确识别每个列表项而导致数据混乱。例如，在删除一个列表项后，如果不使用<code>key</code>，Vue可能会错误地将其他列表项的内容更新为被删除项的内容。而使用<code>key</code>后，Vue可以准确地识别每个列表项，从而避免这种数据混乱的情况。</li>
</ol>
<p>因此，在Vue中渲染列表时加<code>key</code>是一个非常重要的优化措施，它可以帮助我们提高渲染性能、保持组件状态的一致性并避免数据混乱。同时，需要注意的是，<code>key</code>的值应该是唯一的且稳定的，最好使用每个列表项的唯一标识符（如ID）作为<code>key</code>的值。</p>
<h4 id="Vue中常用的修饰符有哪些？"><a href="#Vue中常用的修饰符有哪些？" class="headerlink" title="Vue中常用的修饰符有哪些？"></a>Vue中常用的修饰符有哪些？</h4><p>在Vue中，常用的修饰符主要分为几类：事件修饰符、按键修饰符、系统修饰符以及v-model修饰符。以下是对这些修饰符的简要说明：</p>
<ol>
<li><strong>事件修饰符</strong>：<ul>
<li><code>.stop</code>：阻止事件冒泡。当事件在元素上被触发时，事件将不会进一步冒泡到父元素。</li>
<li><code>.prevent</code>：阻止默认事件行为。例如，阻止表单的提交或阻止a标签的默认跳转行为。</li>
<li><code>.capture</code>：添加事件监听器时使用事件捕获模式，即内部元素触发的事件先在此处理，然后才交由内部元素进行处理。</li>
<li><code>.self</code>：只有元素本身触发时才触发方法，即只有点击元素本身才会触发。</li>
<li><code>.once</code>：事件只会触发一次，之后就会自动移除事件监听器。</li>
<li><code>.passive</code>：不阻止默认行为，但告诉浏览器该监听器不会调用<code>preventDefault()</code>。</li>
</ul>
</li>
<li><strong>按键修饰符</strong>：</li>
</ol>
<p>这些修饰符通常与键盘事件（如<code>@keyup</code>、<code>@keydown</code>）一起使用，用于监听按了哪个键。常见的按键修饰符有：<code>.enter</code>、<code>.tab</code>、<code>.delete</code>、<code>.esc</code>、<code>.up</code>、<code>.down</code>、<code>.left</code>、<code>.right</code>等。</p>
<ol start="3">
<li><strong>系统修饰符</strong>：</li>
</ol>
<p>这些修饰符用于监听系统修饰键的状态，如<code>.ctrl</code>、<code>.shift</code>、<code>.alt</code>、<code>.meta</code>（在Mac系统键盘上，meta对应command键）。</p>
<ol start="4">
<li><strong>v-model修饰符</strong>：</li>
</ol>
<pre><code>* `.lazy`：默认情况下，v-model在每次input事件触发后将输入框的值与数据进行同步。而`.lazy`修饰符则会在光标离开输入框时才进行同步。  
* `.trim`：自动过滤用户输入的首尾空格。  
* `.number`：将用户的输入转换为数值类型，如果用户的输入不能转换为有效的数值，则返回原始输入。
</code></pre>
<p>这些修饰符可以帮助我们更精细地控制Vue中的事件和输入行为，提高应用的交互性和用户体验。</p>
<h4 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h4><p><code>v-if</code> 和 <code>v-show</code> 都是 Vue 中的条件渲染指令，用于根据条件来控制元素的显示和隐藏。它们之间的区别如下：</p>
<blockquote>
<ol>
<li>编译时机：<code>v-if</code> 是在编译阶段进行条件判断，如果条件为假，那么该元素及其子元素将不会被编译和渲染到 DOM 中。而 <code>v-show</code> 是在编译阶段将元素渲染到 DOM 中，然后通过 CSS 的 <code>display</code> 属性控制元素的显示和隐藏。</li>
<li>切换消耗：由于 <code>v-if</code> 是在编译阶段进行条件判断，当条件发生变化时，会触发元素的创建或销毁，因此切换时的消耗较大。而 <code>v-show</code> 只是通过修改 CSS 的 <code>display</code> 属性来切换元素的可见性，所以切换时的消耗较小。</li>
<li>初始渲染开销：由于 <code>v-if</code> 是在编译阶段进行条件判断，当条件为假时，元素及其子元素不会被编译和渲染，所以初始渲染的开销较小。而 <code>v-show</code> 在初始渲染时，会将元素及其子元素都渲染到 DOM 中，然后通过 CSS 控制其可见性，所以初始渲染的开销较大。</li>
<li>条件切换频率：如果需要频繁切换元素的显示和隐藏，建议使用 <code>v-show</code>，因为它只是通过修改 CSS 属性来切换，性能更好。如果切换频率较低，可以使用 <code>v-if</code>，因为它在条件为假时会销毁元素，可以减少页面中的 DOM 元素数量。</li>
</ol>
</blockquote>
<p>​    <code>v-if</code> 适用于条件切换频率较低的情况，可以节省初始渲染开销和内存占用；<code>v-show</code> 适用于频繁切换元素的可见性，可以减少切换消耗。根据具体的需求和场景选择合适的条件渲染指令。</p>
<h4 id="v-if-和-v-for-哪个优先级更高"><a href="#v-if-和-v-for-哪个优先级更高" class="headerlink" title="v-if 和 v-for 哪个优先级更高"></a>v-if 和 v-for 哪个优先级更高</h4><p>​    在 Vue 中，<code>v-for</code> 指令的优先级高于 <code>v-if</code> 指令。这意味着当一个元素同时使用了 <code>v-if</code> 和 <code>v-for</code>，<code>v-for</code> 将首先被解析和执行，然后在每个迭代的元素上进行 <code>v-if</code> 的条件判断。</p>
<p>​    具体来说，当使用 <code>v-if</code> 和 <code>v-for</code> 同时存在于同一个元素上时，Vue 的编译器会先处理 <code>v-for</code>，根据数据集合生成对应的元素列表。然后，在每个生成的元素上，会再依次应用 <code>v-if</code> 的条件判断。这意味着，如果 <code>v-if</code> 的条件为假，对应的元素将不会被渲染到最终的 DOM 中。</p>
<p>​    <code>v-for</code> 会先根据 <code>items</code> 数据集合生成对应的元素列表，然后在每个元素上应用 <code>v-if</code> 的条件判断。只有当 <code>item.visible</code> 的值为真时，对应的元素才会被渲染到最终的 DOM 中。</p>
<p>​    需要注意的是，在某些特定情况下，使用 <code>v-if</code> 和 <code>v-for</code> 同时存在可能会导致性能问题，因为每次迭代都需要进行条件判断。在这种情况下，可以考虑使用计算属性或过滤器来预先筛选数据集合，以减少渲染的元素数量，从而提升性能。</p>
<h4 id="slot（插槽）的作用"><a href="#slot（插槽）的作用" class="headerlink" title="slot（插槽）的作用"></a>slot（插槽）的作用</h4><p>​    插槽（Slot）是 Vue 中一种用于扩展组件内容的机制。通过插槽，你可以在组件的模板中预留出一些位置，然后在使用该组件时，将内容插入到这些位置上。</p>
<p>插槽的作用主要有以下几个方面：</p>
<blockquote>
<ol>
<li>内容分发：插槽允许组件的使用者向组件中传递内容，并在组件内部进行渲染。使用插槽可以将组件设计得更加灵活，使得组件可以接受不同的内容进行渲染，从而满足不同的需求。</li>
<li>组件组合：通过插槽，你可以将多个组件组合在一起，形成更复杂的组合组件。插槽使得组件之间的组合变得简单，你可以将多个组件的内容组合在一起，并且可以在父组件中决定如何组合它们。</li>
<li>默认内容：插槽可以设置默认内容，当使用组件时没有提供具体内容时，将会使用默认的插槽内容进行渲染。这样可以确保即使没有传入内容，组件仍然可以正常显示一些默认的内容。</li>
</ol>
</blockquote>
<p>​    在 Vue 中，有两种类型的插槽：具名插槽和默认插槽。具名插槽允许你为插槽指定名称，并在组件中根据名称进行内容分发。默认插槽是没有名称的，当组件中没有具名插槽时，会将内容分发到默认插槽中。</p>
<p>​    通过使用插槽，你可以将组件的结构和样式与具体的内容进行解耦，提高了组件的可复用性和灵活性。它是 Vue 中非常强大和常用的特性之一。</p>
<h4 id="关于-Vue-的单向数据流"><a href="#关于-Vue-的单向数据流" class="headerlink" title="关于 Vue 的单向数据流"></a>关于 Vue 的单向数据流</h4><p>​    数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<blockquote>
<p>注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</p>
</blockquote>
<p>​    如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改。</p>
<h4 id="computed-和-watch-的区别和运用的场景"><a href="#computed-和-watch-的区别和运用的场景" class="headerlink" title="computed 和 watch 的区别和运用的场景"></a>computed 和 watch 的区别和运用的场景</h4><p>​    computed 是<a target="_blank" rel="noopener" href="https://juejin.cn/post/6956407362085191717">计算属性</a>，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。</p>
<p>​    <a target="_blank" rel="noopener" href="https://juejin.cn/post/6954925963226382367">watch</a>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p>
<p>​    计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑计算属性原理详解 </p>
<h4 id="Vue中的异步组件"><a href="#Vue中的异步组件" class="headerlink" title="Vue中的异步组件"></a>Vue中的异步组件</h4><p>在Vue中，异步组件是一种优化手段，用于在需要时才加载组件，从而加快页面的初始加载速度和提高用户体验。Vue提供了两种主要的方式来定义和使用异步组件：</p>
<ol>
<li><strong>使用webpack的import()方法</strong>：</li>
</ol>
<p>你可以使用webpack提供的<code>import()</code>方法来定义一个异步组件。<code>import()</code>方法允许你在运行时动态加载代码。下面是一个基本的异步组件定义方式：</p>
<pre class=" language-javascript"><code class="language-javascript">javascript复制代码

Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'MyComponent'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./MyComponent.vue'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>注意，异步组件的定义方式必须是一个函数，该函数返回一个Promise对象。当组件被渲染时，Vue.js会自动地检测到该组件是异步组件并进行动态加载。</p>
<ol start="2">
<li><strong>使用工厂函数</strong>：</li>
</ol>
<p>你也可以使用工厂函数来定义异步组件。工厂函数接收两个参数：<code>resolve</code>和<code>reject</code>，用于异步加载组件。当组件加载成功时，调用<code>resolve</code>并传入组件的定义；当加载失败时，调用<code>reject</code>并传入错误原因。下面是一个示例：</p>
<pre class=" language-javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'async-component'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  <span class="token comment" spellcheck="true">// 异步加载组件  </span>
  <span class="token comment" spellcheck="true">// 例如，使用require或其他异步加载方法  </span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./AsyncComponent.vue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>在上面的例子中，当<code>AsyncComponent.vue</code>被成功加载后，Vue会将其注册为名为<code>async-component</code>的组件。</p>
<p><strong>使用异步组件的注意事项</strong>：</p>
<ul>
<li>异步组件在加载时会被替换成占位符（如一个空白的<code>&lt;div&gt;</code>），直到加载完成。因此，你需要确保你的异步组件加载过程不会影响用户体验。</li>
<li>异步组件的加载是异步的，因此你无法确保它们在页面渲染时一定可用。在需要使用异步组件的地方，你需要做好错误处理和降级处理。</li>
<li>当你的项目达到一定的规模时，使用异步组件可以有效地提高页面的初始加载速度，从而提高用户体验。但是，过度使用异步组件可能会导致代码结构复杂和难以维护。因此，你需要在性能和可维护性之间找到一个平衡点。</li>
</ul>
<h4 id="Vue中异步组件与路由懒加载有什么关系"><a href="#Vue中异步组件与路由懒加载有什么关系" class="headerlink" title="Vue中异步组件与路由懒加载有什么关系"></a>Vue中异步组件与路由懒加载有什么关系</h4><p>Vue中的异步组件与路由懒加载是密切相关的。</p>
<p>异步组件是Vue提供的一种性能优化方案，它允许我们在需要时才加载某些组件，而不是一开始就全部加载。这种方式可以很好地提高用户体验，加快页面的载入速度。</p>
<p>而路由懒加载（也叫延迟加载或按需加载）是在单页面应用（SPA）中，将页面进行划分，在需要的时候加载页面，从而有效地分担首页所承担的加载压力，减少首页加载用时。在Vue.js中，路由懒加载是通过使用Vue的异步组件和Webpack的代码分割功能来实现的。</p>
<p>具体来说，当我们配置Vue Router的路由时，可以将路由配置中的component属性改为一个返回Promise的函数，函数的返回值是一个包含要加载的组件的模块。这个模块就是通过动态import语法来异步加载的组件。当路由被访问时，Webpack会自动将相应的组件代码分割到一个新的bundle中，并仅在需要时加载它。</p>
<p>因此，可以说Vue中的异步组件是实现路由懒加载的一种手段，而路由懒加载则是异步组件在实际应用中的一种应用场景。</p>
<h4 id="Vue中scoped的作用与原理"><a href="#Vue中scoped的作用与原理" class="headerlink" title="Vue中scoped的作用与原理"></a>Vue中scoped的作用与原理</h4><p>在Vue中，<code>scoped</code>是一个用于<code>&lt;style&gt;</code>标签的特殊属性，其主要作用和原理如下：</p>
<p><strong>作用</strong></p>
<ol>
<li><strong>避免样式冲突</strong>：当在一个大型项目中，多个开发者可能同时编写组件，<code>scoped</code>可以确保每个组件的样式仅作用于当前组件，避免样式冲突。</li>
<li><strong>提高可维护性</strong>：由于<code>scoped</code>样式仅在当前组件内生效，当需要修改样式时，可以更容易地在组件内定位到相关样式，而不用担心影响其他组件。</li>
<li><strong>增强安全性</strong>：使用<code>scoped</code>可以增强组件的安全性，避免非预期的样式覆盖或影响到其他组件。</li>
</ol>
<p><strong>原理</strong></p>
<p><code>scoped</code>的实现原理主要依赖于Vue在编译过程中为每个组件的DOM元素添加一个唯一的属性（如<code>data-v-f3f3eg9</code>），然后在CSS选择器后添加该属性来实现样式的局部化。例如，如果你的组件有一个类名为<code>.my-class</code>的元素，Vue在编译后可能会将其转化为类似<code>.my-class[data-v-f3f3eg9]</code>的选择器，这样这个样式就只会应用于当前组件中带有<code>data-v-f3f3eg9</code>属性的<code>.my-class</code>元素。</p>
<p>然而，需要注意的是，虽然<code>scoped</code>提供了样式隔离的功能，但在某些情况下，你可能需要修改或覆盖引入的外部组件的样式。在这种情况下，你可能需要使用样式穿透（例如使用<code>::v-deep</code>或<code>&gt;&gt;&gt;</code>选择器）来覆盖外部组件的样式。</p>
<p>总的来说，<code>scoped</code>是Vue提供的一种强大的工具，用于解决样式冲突和提高组件的可维护性和安全性。但在使用时，也需要注意其可能带来的限制和需要额外的处理的情况。</p>
<h4 id="Vue项目中如何解决跨越问题？"><a href="#Vue项目中如何解决跨越问题？" class="headerlink" title="Vue项目中如何解决跨越问题？"></a>Vue项目中如何解决跨越问题？</h4><p>在Vue项目中，跨域问题（CORS，Cross-Origin Resource Sharing）通常是由于浏览器安全策略限制，阻止前端代码从与其源（协议、域名和端口）不同的后端服务器加载资源。为了解决这个问题，你可以采取以下几种方法：</p>
<p><strong>1. 后端配置CORS</strong></p>
<p>在后端服务器配置CORS策略，允许来自特定源（或所有源）的请求。这通常涉及到设置HTTP响应头，如<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>等。</p>
<p>例如，在Express.js中，你可以使用<code>cors</code>中间件来轻松配置CORS：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">const</span> cors <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cors'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">cors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 允许所有源访问  </span>
  
<span class="token comment" spellcheck="true">// 或者指定允许的源  </span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">cors</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  origin<span class="token punctuation">:</span> <span class="token string">'http://example.com'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 只允许来自http://example.com的请求  </span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'POST'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 允许的HTTP方法  </span>
  allowedHeaders<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'Authorization'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 允许的请求头  </span>
  credentials<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 允许携带凭据（如cookies、HTTP认证及客户端SSL证明等）  </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 其他中间件和路由...</span>
</code></pre>
<p><strong>2. 代理服务器（Proxy Server）</strong></p>
<p>在开发环境中，你可以使用代理服务器来转发请求。Vue CLI项目提供了<code>vue.config.js</code>文件来配置开发服务器的代理设置。你可以在<code>devServer.proxy</code>选项中指定代理规则。</p>
<p>例如：</p>
<pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  
  devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
    proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
      <span class="token string">'/api'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>  
        target<span class="token punctuation">:</span> <span class="token string">'http://example.com'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 目标服务器地址  </span>
        changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 开启代理，允许跨域  </span>
        pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span>  
          <span class="token string">'^/api'</span><span class="token punctuation">:</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">// 重写路径，例如将'/api/users'转换为'/users'  </span>
        <span class="token punctuation">}</span>  
      <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>3. JSONP</strong></p>
<p>对于GET请求，你可以考虑使用JSONP（JSON with Padding）作为一种替代方案。JSONP通过在URL后添加一个回调函数名来绕过浏览器的同源策略限制。但是，JSONP只支持GET请求，并且存在安全风险（如XSS攻击）。</p>
<p><strong>4. 使用CORS代理插件</strong></p>
<p>在开发环境中，你可以使用浏览器插件（如Allow CORS: Access-Control-Allow-Origin）来暂时绕过浏览器的CORS限制。但是请注意，这种方法仅适用于开发环境，并且不适用于生产环境。</p>
<p><strong>5. 检查前端代码</strong></p>
<p>确保你的前端代码没有错误地设置CORS请求头（如<code>Access-Control-Allow-Origin</code>），因为这些头应该是由后端服务器设置的，而不是前端。</p>
<p><strong>6. 考虑使用其他技术栈</strong></p>
<p>如果你经常遇到跨域问题，并且后端服务器不支持CORS或代理设置，你可能需要考虑使用其他技术栈或框架，这些技术栈或框架提供了更好的跨域支持或内置了代理功能。</p>
<h4 id="Vue中设置过哪些异常处理？"><a href="#Vue中设置过哪些异常处理？" class="headerlink" title="Vue中设置过哪些异常处理？"></a>Vue中设置过哪些异常处理？</h4><p>在Vue中，有几种常见的异常处理方式：</p>
<ol>
<li>使用try-catch语句捕获异常<ul>
<li>这是JavaScript中处理异常的基本方法。在Vue中，你可以在可能引发异常的代码周围使用try-catch语句。try块中包含可能抛出异常的代码，而catch块则用于捕获并处理这些异常。</li>
</ul>
</li>
<li>使用Vue.config.errorHandler处理全局错误<ul>
<li>Vue提供了一个全局配置属性<code>Vue.config.errorHandler</code>，它允许你定义一个全局的错误处理函数来捕获整个应用程序中的错误。这个函数会在组件渲染函数和生命周期钩子执行期间被调用，无论是否有错误发生。你可以在这里对错误进行一些处理，比如向后端发送错误日志。</li>
</ul>
</li>
<li>使用Vue.mixin混入处理异常<ul>
<li>Vue.mixin是Vue提供的一种混入特性，可以用来扩展Vue组件。你可以通过混入一个包含错误处理逻辑的对象来统一处理组件中的异常。这允许你在不修改每个组件的情况下，为所有组件添加错误处理逻辑。</li>
</ul>
</li>
<li>使用axios拦截器处理异常<ul>
<li>如果你的Vue应用与后端进行HTTP通信，可能会使用axios等HTTP库。你可以通过axios的拦截器来捕获HTTP请求和响应中的异常，并统一处理这些异常。例如，你可以在拦截器中检查响应状态码，如果状态码表示错误，则执行相应的错误处理逻辑。</li>
</ul>
</li>
<li>设置Vue的错误边界<ul>
<li>Vue 2.x和Vue 3.x都提供了错误边界（Error Boundaries）的概念。在Vue 2.x中，你可以使用<code>errorCaptured</code>钩子来捕获并处理子组件中的错误。在Vue 3.x中，你可以使用<code>setup</code>函数中的<code>onErrorCaptured</code>选项来实现相同的功能。这些错误边界可以防止错误在组件树中向上冒泡，并允许你以集中的方式处理这些错误。</li>
</ul>
</li>
<li>自定义全局错误提示<ul>
<li>除了上述方法外，你还可以创建一个自定义的全局错误提示组件，用于显示错误信息和提示用户。当捕获到错误时，你可以将错误信息传递给这个组件，并在页面上显示它。这可以提高用户体验，使用户更清楚地了解发生了什么问题。</li>
</ul>
</li>
</ol>
<h4 id="Vue-use函数具体做了哪些事？"><a href="#Vue-use函数具体做了哪些事？" class="headerlink" title="Vue.use函数具体做了哪些事？"></a>Vue.use函数具体做了哪些事？</h4><p><code>Vue.use()</code> 是 Vue.js 中的一个方法，它用于安装 Vue.js 插件。插件通常会为 Vue 添加全局级别的功能。例如，官方提供的 <code>vue-router</code> 插件用于添加路由管理功能，而 <code>vuex</code> 插件则用于添加状态管理功能。</p>
<p><code>Vue.use()</code> 函数的主要步骤如下：</p>
<ol>
<li><strong>检查插件是否已经安装</strong>：<br><code>Vue.use()</code> 会首先检查该插件是否已经被安装（即是否已经通过 <code>Vue.use()</code> 调用过）。如果是，它会阻止插件的重复安装并直接返回。</li>
<li><strong>调用插件的 <code>install</code> 方法</strong>：<br>每个 Vue.js 插件都应该暴露一个 <code>install</code> 方法。<code>Vue.use()</code> 会调用这个 <code>install</code> 方法，并将 Vue 构造函数和可选的选项参数作为参数传递给该方法。这样，插件就可以在 <code>install</code> 方法内部添加全局功能、混入、指令等。</li>
<li><strong>添加插件到 Vue 的已安装插件列表中</strong>：<br>为了确保插件不会被重复安装，<code>Vue.use()</code> 会将已安装的插件添加到一个内部列表中。这样，在后续尝试安装相同插件时，可以迅速检查并阻止重复安装。</li>
</ol>
<p>下面是一个简单的示例，展示了如何创建一个 Vue.js 插件并使用 <code>Vue.use()</code> 进行安装：</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 创建一个 Vue 插件  </span>
<span class="token keyword">const</span> MyPlugin <span class="token operator">=</span> <span class="token punctuation">{</span>  
  <span class="token function">install</span><span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">// 1. 添加全局方法或属性  </span>
    Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$myMethod <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token function">alert</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">;</span>  
  
    <span class="token comment" spellcheck="true">// 2. 添加全局资源  </span>
    Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  
      <span class="token function">bind</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment" spellcheck="true">// 指令的逻辑  </span>
        <span class="token comment" spellcheck="true">// ...  </span>
      <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
    <span class="token comment" spellcheck="true">// 3. 注入组件选项  </span>
    Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
      created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment" spellcheck="true">// 混入逻辑  </span>
        <span class="token comment" spellcheck="true">// ...  </span>
      <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
    <span class="token comment" spellcheck="true">// 4. 添加实例方法  </span>
    Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$myInstanceMethod <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>methodOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token comment" spellcheck="true">// 实例方法逻辑  </span>
      <span class="token comment" spellcheck="true">// ...  </span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>  
  
    <span class="token comment" spellcheck="true">// 接收传入的选项参数  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
      <span class="token comment" spellcheck="true">// 使用 options 做一些其他事情  </span>
    <span class="token punctuation">}</span>  
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
  
<span class="token comment" spellcheck="true">// 使用 Vue.use() 安装插件  </span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>MyPlugin<span class="token punctuation">,</span> <span class="token punctuation">{</span> someOption<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>在这个示例中，我们创建了一个名为 <code>MyPlugin</code> 的 Vue 插件，它包含了全局方法、指令、混入和实例方法。然后，我们使用 <code>Vue.use()</code> 方法将该插件安装到 Vue 中，并传递了一个选项对象 <code>&#123; someOption: true &#125;</code>。在 <code>MyPlugin</code> 的 <code>install</code> 方法内部，我们可以根据需要使用这些选项。</p>
<h4 id="Vue为什么采用异步渲染？"><a href="#Vue为什么采用异步渲染？" class="headerlink" title="Vue为什么采用异步渲染？"></a>Vue为什么采用异步渲染？</h4><p>Vue采用异步渲染主要有以下几个原因：</p>
<ol>
<li><strong>性能优化</strong>：在DOM操作中，直接操作真实的DOM是非常昂贵的，因为它涉及到浏览器的重排和重绘。Vue将这些DOM操作进行了抽象和封装，并尽量减少了直接操作DOM的次数。通过异步渲染，Vue可以将多个状态变化合并成一个，然后一次性进行DOM更新，从而减少了浏览器的重排和重绘次数，提高了性能。</li>
<li><strong>响应式系统</strong>：Vue的响应式系统是其核心特性之一。当Vue实例的数据发生变化时，视图会自动更新。这种响应式更新是异步的，因为Vue需要收集这些变化，并在适当的时候进行更新。这种设计可以避免不必要的计算和渲染，进一步提高了性能。在某些情况下，用户可能连续触发多个状态变化，如果Vue对每个变化都立即进行渲染，可能会导致页面频繁闪烁或卡顿。</li>
<li><strong>用户体验</strong>：当页面需要渲染大量的数据时，同步渲染可能会造成页面的长时间卡顿，给用户带来不良的体验。而异步渲染可以将渲染过程分成多个小任务，每个小任务可以在后台执行，减少页面的卡顿感，从而提高用户体验。</li>
<li><strong>可维护性</strong>：通过将渲染过程分解成多个小任务，异步渲染不仅可以提高页面加载的速度，还可以更好地组织和管理代码，从而提高代码的可维护性。</li>
<li><strong>可访问性</strong>：通过采用异步渲染，可以在后台进行一些额外的处理，例如优化HTML结构、剔除无效的标签等，从而提高页面的可访问性。</li>
</ol>
<p>总的来说，Vue采用异步渲染是为了提升性能、优化用户体验、提高代码的可维护性和可访问性。这使得Vue成为了一个强大且灵活的前端框架。</p>
<h4 id="从0到1自己构架一个Vue项目"><a href="#从0到1自己构架一个Vue项目" class="headerlink" title="从0到1自己构架一个Vue项目"></a>从0到1自己构架一个Vue项目</h4><p>从0到1自己构架一个Vue项目可以是一个很好的学习经验。以下是一个基本的步骤指南，帮助你开始这个过程：</p>
<p><strong>1. 初始化项目</strong></p>
<ol>
<li><strong>安装Node.js和npm</strong>：确保你的机器上已经安装了Node.js和npm（Node.js的包管理器）。</li>
<li><strong>创建一个新的项目文件夹</strong>：在你的文件系统中创建一个新的文件夹，用于存放你的Vue项目。</li>
<li><strong>初始化npm</strong>：在项目文件夹中打开终端，运行<code>npm init -y</code>（或<code>npm init</code>后按照提示填写信息）来初始化一个基本的<code>package.json</code>文件。</li>
</ol>
<p><strong>2. 安装Vue CLI</strong></p>
<p>Vue CLI是一个官方提供的脚手架工具，可以帮助你快速构建Vue项目。</p>
<ol>
<li><strong>全局安装Vue CLI</strong>：运行<code>npm install -g @vue/cli</code>来安装Vue CLI。</li>
</ol>
<p><strong>3. 创建Vue项目</strong></p>
<p>使用Vue CLI来创建你的Vue项目。</p>
<ol>
<li><strong>运行Vue CLI</strong>：在项目文件夹中运行<code>vue create my-project</code>（<code>my-project</code>是你的项目名称，可以替换为你想要的名字）。</li>
<li><strong>选择预设或手动配置</strong>：Vue CLI会提示你选择预设的配置或者手动配置。如果你不确定，可以选择默认预设或者手动配置以选择你需要的特性和工具。</li>
<li><strong>等待项目创建完成</strong>：Vue CLI会根据你的选择自动安装所需的依赖并创建项目结构。</li>
</ol>
<p><strong>4. 项目结构</strong></p>
<p>一个基本的Vue项目通常包含以下文件和文件夹：</p>
<ul>
<li><p>**<code>node_modules</code>**：包含项目的所有依赖。</p>
</li>
<li><p>**<code>public</code>**：包含静态资源，如favicon.ico和index.html。</p>
</li>
<li><p><code>src</code></p>
<p>：包含项目的源代码。</p>
<ul>
<li>**<code>assets</code>**：包含图片、字体等静态资源。</li>
<li>**<code>components</code>**：包含Vue组件。</li>
<li>**<code>router</code>**：包含Vue Router的配置。</li>
<li>**<code>store</code>**（如果你选择了Vuex）：包含Vuex的状态管理配置。</li>
<li>**<code>views</code>**：包含页面级别的组件。</li>
<li>**<code>App.vue</code>**：主组件。</li>
<li>**<code>main.js</code>**：入口文件，用于初始化Vue实例和挂载根组件。</li>
</ul>
</li>
<li><p>**<code>.gitignore</code>**：用于指定Git仓库中需要忽略的文件和文件夹。</p>
</li>
<li><p>**<code>babel.config.js</code>**：Babel的配置文件。</p>
</li>
<li><p>**<code>package.json</code>**：包含项目的元数据和依赖信息。</p>
</li>
<li><p>**<code>README.md</code>**：项目的说明文档。</p>
</li>
</ul>
<p><strong>5. 编写代码</strong></p>
<p>现在你可以开始编写你的Vue代码了。你可以按照以下步骤进行：</p>
<ol>
<li><strong>编写组件</strong>：在<code>src/components</code>文件夹中创建你的Vue组件。每个组件应该包含一个<code>.vue</code>文件，该文件包含了组件的模板、脚本和样式。</li>
<li><strong>配置路由</strong>：如果你选择了Vue Router，你需要在<code>src/router/index.js</code>文件中配置你的路由。每个路由应该映射到一个Vue组件。</li>
<li><strong>管理状态</strong>（如果你选择了Vuex）：在<code>src/store</code>文件夹中配置你的Vuex状态管理。你可以定义状态、mutations、actions和getters等。</li>
<li><strong>编写页面</strong>：在<code>src/views</code>文件夹中创建你的页面级别的组件。这些组件通常用于构建你的应用的各个页面。</li>
<li><strong>集成和测试</strong>：将你的组件、路由和状态管理集成到你的应用中，并进行测试以确保一切正常工作。</li>
<li><strong>构建和部署</strong>：当你完成开发后，你可以使用Vue CLI的命令来构建你的应用（<code>npm run build</code>），并将构建后的文件部署到你的服务器或CDN上。</li>
</ol>
<p><strong>6. 学习和资源</strong></p>
<ul>
<li><strong>Vue官方文档</strong>：Vue的官方文档是一个很好的学习资源，它包含了Vue的基础知识、组件、指令、路由、状态管理等内容的详细解释和示例。</li>
<li><strong>Vue Router和Vuex</strong>：如果你打算在你的项目中使用路由和状态管理，你应该熟悉Vue Router和Vuex的文档和用法。</li>
<li><strong>Vue社区</strong>：Vue有一个庞大的社区，你可以通过论坛、Stack Overflow、GitHub等问题解答平台来获取帮助和解答你的问题。</li>
<li><strong>教程和示例</strong>：有许多教程和示例可以帮助你更好地理解和使用Vue。你可以搜索在线教程、观看教学视频或阅读相关书籍来学习Vue的更多内容。</li>
</ul>
<h4 id="Vue中动画怎么实现？"><a href="#Vue中动画怎么实现？" class="headerlink" title="Vue中动画怎么实现？"></a>Vue中动画怎么实现？</h4><p>在Vue中，你可以通过多种方式来实现动画效果。Vue 提供了内置的过渡（transition）组件和动画（animation）类名，使得你可以很方便地为元素或组件添加过渡动画。以下是一些实现Vue动画的基本方法：</p>
<ol>
<li><strong>使用Vue的<code>&lt;transition&gt;</code>组件</strong></li>
</ol>
<p>Vue 提供了一个内置的 <code>&lt;transition&gt;</code> 组件，该组件可以在元素或组件进入/离开时应用过渡效果。你可以通过 <code>name</code> 属性来指定过渡效果的名称，该名称将用于查找对应的 CSS 类名。</p>
<pre class=" language-vue"><code class="language-vue"><template>  
  <transition name="fade">  
    <div v-if="show">Hello</div>  
  </transition>  
</template>  
  
<style>  
.fade-enter-active, .fade-leave-active {  
  transition: opacity .5s;  
}  
.fade-enter, .fade-leave-to {  
  opacity: 0;  
}  
</style>
</code></pre>
<p>在这个例子中，当 <code>show</code> 变量变化时，<code>&lt;div&gt;</code> 元素会淡入或淡出。</p>
<ol>
<li><strong>使用CSS动画</strong></li>
</ol>
<p>你也可以使用 CSS 动画来实现更复杂的过渡效果。你可以通过 <code>name</code> 属性来指定 CSS 动画的名称，该名称将用于查找对应的 CSS 动画。</p>
<pre class=" language-vue"><code class="language-vue"><template>  
  <transition name="bounce">  
    <div v-if="show">Hello</div>  
  </transition>  
</template>  
  
<style>  
@keyframes bounce {  
  0%, 100% { transform: translateY(0); }  
  50% { transform: translateY(-20px); }  
}  
  
.bounce-enter-active {  
  animation: bounce 0.5s;  
}  
</style>
</code></pre>
<p>在这个例子中，当 <code>show</code> 变量变化时，<code>&lt;div&gt;</code> 元素会执行一个弹跳动画。</p>
<ol>
<li><strong>使用第三方库</strong></li>
</ol>
<p>Vue 社区有许多第三方库可以帮助你更方便地实现动画效果，例如 <code>vue-animate.css</code>、<code>vue2-animate</code> 等。这些库通常提供了许多预定义的动画效果，你可以直接在你的 Vue 项目中使用它们。</p>
<ol>
<li><strong>使用JavaScript钩子函数</strong></li>
</ol>
<p>Vue 的 <code>&lt;transition&gt;</code> 组件还提供了 JavaScript 钩子函数，你可以在元素进入/离开的不同阶段执行自定义的 JavaScript 代码。例如，你可以在 <code>enter</code> 钩子函数中启动一个 CSS 动画，并在 <code>after-enter</code> 钩子函数中停止它。</p>
<p>总之，Vue 提供了多种实现动画效果的方法，你可以根据自己的需求选择最适合你的方法。</p>
<h4 id="vue-中使用了哪些设计模式"><a href="#vue-中使用了哪些设计模式" class="headerlink" title="vue 中使用了哪些设计模式"></a>vue 中使用了哪些设计模式</h4><blockquote>
<p>1.工厂模式 - 传入参数即可创建实例</p>
<p>虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p>
<p>2.单例模式 - 整个程序有且仅有一个实例</p>
<p>vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉</p>
<p>3.发布-订阅模式 (vue 事件机制)</p>
<p>4.观察者模式 (响应式数据原理)</p>
<p>5.装饰模式: (@装饰器的用法)</p>
<p>6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p>
</blockquote>
<h4 id="Vue-模板编译原理"><a href="#Vue-模板编译原理" class="headerlink" title="Vue 模板编译原理"></a>Vue 模板编译原理</h4><p>Vue 的模板编译原理主要包括以下步骤：</p>
<blockquote>
<ol>
<li>解析：Vue 的模板编译器将模板字符串解析为抽象语法树（AST）。AST 是一个树状结构，表示了模板中的各个节点和它们之间的关系。</li>
<li>优化：在解析完成后，编译器会对生成的 AST 进行优化。这个优化过程包括静态节点标记、静态根节点提升和事件侦听器的缓存等。这些优化可以提高渲染性能和减少运行时的开销。</li>
<li>代码生成：在优化完成后，编译器会根据 AST 生成渲染函数。渲染函数是一个 JavaScript 函数，它接收数据作为参数，返回一个虚拟 DOM 树。渲染函数可以将模板中的数据和逻辑转换为实际的 DOM 操作。</li>
<li>组件化编译：如果模板中包含组件，编译器会递归地对组件进行编译。这样可以将组件的模板编译为渲染函数，并生成组件的渲染逻辑。</li>
</ol>
</blockquote>
<p>​    在运行时，Vue 实例会通过编译后的渲染函数生成虚拟 DOM，并将其与实际的 DOM 进行比对，只更新需要改变的部分，以提高性能。</p>
<p>​    Vue 的模板编译原理将模板字符串解析为 AST，经过优化后生成渲染函数，然后在运行时使用渲染函数生成虚拟 DOM，并进行差异比对来更新视图。这种编译的过程使得 Vue 具有高效的渲染性能和灵活的组件化开发能力。</p>
<h4 id="Vue中性能优化-项目优化-有哪些？"><a href="#Vue中性能优化-项目优化-有哪些？" class="headerlink" title="Vue中性能优化(项目优化)有哪些？"></a>Vue中性能优化(项目优化)有哪些？</h4><p>在Vue项目中，性能优化是一个重要的方面，可以确保应用能够快速、高效地运行。以下是一些Vue项目性能优化的常见策略：</p>
<p><strong>1. 代码层面的优化</strong></p>
<p><strong>1.1 合理使用v-if和v-show</strong></p>
<ul>
<li><code>v-if</code>：适用于条件不经常改变的场景，因为它会销毁和重建元素。</li>
<li><code>v-show</code>：适用于频繁切换条件的场景，因为它只是通过改变CSS的<code>display</code>属性来切换显示与隐藏。</li>
</ul>
<p><strong>1.2 正确使用computed和watch</strong></p>
<ul>
<li><code>computed</code>：适用于依赖其他数据且需要计算的情况，具有缓存特性。</li>
<li><code>watch</code>：适用于数据变化时需要执行异步或开销较大的操作，可以限制执行频率。</li>
</ul>
<p><strong>1.3 变量本地化</strong></p>
<p>避免在模板中频繁使用<code>this</code>来访问数据，可以将常用变量保存在组件的<code>data</code>或<code>computed</code>属性中。</p>
<p><strong>1.4 代码精简和复用</strong></p>
<ul>
<li>去除不必要的<code>console</code>语句。</li>
<li>提取可复用的方法和组件。</li>
<li>避免行内样式，以减少DOM重绘。</li>
</ul>
<p><strong>2. 路由和组件层面的优化</strong></p>
<p><strong>2.1 路由懒加载</strong></p>
<p>使用Vue Router的懒加载功能，将页面资源划分为多份，按需加载，减少首次加载的消耗。</p>
<p><strong>2.2 keep-alive缓存组件</strong></p>
<p>对于不需要重新渲染的组件，可以使用<code>&lt;keep-alive&gt;</code>进行缓存，避免重复渲染。</p>
<p><strong>2.3 组件的延迟加载</strong></p>
<p>将页面资源划分为多份，按需加载，减少首次加载的消耗。</p>
<p><strong>3. 第三方库和插件的优化</strong></p>
<p><strong>3.1 按需引入第三方库和插件</strong></p>
<p>避免引入整个库，只引入需要的部分，减少项目体积。</p>
<p><strong>3.2 使用轻量级的库和插件</strong></p>
<p>选择体积小、性能好的库和插件。</p>
<p><strong>4. SEO优化</strong></p>
<p><strong>4.1 服务端渲染（SSR）或预渲染</strong></p>
<p>对于需要SEO优化的页面，可以使用服务端渲染或预渲染来提高页面加载速度和搜索引擎的可见性。</p>
<p><strong>5. 调试和性能分析工具</strong></p>
<p><strong>5.1 使用Chrome DevTools</strong></p>
<p>利用Chrome DevTools的Performance和Network工具来录制和分析运行时性能和加载性能问题。</p>
<p><strong>5.2 使用Vue Devtools</strong></p>
<p>Vue Devtools是一个专门为Vue.js开发者设计的浏览器扩展，可以帮助你更好地理解和调试Vue应用。</p>
<p><strong>6. 其他优化策略</strong></p>
<p><strong>6.1 图片懒加载</strong></p>
<p>对于非关键图片，可以使用懒加载技术，当用户滚动到图片位置时才加载图片。</p>
<p><strong>6.2 长列表优化</strong></p>
<p>对于长列表，可以使用虚拟滚动等技术来优化性能。</p>
<p><strong>6.3 防抖和节流函数</strong></p>
<p>对于短时间内的大量操作（如缩放、滚动等），可以使用防抖和节流函数来限制执行频率。</p>
<p><strong>7. 构建和部署优化</strong></p>
<p><strong>7.1 代码分割</strong></p>
<p>使用Webpack等构建工具进行代码分割，将代码拆分成多个小块，按需加载。</p>
<p><strong>7.2 压缩和优化资源</strong></p>
<p>压缩CSS、JavaScript和图片等资源，减少文件大小，提高加载速度。</p>
<p><strong>7.3 使用CDN</strong></p>
<p>将静态资源部署到CDN上，加快资源加载速度。</p>
<p><strong>7.4 缓存策略</strong></p>
<p>设置合理的缓存策略，减少不必要的网络请求。</p>
<h4 id="Vue项目进行-SEO-优化的常用方案"><a href="#Vue项目进行-SEO-优化的常用方案" class="headerlink" title="Vue项目进行 SEO 优化的常用方案"></a>Vue项目进行 SEO 优化的常用方案</h4><p>Vue项目进行SEO优化的常用方案主要包括以下几个方面：</p>
<ol>
<li>预渲染（Prerendering）<ul>
<li>预渲染可以在构建时生成针对每个路由的静态HTML页面，这样搜索引擎爬虫就可以直接获取到页面的内容，从而提高SEO的效果。</li>
<li>可以使用类似Prerender或者Vue官方推荐的prerender-spa-plugin等工具来实现预渲染。</li>
</ul>
</li>
<li>服务端渲染（SSR, Server-Side Rendering）<ul>
<li>通过将Vue应用改造为服务端渲染的形式，可以让搜索引擎直接获取到完整的页面内容，从而提高SEO效果。</li>
<li>Nuxt.js是一个基于Vue的SSR框架，可以帮助你快速实现Vue应用的服务端渲染。</li>
</ul>
</li>
<li>合理的页面结构和语义化的HTML标记<ul>
<li>确保页面结构清晰，使用语义化的HTML标签来描述页面内容，这有助于搜索引擎理解和索引页面内容。</li>
</ul>
</li>
<li>优化关键词使用<ul>
<li>在页面标题、描述、内容等位置合理使用关键词，提高页面在搜索引擎中的相关性。</li>
</ul>
</li>
<li>高质量的内容<ul>
<li>内容是网站的核心，确保你的网站内容独特、有价值，并且与目标受众相关。</li>
</ul>
</li>
<li>提高页面加载速度<ul>
<li>压缩图片大小、优化代码、使用CDN等方法来提高页面加载速度，这不仅可以提高用户体验，还有助于提高搜索引擎排名。</li>
</ul>
</li>
<li>内部链接优化<ul>
<li>通过在网站内部引导用户浏览相关内容，提高网站的转化率和粘性。内部链接的合理设置有助于搜索引擎爬虫更深入地抓取网站内容。</li>
</ul>
</li>
<li>外部链接建设<ul>
<li>高质量的外部链接可以为你的产品网站带来更多的流量和权威性。寻找相关性高的网站，与其建立合作关系，在其网站上引用或链接你的产品网站。</li>
</ul>
</li>
<li>社交媒体优化<ul>
<li>社交媒体已经成为重要的流量来源之一。通过在各大社交媒体平台上发布有关你产品的内容，吸引更多的用户访问和分享。</li>
</ul>
</li>
<li>网站结构优化<ul>
<li>一个良好的网站结构可以让搜索引擎更好地理解和索引你的网站。确保网站结构清晰、层次分明，便于搜索引擎爬虫抓取。</li>
</ul>
</li>
<li>代码优化<ul>
<li>对于Vue项目而言，还可以通过代码优化来提高性能和SEO效果。例如，优化计算属性和监听器、列表渲染性能优化、合理使用v-if和v-show、懒加载组件等。</li>
</ul>
</li>
<li>使用Vue SEO库<ul>
<li>可以考虑使用Vue SEO库，如vue-meta，来管理页面的元数据（如标题、描述等），这有助于搜索引擎更好地了解你的页面内容。</li>
</ul>
</li>
</ol>
<p>请注意，SEO是一个持续的过程，需要不断地优化和调整。同时，SEO效果也受到多种因素的影响，包括但不限于搜索引擎的算法变化、竞争对手的策略等。因此，在进行SEO优化时，需要综合考虑各种因素，并持续跟踪和调整优化策略。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Jayhodon</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章連結:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://Jayhodon.github.io/2023/06/12/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">https://Jayhodon.github.io/2023/06/12/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版權聲明:
                    </i>
                </span>
                <span class="reprint-info">
                    本部落格所有文章除特別聲明外，均採用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    許可協議。轉載請註明來源
                    <a href="/about" target="_blank">Jayhodon</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>複製成功，請遵循本文的轉載規則</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                    <span class="chip bg-color">前端</span>
                                </a>
                            
                                <a href="/tags/Vue/">
                                    <span class="chip bg-color">Vue</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Javascript/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="设计模式 - Javascript">
                        
                        <span class="card-title">设计模式 - Javascript</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            该博文是js的内功进阶修炼 - JavaScript设计模式
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-07-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/Javascript/" class="post-category">
                                    Javascript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                    <a href="/tags/Javascript/">
                        <span class="chip bg-color">Javascript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/05/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="浏览器相关">
                        
                        <span class="card-title">浏览器相关</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            一篇了解、剖析浏览器相关原理知识点的手作指北。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-05-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/" class="post-category">
                                    个人知识库
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目錄</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1 , h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1 , h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2024</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">Jayhodon</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;總訪問量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;總訪問人數:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/jayhodon" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:tang9568@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2324729568" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2324729568" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="請輸入搜索的關鍵字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
